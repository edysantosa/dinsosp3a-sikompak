/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./resources/adminlte/plugins/bootstrap/js/bootstrap.bundle.js":
/*!*********************************************************************!*\
  !*** ./resources/adminlte/plugins/bootstrap/js/bootstrap.bundle.js ***!
  \*********************************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n/*!\n  * Bootstrap v4.6.1 (https://getbootstrap.com/)\n  * Copyright 2011-2021 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */\n(function (global, factory) {\n  ( false ? 0 : _typeof(exports)) === 'object' && \"object\" !== 'undefined' ? factory(exports, __webpack_require__(Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'jquery'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()))) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'jquery'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }())], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : (0);\n})(this, function (exports, $) {\n  'use strict';\n\n  function _interopDefaultLegacy(e) {\n    return e && _typeof(e) === 'object' && 'default' in e ? e : {\n      'default': e\n    };\n  }\n  var $__default = /*#__PURE__*/_interopDefaultLegacy($);\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n  function _extends$1() {\n    _extends$1 = Object.assign || function (target) {\n      for (var i = 1; i < arguments.length; i++) {\n        var source = arguments[i];\n        for (var key in source) {\n          if (Object.prototype.hasOwnProperty.call(source, key)) {\n            target[key] = source[key];\n          }\n        }\n      }\n      return target;\n    };\n    return _extends$1.apply(this, arguments);\n  }\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    _setPrototypeOf(subClass, superClass);\n  }\n  function _setPrototypeOf(o, p) {\n    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n      o.__proto__ = p;\n      return o;\n    };\n    return _setPrototypeOf(o, p);\n  }\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.1): util.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  /**\n   * Private TransitionEnd Helpers\n   */\n\n  var TRANSITION_END = 'transitionend';\n  var MAX_UID = 1000000;\n  var MILLISECONDS_MULTIPLIER = 1000; // Shoutout AngusCroll (https://goo.gl/pxwQGp)\n\n  function toType(obj) {\n    if (obj === null || typeof obj === 'undefined') {\n      return \"\" + obj;\n    }\n    return {}.toString.call(obj).match(/\\s([a-z]+)/i)[1].toLowerCase();\n  }\n  function getSpecialTransitionEndEvent() {\n    return {\n      bindType: TRANSITION_END,\n      delegateType: TRANSITION_END,\n      handle: function handle(event) {\n        if ($__default[\"default\"](event.target).is(this)) {\n          return event.handleObj.handler.apply(this, arguments); // eslint-disable-line prefer-rest-params\n        }\n\n        return undefined;\n      }\n    };\n  }\n  function transitionEndEmulator(duration) {\n    var _this = this;\n    var called = false;\n    $__default[\"default\"](this).one(Util.TRANSITION_END, function () {\n      called = true;\n    });\n    setTimeout(function () {\n      if (!called) {\n        Util.triggerTransitionEnd(_this);\n      }\n    }, duration);\n    return this;\n  }\n  function setTransitionEndSupport() {\n    $__default[\"default\"].fn.emulateTransitionEnd = transitionEndEmulator;\n    $__default[\"default\"].event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();\n  }\n  /**\n   * Public Util API\n   */\n\n  var Util = {\n    TRANSITION_END: 'bsTransitionEnd',\n    getUID: function getUID(prefix) {\n      do {\n        // eslint-disable-next-line no-bitwise\n        prefix += ~~(Math.random() * MAX_UID); // \"~~\" acts like a faster Math.floor() here\n      } while (document.getElementById(prefix));\n      return prefix;\n    },\n    getSelectorFromElement: function getSelectorFromElement(element) {\n      var selector = element.getAttribute('data-target');\n      if (!selector || selector === '#') {\n        var hrefAttr = element.getAttribute('href');\n        selector = hrefAttr && hrefAttr !== '#' ? hrefAttr.trim() : '';\n      }\n      try {\n        return document.querySelector(selector) ? selector : null;\n      } catch (_) {\n        return null;\n      }\n    },\n    getTransitionDurationFromElement: function getTransitionDurationFromElement(element) {\n      if (!element) {\n        return 0;\n      } // Get transition-duration of the element\n\n      var transitionDuration = $__default[\"default\"](element).css('transition-duration');\n      var transitionDelay = $__default[\"default\"](element).css('transition-delay');\n      var floatTransitionDuration = parseFloat(transitionDuration);\n      var floatTransitionDelay = parseFloat(transitionDelay); // Return 0 if element or transition duration is not found\n\n      if (!floatTransitionDuration && !floatTransitionDelay) {\n        return 0;\n      } // If multiple durations are defined, take the first\n\n      transitionDuration = transitionDuration.split(',')[0];\n      transitionDelay = transitionDelay.split(',')[0];\n      return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    },\n    reflow: function reflow(element) {\n      return element.offsetHeight;\n    },\n    triggerTransitionEnd: function triggerTransitionEnd(element) {\n      $__default[\"default\"](element).trigger(TRANSITION_END);\n    },\n    supportsTransitionEnd: function supportsTransitionEnd() {\n      return Boolean(TRANSITION_END);\n    },\n    isElement: function isElement(obj) {\n      return (obj[0] || obj).nodeType;\n    },\n    typeCheckConfig: function typeCheckConfig(componentName, config, configTypes) {\n      for (var property in configTypes) {\n        if (Object.prototype.hasOwnProperty.call(configTypes, property)) {\n          var expectedTypes = configTypes[property];\n          var value = config[property];\n          var valueType = value && Util.isElement(value) ? 'element' : toType(value);\n          if (!new RegExp(expectedTypes).test(valueType)) {\n            throw new Error(componentName.toUpperCase() + \": \" + (\"Option \\\"\" + property + \"\\\" provided type \\\"\" + valueType + \"\\\" \") + (\"but expected type \\\"\" + expectedTypes + \"\\\".\"));\n          }\n        }\n      }\n    },\n    findShadowRoot: function findShadowRoot(element) {\n      if (!document.documentElement.attachShadow) {\n        return null;\n      } // Can find the shadow root otherwise it'll return the document\n\n      if (typeof element.getRootNode === 'function') {\n        var root = element.getRootNode();\n        return root instanceof ShadowRoot ? root : null;\n      }\n      if (element instanceof ShadowRoot) {\n        return element;\n      } // when we don't find a shadow root\n\n      if (!element.parentNode) {\n        return null;\n      }\n      return Util.findShadowRoot(element.parentNode);\n    },\n    jQueryDetection: function jQueryDetection() {\n      if (typeof $__default[\"default\"] === 'undefined') {\n        throw new TypeError('Bootstrap\\'s JavaScript requires jQuery. jQuery must be included before Bootstrap\\'s JavaScript.');\n      }\n      var version = $__default[\"default\"].fn.jquery.split(' ')[0].split('.');\n      var minMajor = 1;\n      var ltMajor = 2;\n      var minMinor = 9;\n      var minPatch = 1;\n      var maxMajor = 4;\n      if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {\n        throw new Error('Bootstrap\\'s JavaScript requires at least jQuery v1.9.1 but less than v4.0.0');\n      }\n    }\n  };\n  Util.jQueryDetection();\n  setTransitionEndSupport();\n\n  /**\n   * Constants\n   */\n\n  var NAME$a = 'alert';\n  var VERSION$a = '4.6.1';\n  var DATA_KEY$a = 'bs.alert';\n  var EVENT_KEY$a = \".\" + DATA_KEY$a;\n  var DATA_API_KEY$7 = '.data-api';\n  var JQUERY_NO_CONFLICT$a = $__default[\"default\"].fn[NAME$a];\n  var CLASS_NAME_ALERT = 'alert';\n  var CLASS_NAME_FADE$5 = 'fade';\n  var CLASS_NAME_SHOW$7 = 'show';\n  var EVENT_CLOSE = \"close\" + EVENT_KEY$a;\n  var EVENT_CLOSED = \"closed\" + EVENT_KEY$a;\n  var EVENT_CLICK_DATA_API$6 = \"click\" + EVENT_KEY$a + DATA_API_KEY$7;\n  var SELECTOR_DISMISS = '[data-dismiss=\"alert\"]';\n  /**\n   * Class definition\n   */\n\n  var Alert = /*#__PURE__*/function () {\n    function Alert(element) {\n      this._element = element;\n    } // Getters\n\n    var _proto = Alert.prototype;\n\n    // Public\n    _proto.close = function close(element) {\n      var rootElement = this._element;\n      if (element) {\n        rootElement = this._getRootElement(element);\n      }\n      var customEvent = this._triggerCloseEvent(rootElement);\n      if (customEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._removeElement(rootElement);\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$a);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._getRootElement = function _getRootElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      var parent = false;\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      if (!parent) {\n        parent = $__default[\"default\"](element).closest(\".\" + CLASS_NAME_ALERT)[0];\n      }\n      return parent;\n    };\n    _proto._triggerCloseEvent = function _triggerCloseEvent(element) {\n      var closeEvent = $__default[\"default\"].Event(EVENT_CLOSE);\n      $__default[\"default\"](element).trigger(closeEvent);\n      return closeEvent;\n    };\n    _proto._removeElement = function _removeElement(element) {\n      var _this = this;\n      $__default[\"default\"](element).removeClass(CLASS_NAME_SHOW$7);\n      if (!$__default[\"default\"](element).hasClass(CLASS_NAME_FADE$5)) {\n        this._destroyElement(element);\n        return;\n      }\n      var transitionDuration = Util.getTransitionDurationFromElement(element);\n      $__default[\"default\"](element).one(Util.TRANSITION_END, function (event) {\n        return _this._destroyElement(element, event);\n      }).emulateTransitionEnd(transitionDuration);\n    };\n    _proto._destroyElement = function _destroyElement(element) {\n      $__default[\"default\"](element).detach().trigger(EVENT_CLOSED).remove();\n    } // Static\n    ;\n\n    Alert._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default[\"default\"](this);\n        var data = $element.data(DATA_KEY$a);\n        if (!data) {\n          data = new Alert(this);\n          $element.data(DATA_KEY$a, data);\n        }\n        if (config === 'close') {\n          data[config](this);\n        }\n      });\n    };\n    Alert._handleDismiss = function _handleDismiss(alertInstance) {\n      return function (event) {\n        if (event) {\n          event.preventDefault();\n        }\n        alertInstance.close(this);\n      };\n    };\n    _createClass(Alert, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$a;\n      }\n    }]);\n    return Alert;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API$6, SELECTOR_DISMISS, Alert._handleDismiss(new Alert()));\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$a] = Alert._jQueryInterface;\n  $__default[\"default\"].fn[NAME$a].Constructor = Alert;\n  $__default[\"default\"].fn[NAME$a].noConflict = function () {\n    $__default[\"default\"].fn[NAME$a] = JQUERY_NO_CONFLICT$a;\n    return Alert._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$9 = 'button';\n  var VERSION$9 = '4.6.1';\n  var DATA_KEY$9 = 'bs.button';\n  var EVENT_KEY$9 = \".\" + DATA_KEY$9;\n  var DATA_API_KEY$6 = '.data-api';\n  var JQUERY_NO_CONFLICT$9 = $__default[\"default\"].fn[NAME$9];\n  var CLASS_NAME_ACTIVE$3 = 'active';\n  var CLASS_NAME_BUTTON = 'btn';\n  var CLASS_NAME_FOCUS = 'focus';\n  var EVENT_CLICK_DATA_API$5 = \"click\" + EVENT_KEY$9 + DATA_API_KEY$6;\n  var EVENT_FOCUS_BLUR_DATA_API = \"focus\" + EVENT_KEY$9 + DATA_API_KEY$6 + \" \" + (\"blur\" + EVENT_KEY$9 + DATA_API_KEY$6);\n  var EVENT_LOAD_DATA_API$2 = \"load\" + EVENT_KEY$9 + DATA_API_KEY$6;\n  var SELECTOR_DATA_TOGGLE_CARROT = '[data-toggle^=\"button\"]';\n  var SELECTOR_DATA_TOGGLES = '[data-toggle=\"buttons\"]';\n  var SELECTOR_DATA_TOGGLE$4 = '[data-toggle=\"button\"]';\n  var SELECTOR_DATA_TOGGLES_BUTTONS = '[data-toggle=\"buttons\"] .btn';\n  var SELECTOR_INPUT = 'input:not([type=\"hidden\"])';\n  var SELECTOR_ACTIVE$2 = '.active';\n  var SELECTOR_BUTTON = '.btn';\n  /**\n   * Class definition\n   */\n\n  var Button = /*#__PURE__*/function () {\n    function Button(element) {\n      this._element = element;\n      this.shouldAvoidTriggerChange = false;\n    } // Getters\n\n    var _proto = Button.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      var triggerChangeEvent = true;\n      var addAriaPressed = true;\n      var rootElement = $__default[\"default\"](this._element).closest(SELECTOR_DATA_TOGGLES)[0];\n      if (rootElement) {\n        var input = this._element.querySelector(SELECTOR_INPUT);\n        if (input) {\n          if (input.type === 'radio') {\n            if (input.checked && this._element.classList.contains(CLASS_NAME_ACTIVE$3)) {\n              triggerChangeEvent = false;\n            } else {\n              var activeElement = rootElement.querySelector(SELECTOR_ACTIVE$2);\n              if (activeElement) {\n                $__default[\"default\"](activeElement).removeClass(CLASS_NAME_ACTIVE$3);\n              }\n            }\n          }\n          if (triggerChangeEvent) {\n            // if it's not a radio button or checkbox don't add a pointless/invalid checked property to the input\n            if (input.type === 'checkbox' || input.type === 'radio') {\n              input.checked = !this._element.classList.contains(CLASS_NAME_ACTIVE$3);\n            }\n            if (!this.shouldAvoidTriggerChange) {\n              $__default[\"default\"](input).trigger('change');\n            }\n          }\n          input.focus();\n          addAriaPressed = false;\n        }\n      }\n      if (!(this._element.hasAttribute('disabled') || this._element.classList.contains('disabled'))) {\n        if (addAriaPressed) {\n          this._element.setAttribute('aria-pressed', !this._element.classList.contains(CLASS_NAME_ACTIVE$3));\n        }\n        if (triggerChangeEvent) {\n          $__default[\"default\"](this._element).toggleClass(CLASS_NAME_ACTIVE$3);\n        }\n      }\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$9);\n      this._element = null;\n    } // Static\n    ;\n\n    Button._jQueryInterface = function _jQueryInterface(config, avoidTriggerChange) {\n      return this.each(function () {\n        var $element = $__default[\"default\"](this);\n        var data = $element.data(DATA_KEY$9);\n        if (!data) {\n          data = new Button(this);\n          $element.data(DATA_KEY$9, data);\n        }\n        data.shouldAvoidTriggerChange = avoidTriggerChange;\n        if (config === 'toggle') {\n          data[config]();\n        }\n      });\n    };\n    _createClass(Button, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$9;\n      }\n    }]);\n    return Button;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API$5, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = event.target;\n    var initialButton = button;\n    if (!$__default[\"default\"](button).hasClass(CLASS_NAME_BUTTON)) {\n      button = $__default[\"default\"](button).closest(SELECTOR_BUTTON)[0];\n    }\n    if (!button || button.hasAttribute('disabled') || button.classList.contains('disabled')) {\n      event.preventDefault(); // work around Firefox bug #1540995\n    } else {\n      var inputBtn = button.querySelector(SELECTOR_INPUT);\n      if (inputBtn && (inputBtn.hasAttribute('disabled') || inputBtn.classList.contains('disabled'))) {\n        event.preventDefault(); // work around Firefox bug #1540995\n\n        return;\n      }\n      if (initialButton.tagName === 'INPUT' || button.tagName !== 'LABEL') {\n        Button._jQueryInterface.call($__default[\"default\"](button), 'toggle', initialButton.tagName === 'INPUT');\n      }\n    }\n  }).on(EVENT_FOCUS_BLUR_DATA_API, SELECTOR_DATA_TOGGLE_CARROT, function (event) {\n    var button = $__default[\"default\"](event.target).closest(SELECTOR_BUTTON)[0];\n    $__default[\"default\"](button).toggleClass(CLASS_NAME_FOCUS, /^focus(in)?$/.test(event.type));\n  });\n  $__default[\"default\"](window).on(EVENT_LOAD_DATA_API$2, function () {\n    // ensure correct active class is set to match the controls' actual values/states\n    // find all checkboxes/readio buttons inside data-toggle groups\n    var buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLES_BUTTONS));\n    for (var i = 0, len = buttons.length; i < len; i++) {\n      var button = buttons[i];\n      var input = button.querySelector(SELECTOR_INPUT);\n      if (input.checked || input.hasAttribute('checked')) {\n        button.classList.add(CLASS_NAME_ACTIVE$3);\n      } else {\n        button.classList.remove(CLASS_NAME_ACTIVE$3);\n      }\n    } // find all button toggles\n\n    buttons = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$4));\n    for (var _i = 0, _len = buttons.length; _i < _len; _i++) {\n      var _button = buttons[_i];\n      if (_button.getAttribute('aria-pressed') === 'true') {\n        _button.classList.add(CLASS_NAME_ACTIVE$3);\n      } else {\n        _button.classList.remove(CLASS_NAME_ACTIVE$3);\n      }\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$9] = Button._jQueryInterface;\n  $__default[\"default\"].fn[NAME$9].Constructor = Button;\n  $__default[\"default\"].fn[NAME$9].noConflict = function () {\n    $__default[\"default\"].fn[NAME$9] = JQUERY_NO_CONFLICT$9;\n    return Button._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$8 = 'carousel';\n  var VERSION$8 = '4.6.1';\n  var DATA_KEY$8 = 'bs.carousel';\n  var EVENT_KEY$8 = \".\" + DATA_KEY$8;\n  var DATA_API_KEY$5 = '.data-api';\n  var JQUERY_NO_CONFLICT$8 = $__default[\"default\"].fn[NAME$8];\n  var ARROW_LEFT_KEYCODE = 37; // KeyboardEvent.which value for left arrow key\n\n  var ARROW_RIGHT_KEYCODE = 39; // KeyboardEvent.which value for right arrow key\n\n  var TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n\n  var SWIPE_THRESHOLD = 40;\n  var CLASS_NAME_CAROUSEL = 'carousel';\n  var CLASS_NAME_ACTIVE$2 = 'active';\n  var CLASS_NAME_SLIDE = 'slide';\n  var CLASS_NAME_RIGHT = 'carousel-item-right';\n  var CLASS_NAME_LEFT = 'carousel-item-left';\n  var CLASS_NAME_NEXT = 'carousel-item-next';\n  var CLASS_NAME_PREV = 'carousel-item-prev';\n  var CLASS_NAME_POINTER_EVENT = 'pointer-event';\n  var DIRECTION_NEXT = 'next';\n  var DIRECTION_PREV = 'prev';\n  var DIRECTION_LEFT = 'left';\n  var DIRECTION_RIGHT = 'right';\n  var EVENT_SLIDE = \"slide\" + EVENT_KEY$8;\n  var EVENT_SLID = \"slid\" + EVENT_KEY$8;\n  var EVENT_KEYDOWN = \"keydown\" + EVENT_KEY$8;\n  var EVENT_MOUSEENTER = \"mouseenter\" + EVENT_KEY$8;\n  var EVENT_MOUSELEAVE = \"mouseleave\" + EVENT_KEY$8;\n  var EVENT_TOUCHSTART = \"touchstart\" + EVENT_KEY$8;\n  var EVENT_TOUCHMOVE = \"touchmove\" + EVENT_KEY$8;\n  var EVENT_TOUCHEND = \"touchend\" + EVENT_KEY$8;\n  var EVENT_POINTERDOWN = \"pointerdown\" + EVENT_KEY$8;\n  var EVENT_POINTERUP = \"pointerup\" + EVENT_KEY$8;\n  var EVENT_DRAG_START = \"dragstart\" + EVENT_KEY$8;\n  var EVENT_LOAD_DATA_API$1 = \"load\" + EVENT_KEY$8 + DATA_API_KEY$5;\n  var EVENT_CLICK_DATA_API$4 = \"click\" + EVENT_KEY$8 + DATA_API_KEY$5;\n  var SELECTOR_ACTIVE$1 = '.active';\n  var SELECTOR_ACTIVE_ITEM = '.active.carousel-item';\n  var SELECTOR_ITEM = '.carousel-item';\n  var SELECTOR_ITEM_IMG = '.carousel-item img';\n  var SELECTOR_NEXT_PREV = '.carousel-item-next, .carousel-item-prev';\n  var SELECTOR_INDICATORS = '.carousel-indicators';\n  var SELECTOR_DATA_SLIDE = '[data-slide], [data-slide-to]';\n  var SELECTOR_DATA_RIDE = '[data-ride=\"carousel\"]';\n  var Default$7 = {\n    interval: 5000,\n    keyboard: true,\n    slide: false,\n    pause: 'hover',\n    wrap: true,\n    touch: true\n  };\n  var DefaultType$7 = {\n    interval: '(number|boolean)',\n    keyboard: 'boolean',\n    slide: '(boolean|string)',\n    pause: '(string|boolean)',\n    wrap: 'boolean',\n    touch: 'boolean'\n  };\n  var PointerType = {\n    TOUCH: 'touch',\n    PEN: 'pen'\n  };\n  /**\n   * Class definition\n   */\n\n  var Carousel = /*#__PURE__*/function () {\n    function Carousel(element, config) {\n      this._items = null;\n      this._interval = null;\n      this._activeElement = null;\n      this._isPaused = false;\n      this._isSliding = false;\n      this.touchTimeout = null;\n      this.touchStartX = 0;\n      this.touchDeltaX = 0;\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._indicatorsElement = this._element.querySelector(SELECTOR_INDICATORS);\n      this._touchSupported = 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\n      this._pointerEvent = Boolean(window.PointerEvent || window.MSPointerEvent);\n      this._addEventListeners();\n    } // Getters\n\n    var _proto = Carousel.prototype;\n\n    // Public\n    _proto.next = function next() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_NEXT);\n      }\n    };\n    _proto.nextWhenVisible = function nextWhenVisible() {\n      var $element = $__default[\"default\"](this._element); // Don't call next when the page isn't visible\n      // or the carousel or its parent isn't visible\n\n      if (!document.hidden && $element.is(':visible') && $element.css('visibility') !== 'hidden') {\n        this.next();\n      }\n    };\n    _proto.prev = function prev() {\n      if (!this._isSliding) {\n        this._slide(DIRECTION_PREV);\n      }\n    };\n    _proto.pause = function pause(event) {\n      if (!event) {\n        this._isPaused = true;\n      }\n      if (this._element.querySelector(SELECTOR_NEXT_PREV)) {\n        Util.triggerTransitionEnd(this._element);\n        this.cycle(true);\n      }\n      clearInterval(this._interval);\n      this._interval = null;\n    };\n    _proto.cycle = function cycle(event) {\n      if (!event) {\n        this._isPaused = false;\n      }\n      if (this._interval) {\n        clearInterval(this._interval);\n        this._interval = null;\n      }\n      if (this._config.interval && !this._isPaused) {\n        this._updateInterval();\n        this._interval = setInterval((document.visibilityState ? this.nextWhenVisible : this.next).bind(this), this._config.interval);\n      }\n    };\n    _proto.to = function to(index) {\n      var _this = this;\n      this._activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      var activeIndex = this._getItemIndex(this._activeElement);\n      if (index > this._items.length - 1 || index < 0) {\n        return;\n      }\n      if (this._isSliding) {\n        $__default[\"default\"](this._element).one(EVENT_SLID, function () {\n          return _this.to(index);\n        });\n        return;\n      }\n      if (activeIndex === index) {\n        this.pause();\n        this.cycle();\n        return;\n      }\n      var direction = index > activeIndex ? DIRECTION_NEXT : DIRECTION_PREV;\n      this._slide(direction, this._items[index]);\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"](this._element).off(EVENT_KEY$8);\n      $__default[\"default\"].removeData(this._element, DATA_KEY$8);\n      this._items = null;\n      this._config = null;\n      this._element = null;\n      this._interval = null;\n      this._isPaused = null;\n      this._isSliding = null;\n      this._activeElement = null;\n      this._indicatorsElement = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, Default$7, config);\n      Util.typeCheckConfig(NAME$8, config, DefaultType$7);\n      return config;\n    };\n    _proto._handleSwipe = function _handleSwipe() {\n      var absDeltax = Math.abs(this.touchDeltaX);\n      if (absDeltax <= SWIPE_THRESHOLD) {\n        return;\n      }\n      var direction = absDeltax / this.touchDeltaX;\n      this.touchDeltaX = 0; // swipe left\n\n      if (direction > 0) {\n        this.prev();\n      } // swipe right\n\n      if (direction < 0) {\n        this.next();\n      }\n    };\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this2 = this;\n      if (this._config.keyboard) {\n        $__default[\"default\"](this._element).on(EVENT_KEYDOWN, function (event) {\n          return _this2._keydown(event);\n        });\n      }\n      if (this._config.pause === 'hover') {\n        $__default[\"default\"](this._element).on(EVENT_MOUSEENTER, function (event) {\n          return _this2.pause(event);\n        }).on(EVENT_MOUSELEAVE, function (event) {\n          return _this2.cycle(event);\n        });\n      }\n      if (this._config.touch) {\n        this._addTouchEventListeners();\n      }\n    };\n    _proto._addTouchEventListeners = function _addTouchEventListeners() {\n      var _this3 = this;\n      if (!this._touchSupported) {\n        return;\n      }\n      var start = function start(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchStartX = event.originalEvent.clientX;\n        } else if (!_this3._pointerEvent) {\n          _this3.touchStartX = event.originalEvent.touches[0].clientX;\n        }\n      };\n      var move = function move(event) {\n        // ensure swiping with one touch and not pinching\n        _this3.touchDeltaX = event.originalEvent.touches && event.originalEvent.touches.length > 1 ? 0 : event.originalEvent.touches[0].clientX - _this3.touchStartX;\n      };\n      var end = function end(event) {\n        if (_this3._pointerEvent && PointerType[event.originalEvent.pointerType.toUpperCase()]) {\n          _this3.touchDeltaX = event.originalEvent.clientX - _this3.touchStartX;\n        }\n        _this3._handleSwipe();\n        if (_this3._config.pause === 'hover') {\n          // If it's a touch-enabled device, mouseenter/leave are fired as\n          // part of the mouse compatibility events on first tap - the carousel\n          // would stop cycling until user tapped out of it;\n          // here, we listen for touchend, explicitly pause the carousel\n          // (as if it's the second time we tap on it, mouseenter compat event\n          // is NOT fired) and after a timeout (to allow for mouse compatibility\n          // events to fire) we explicitly restart cycling\n          _this3.pause();\n          if (_this3.touchTimeout) {\n            clearTimeout(_this3.touchTimeout);\n          }\n          _this3.touchTimeout = setTimeout(function (event) {\n            return _this3.cycle(event);\n          }, TOUCHEVENT_COMPAT_WAIT + _this3._config.interval);\n        }\n      };\n      $__default[\"default\"](this._element.querySelectorAll(SELECTOR_ITEM_IMG)).on(EVENT_DRAG_START, function (e) {\n        return e.preventDefault();\n      });\n      if (this._pointerEvent) {\n        $__default[\"default\"](this._element).on(EVENT_POINTERDOWN, function (event) {\n          return start(event);\n        });\n        $__default[\"default\"](this._element).on(EVENT_POINTERUP, function (event) {\n          return end(event);\n        });\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n      } else {\n        $__default[\"default\"](this._element).on(EVENT_TOUCHSTART, function (event) {\n          return start(event);\n        });\n        $__default[\"default\"](this._element).on(EVENT_TOUCHMOVE, function (event) {\n          return move(event);\n        });\n        $__default[\"default\"](this._element).on(EVENT_TOUCHEND, function (event) {\n          return end(event);\n        });\n      }\n    };\n    _proto._keydown = function _keydown(event) {\n      if (/input|textarea/i.test(event.target.tagName)) {\n        return;\n      }\n      switch (event.which) {\n        case ARROW_LEFT_KEYCODE:\n          event.preventDefault();\n          this.prev();\n          break;\n        case ARROW_RIGHT_KEYCODE:\n          event.preventDefault();\n          this.next();\n          break;\n      }\n    };\n    _proto._getItemIndex = function _getItemIndex(element) {\n      this._items = element && element.parentNode ? [].slice.call(element.parentNode.querySelectorAll(SELECTOR_ITEM)) : [];\n      return this._items.indexOf(element);\n    };\n    _proto._getItemByDirection = function _getItemByDirection(direction, activeElement) {\n      var isNextDirection = direction === DIRECTION_NEXT;\n      var isPrevDirection = direction === DIRECTION_PREV;\n      var activeIndex = this._getItemIndex(activeElement);\n      var lastItemIndex = this._items.length - 1;\n      var isGoingToWrap = isPrevDirection && activeIndex === 0 || isNextDirection && activeIndex === lastItemIndex;\n      if (isGoingToWrap && !this._config.wrap) {\n        return activeElement;\n      }\n      var delta = direction === DIRECTION_PREV ? -1 : 1;\n      var itemIndex = (activeIndex + delta) % this._items.length;\n      return itemIndex === -1 ? this._items[this._items.length - 1] : this._items[itemIndex];\n    };\n    _proto._triggerSlideEvent = function _triggerSlideEvent(relatedTarget, eventDirectionName) {\n      var targetIndex = this._getItemIndex(relatedTarget);\n      var fromIndex = this._getItemIndex(this._element.querySelector(SELECTOR_ACTIVE_ITEM));\n      var slideEvent = $__default[\"default\"].Event(EVENT_SLIDE, {\n        relatedTarget: relatedTarget,\n        direction: eventDirectionName,\n        from: fromIndex,\n        to: targetIndex\n      });\n      $__default[\"default\"](this._element).trigger(slideEvent);\n      return slideEvent;\n    };\n    _proto._setActiveIndicatorElement = function _setActiveIndicatorElement(element) {\n      if (this._indicatorsElement) {\n        var indicators = [].slice.call(this._indicatorsElement.querySelectorAll(SELECTOR_ACTIVE$1));\n        $__default[\"default\"](indicators).removeClass(CLASS_NAME_ACTIVE$2);\n        var nextIndicator = this._indicatorsElement.children[this._getItemIndex(element)];\n        if (nextIndicator) {\n          $__default[\"default\"](nextIndicator).addClass(CLASS_NAME_ACTIVE$2);\n        }\n      }\n    };\n    _proto._updateInterval = function _updateInterval() {\n      var element = this._activeElement || this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      if (!element) {\n        return;\n      }\n      var elementInterval = parseInt(element.getAttribute('data-interval'), 10);\n      if (elementInterval) {\n        this._config.defaultInterval = this._config.defaultInterval || this._config.interval;\n        this._config.interval = elementInterval;\n      } else {\n        this._config.interval = this._config.defaultInterval || this._config.interval;\n      }\n    };\n    _proto._slide = function _slide(direction, element) {\n      var _this4 = this;\n      var activeElement = this._element.querySelector(SELECTOR_ACTIVE_ITEM);\n      var activeElementIndex = this._getItemIndex(activeElement);\n      var nextElement = element || activeElement && this._getItemByDirection(direction, activeElement);\n      var nextElementIndex = this._getItemIndex(nextElement);\n      var isCycling = Boolean(this._interval);\n      var directionalClassName;\n      var orderClassName;\n      var eventDirectionName;\n      if (direction === DIRECTION_NEXT) {\n        directionalClassName = CLASS_NAME_LEFT;\n        orderClassName = CLASS_NAME_NEXT;\n        eventDirectionName = DIRECTION_LEFT;\n      } else {\n        directionalClassName = CLASS_NAME_RIGHT;\n        orderClassName = CLASS_NAME_PREV;\n        eventDirectionName = DIRECTION_RIGHT;\n      }\n      if (nextElement && $__default[\"default\"](nextElement).hasClass(CLASS_NAME_ACTIVE$2)) {\n        this._isSliding = false;\n        return;\n      }\n      var slideEvent = this._triggerSlideEvent(nextElement, eventDirectionName);\n      if (slideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (!activeElement || !nextElement) {\n        // Some weirdness is happening, so we bail\n        return;\n      }\n      this._isSliding = true;\n      if (isCycling) {\n        this.pause();\n      }\n      this._setActiveIndicatorElement(nextElement);\n      this._activeElement = nextElement;\n      var slidEvent = $__default[\"default\"].Event(EVENT_SLID, {\n        relatedTarget: nextElement,\n        direction: eventDirectionName,\n        from: activeElementIndex,\n        to: nextElementIndex\n      });\n      if ($__default[\"default\"](this._element).hasClass(CLASS_NAME_SLIDE)) {\n        $__default[\"default\"](nextElement).addClass(orderClassName);\n        Util.reflow(nextElement);\n        $__default[\"default\"](activeElement).addClass(directionalClassName);\n        $__default[\"default\"](nextElement).addClass(directionalClassName);\n        var transitionDuration = Util.getTransitionDurationFromElement(activeElement);\n        $__default[\"default\"](activeElement).one(Util.TRANSITION_END, function () {\n          $__default[\"default\"](nextElement).removeClass(directionalClassName + \" \" + orderClassName).addClass(CLASS_NAME_ACTIVE$2);\n          $__default[\"default\"](activeElement).removeClass(CLASS_NAME_ACTIVE$2 + \" \" + orderClassName + \" \" + directionalClassName);\n          _this4._isSliding = false;\n          setTimeout(function () {\n            return $__default[\"default\"](_this4._element).trigger(slidEvent);\n          }, 0);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        $__default[\"default\"](activeElement).removeClass(CLASS_NAME_ACTIVE$2);\n        $__default[\"default\"](nextElement).addClass(CLASS_NAME_ACTIVE$2);\n        this._isSliding = false;\n        $__default[\"default\"](this._element).trigger(slidEvent);\n      }\n      if (isCycling) {\n        this.cycle();\n      }\n    } // Static\n    ;\n\n    Carousel._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default[\"default\"](this).data(DATA_KEY$8);\n        var _config = _extends$1({}, Default$7, $__default[\"default\"](this).data());\n        if (_typeof(config) === 'object') {\n          _config = _extends$1({}, _config, config);\n        }\n        var action = typeof config === 'string' ? config : _config.slide;\n        if (!data) {\n          data = new Carousel(this, _config);\n          $__default[\"default\"](this).data(DATA_KEY$8, data);\n        }\n        if (typeof config === 'number') {\n          data.to(config);\n        } else if (typeof action === 'string') {\n          if (typeof data[action] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + action + \"\\\"\");\n          }\n          data[action]();\n        } else if (_config.interval && _config.ride) {\n          data.pause();\n          data.cycle();\n        }\n      });\n    };\n    Carousel._dataApiClickHandler = function _dataApiClickHandler(event) {\n      var selector = Util.getSelectorFromElement(this);\n      if (!selector) {\n        return;\n      }\n      var target = $__default[\"default\"](selector)[0];\n      if (!target || !$__default[\"default\"](target).hasClass(CLASS_NAME_CAROUSEL)) {\n        return;\n      }\n      var config = _extends$1({}, $__default[\"default\"](target).data(), $__default[\"default\"](this).data());\n      var slideIndex = this.getAttribute('data-slide-to');\n      if (slideIndex) {\n        config.interval = false;\n      }\n      Carousel._jQueryInterface.call($__default[\"default\"](target), config);\n      if (slideIndex) {\n        $__default[\"default\"](target).data(DATA_KEY$8).to(slideIndex);\n      }\n      event.preventDefault();\n    };\n    _createClass(Carousel, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$8;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$7;\n      }\n    }]);\n    return Carousel;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API$4, SELECTOR_DATA_SLIDE, Carousel._dataApiClickHandler);\n  $__default[\"default\"](window).on(EVENT_LOAD_DATA_API$1, function () {\n    var carousels = [].slice.call(document.querySelectorAll(SELECTOR_DATA_RIDE));\n    for (var i = 0, len = carousels.length; i < len; i++) {\n      var $carousel = $__default[\"default\"](carousels[i]);\n      Carousel._jQueryInterface.call($carousel, $carousel.data());\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$8] = Carousel._jQueryInterface;\n  $__default[\"default\"].fn[NAME$8].Constructor = Carousel;\n  $__default[\"default\"].fn[NAME$8].noConflict = function () {\n    $__default[\"default\"].fn[NAME$8] = JQUERY_NO_CONFLICT$8;\n    return Carousel._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$7 = 'collapse';\n  var VERSION$7 = '4.6.1';\n  var DATA_KEY$7 = 'bs.collapse';\n  var EVENT_KEY$7 = \".\" + DATA_KEY$7;\n  var DATA_API_KEY$4 = '.data-api';\n  var JQUERY_NO_CONFLICT$7 = $__default[\"default\"].fn[NAME$7];\n  var CLASS_NAME_SHOW$6 = 'show';\n  var CLASS_NAME_COLLAPSE = 'collapse';\n  var CLASS_NAME_COLLAPSING = 'collapsing';\n  var CLASS_NAME_COLLAPSED = 'collapsed';\n  var DIMENSION_WIDTH = 'width';\n  var DIMENSION_HEIGHT = 'height';\n  var EVENT_SHOW$4 = \"show\" + EVENT_KEY$7;\n  var EVENT_SHOWN$4 = \"shown\" + EVENT_KEY$7;\n  var EVENT_HIDE$4 = \"hide\" + EVENT_KEY$7;\n  var EVENT_HIDDEN$4 = \"hidden\" + EVENT_KEY$7;\n  var EVENT_CLICK_DATA_API$3 = \"click\" + EVENT_KEY$7 + DATA_API_KEY$4;\n  var SELECTOR_ACTIVES = '.show, .collapsing';\n  var SELECTOR_DATA_TOGGLE$3 = '[data-toggle=\"collapse\"]';\n  var Default$6 = {\n    toggle: true,\n    parent: ''\n  };\n  var DefaultType$6 = {\n    toggle: 'boolean',\n    parent: '(string|element)'\n  };\n  /**\n   * Class definition\n   */\n\n  var Collapse = /*#__PURE__*/function () {\n    function Collapse(element, config) {\n      this._isTransitioning = false;\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._triggerArray = [].slice.call(document.querySelectorAll(\"[data-toggle=\\\"collapse\\\"][href=\\\"#\" + element.id + \"\\\"],\" + (\"[data-toggle=\\\"collapse\\\"][data-target=\\\"#\" + element.id + \"\\\"]\")));\n      var toggleList = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$3));\n      for (var i = 0, len = toggleList.length; i < len; i++) {\n        var elem = toggleList[i];\n        var selector = Util.getSelectorFromElement(elem);\n        var filterElement = [].slice.call(document.querySelectorAll(selector)).filter(function (foundElem) {\n          return foundElem === element;\n        });\n        if (selector !== null && filterElement.length > 0) {\n          this._selector = selector;\n          this._triggerArray.push(elem);\n        }\n      }\n      this._parent = this._config.parent ? this._getParent() : null;\n      if (!this._config.parent) {\n        this._addAriaAndCollapsedClass(this._element, this._triggerArray);\n      }\n      if (this._config.toggle) {\n        this.toggle();\n      }\n    } // Getters\n\n    var _proto = Collapse.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if ($__default[\"default\"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        this.hide();\n      } else {\n        this.show();\n      }\n    };\n    _proto.show = function show() {\n      var _this = this;\n      if (this._isTransitioning || $__default[\"default\"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        return;\n      }\n      var actives;\n      var activesData;\n      if (this._parent) {\n        actives = [].slice.call(this._parent.querySelectorAll(SELECTOR_ACTIVES)).filter(function (elem) {\n          if (typeof _this._config.parent === 'string') {\n            return elem.getAttribute('data-parent') === _this._config.parent;\n          }\n          return elem.classList.contains(CLASS_NAME_COLLAPSE);\n        });\n        if (actives.length === 0) {\n          actives = null;\n        }\n      }\n      if (actives) {\n        activesData = $__default[\"default\"](actives).not(this._selector).data(DATA_KEY$7);\n        if (activesData && activesData._isTransitioning) {\n          return;\n        }\n      }\n      var startEvent = $__default[\"default\"].Event(EVENT_SHOW$4);\n      $__default[\"default\"](this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (actives) {\n        Collapse._jQueryInterface.call($__default[\"default\"](actives).not(this._selector), 'hide');\n        if (!activesData) {\n          $__default[\"default\"](actives).data(DATA_KEY$7, null);\n        }\n      }\n      var dimension = this._getDimension();\n      $__default[\"default\"](this._element).removeClass(CLASS_NAME_COLLAPSE).addClass(CLASS_NAME_COLLAPSING);\n      this._element.style[dimension] = 0;\n      if (this._triggerArray.length) {\n        $__default[\"default\"](this._triggerArray).removeClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', true);\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        $__default[\"default\"](_this._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$6);\n        _this._element.style[dimension] = '';\n        _this.setTransitioning(false);\n        $__default[\"default\"](_this._element).trigger(EVENT_SHOWN$4);\n      };\n      var capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n      var scrollSize = \"scroll\" + capitalizedDimension;\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default[\"default\"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      this._element.style[dimension] = this._element[scrollSize] + \"px\";\n    };\n    _proto.hide = function hide() {\n      var _this2 = this;\n      if (this._isTransitioning || !$__default[\"default\"](this._element).hasClass(CLASS_NAME_SHOW$6)) {\n        return;\n      }\n      var startEvent = $__default[\"default\"].Event(EVENT_HIDE$4);\n      $__default[\"default\"](this._element).trigger(startEvent);\n      if (startEvent.isDefaultPrevented()) {\n        return;\n      }\n      var dimension = this._getDimension();\n      this._element.style[dimension] = this._element.getBoundingClientRect()[dimension] + \"px\";\n      Util.reflow(this._element);\n      $__default[\"default\"](this._element).addClass(CLASS_NAME_COLLAPSING).removeClass(CLASS_NAME_COLLAPSE + \" \" + CLASS_NAME_SHOW$6);\n      var triggerArrayLength = this._triggerArray.length;\n      if (triggerArrayLength > 0) {\n        for (var i = 0; i < triggerArrayLength; i++) {\n          var trigger = this._triggerArray[i];\n          var selector = Util.getSelectorFromElement(trigger);\n          if (selector !== null) {\n            var $elem = $__default[\"default\"]([].slice.call(document.querySelectorAll(selector)));\n            if (!$elem.hasClass(CLASS_NAME_SHOW$6)) {\n              $__default[\"default\"](trigger).addClass(CLASS_NAME_COLLAPSED).attr('aria-expanded', false);\n            }\n          }\n        }\n      }\n      this.setTransitioning(true);\n      var complete = function complete() {\n        _this2.setTransitioning(false);\n        $__default[\"default\"](_this2._element).removeClass(CLASS_NAME_COLLAPSING).addClass(CLASS_NAME_COLLAPSE).trigger(EVENT_HIDDEN$4);\n      };\n      this._element.style[dimension] = '';\n      var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n      $__default[\"default\"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n    };\n    _proto.setTransitioning = function setTransitioning(isTransitioning) {\n      this._isTransitioning = isTransitioning;\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$7);\n      this._config = null;\n      this._parent = null;\n      this._element = null;\n      this._triggerArray = null;\n      this._isTransitioning = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, Default$6, config);\n      config.toggle = Boolean(config.toggle); // Coerce string values\n\n      Util.typeCheckConfig(NAME$7, config, DefaultType$6);\n      return config;\n    };\n    _proto._getDimension = function _getDimension() {\n      var hasWidth = $__default[\"default\"](this._element).hasClass(DIMENSION_WIDTH);\n      return hasWidth ? DIMENSION_WIDTH : DIMENSION_HEIGHT;\n    };\n    _proto._getParent = function _getParent() {\n      var _this3 = this;\n      var parent;\n      if (Util.isElement(this._config.parent)) {\n        parent = this._config.parent; // It's a jQuery object\n\n        if (typeof this._config.parent.jquery !== 'undefined') {\n          parent = this._config.parent[0];\n        }\n      } else {\n        parent = document.querySelector(this._config.parent);\n      }\n      var selector = \"[data-toggle=\\\"collapse\\\"][data-parent=\\\"\" + this._config.parent + \"\\\"]\";\n      var children = [].slice.call(parent.querySelectorAll(selector));\n      $__default[\"default\"](children).each(function (i, element) {\n        _this3._addAriaAndCollapsedClass(Collapse._getTargetFromElement(element), [element]);\n      });\n      return parent;\n    };\n    _proto._addAriaAndCollapsedClass = function _addAriaAndCollapsedClass(element, triggerArray) {\n      var isOpen = $__default[\"default\"](element).hasClass(CLASS_NAME_SHOW$6);\n      if (triggerArray.length) {\n        $__default[\"default\"](triggerArray).toggleClass(CLASS_NAME_COLLAPSED, !isOpen).attr('aria-expanded', isOpen);\n      }\n    } // Static\n    ;\n\n    Collapse._getTargetFromElement = function _getTargetFromElement(element) {\n      var selector = Util.getSelectorFromElement(element);\n      return selector ? document.querySelector(selector) : null;\n    };\n    Collapse._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default[\"default\"](this);\n        var data = $element.data(DATA_KEY$7);\n        var _config = _extends$1({}, Default$6, $element.data(), _typeof(config) === 'object' && config ? config : {});\n        if (!data && _config.toggle && typeof config === 'string' && /show|hide/.test(config)) {\n          _config.toggle = false;\n        }\n        if (!data) {\n          data = new Collapse(this, _config);\n          $element.data(DATA_KEY$7, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Collapse, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$7;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$6;\n      }\n    }]);\n    return Collapse;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n    if (event.currentTarget.tagName === 'A') {\n      event.preventDefault();\n    }\n    var $trigger = $__default[\"default\"](this);\n    var selector = Util.getSelectorFromElement(this);\n    var selectors = [].slice.call(document.querySelectorAll(selector));\n    $__default[\"default\"](selectors).each(function () {\n      var $target = $__default[\"default\"](this);\n      var data = $target.data(DATA_KEY$7);\n      var config = data ? 'toggle' : $trigger.data();\n      Collapse._jQueryInterface.call($target, config);\n    });\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$7] = Collapse._jQueryInterface;\n  $__default[\"default\"].fn[NAME$7].Constructor = Collapse;\n  $__default[\"default\"].fn[NAME$7].noConflict = function () {\n    $__default[\"default\"].fn[NAME$7] = JQUERY_NO_CONFLICT$7;\n    return Collapse._jQueryInterface;\n  };\n\n  /**!\n   * @fileOverview Kickass library to create and place poppers near their reference elements.\n   * @version 1.16.1\n   * @license\n   * Copyright (c) 2016 Federico Zivolo and contributors\n   *\n   * Permission is hereby granted, free of charge, to any person obtaining a copy\n   * of this software and associated documentation files (the \"Software\"), to deal\n   * in the Software without restriction, including without limitation the rights\n   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   * copies of the Software, and to permit persons to whom the Software is\n   * furnished to do so, subject to the following conditions:\n   *\n   * The above copyright notice and this permission notice shall be included in all\n   * copies or substantial portions of the Software.\n   *\n   * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   * SOFTWARE.\n   */\n  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';\n  var timeoutDuration = function () {\n    var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];\n    for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {\n      if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {\n        return 1;\n      }\n    }\n    return 0;\n  }();\n  function microtaskDebounce(fn) {\n    var called = false;\n    return function () {\n      if (called) {\n        return;\n      }\n      called = true;\n      window.Promise.resolve().then(function () {\n        called = false;\n        fn();\n      });\n    };\n  }\n  function taskDebounce(fn) {\n    var scheduled = false;\n    return function () {\n      if (!scheduled) {\n        scheduled = true;\n        setTimeout(function () {\n          scheduled = false;\n          fn();\n        }, timeoutDuration);\n      }\n    };\n  }\n  var supportsMicroTasks = isBrowser && window.Promise;\n\n  /**\n  * Create a debounced version of a method, that's asynchronously deferred\n  * but called in the minimum time possible.\n  *\n  * @method\n  * @memberof Popper.Utils\n  * @argument {Function} fn\n  * @returns {Function}\n  */\n  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;\n\n  /**\n   * Check if the given variable is a function\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Any} functionToCheck - variable to check\n   * @returns {Boolean} answer to: is a function?\n   */\n  function isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';\n  }\n\n  /**\n   * Get CSS computed property of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Eement} element\n   * @argument {String} property\n   */\n  function getStyleComputedProperty(element, property) {\n    if (element.nodeType !== 1) {\n      return [];\n    }\n    // NOTE: 1 DOM access here\n    var window = element.ownerDocument.defaultView;\n    var css = window.getComputedStyle(element, null);\n    return property ? css[property] : css;\n  }\n\n  /**\n   * Returns the parentNode or the host of the element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} parent\n   */\n  function getParentNode(element) {\n    if (element.nodeName === 'HTML') {\n      return element;\n    }\n    return element.parentNode || element.host;\n  }\n\n  /**\n   * Returns the scrolling parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} scroll parent\n   */\n  function getScrollParent(element) {\n    // Return body, `getScroll` will take care to get the correct `scrollTop` from it\n    if (!element) {\n      return document.body;\n    }\n    switch (element.nodeName) {\n      case 'HTML':\n      case 'BODY':\n        return element.ownerDocument.body;\n      case '#document':\n        return element.body;\n    }\n\n    // Firefox want us to check `-x` and `-y` variations as well\n\n    var _getStyleComputedProp = getStyleComputedProperty(element),\n      overflow = _getStyleComputedProp.overflow,\n      overflowX = _getStyleComputedProp.overflowX,\n      overflowY = _getStyleComputedProp.overflowY;\n    if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {\n      return element;\n    }\n    return getScrollParent(getParentNode(element));\n  }\n\n  /**\n   * Returns the reference node of the reference object, or the reference object itself.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Element|Object} reference - the reference element (the popper will be relative to this)\n   * @returns {Element} parent\n   */\n  function getReferenceNode(reference) {\n    return reference && reference.referenceNode ? reference.referenceNode : reference;\n  }\n  var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);\n  var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);\n\n  /**\n   * Determines if the browser is Internet Explorer\n   * @method\n   * @memberof Popper.Utils\n   * @param {Number} version to check\n   * @returns {Boolean} isIE\n   */\n  function isIE(version) {\n    if (version === 11) {\n      return isIE11;\n    }\n    if (version === 10) {\n      return isIE10;\n    }\n    return isIE11 || isIE10;\n  }\n\n  /**\n   * Returns the offset parent of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} offset parent\n   */\n  function getOffsetParent(element) {\n    if (!element) {\n      return document.documentElement;\n    }\n    var noOffsetParent = isIE(10) ? document.body : null;\n\n    // NOTE: 1 DOM access here\n    var offsetParent = element.offsetParent || null;\n    // Skip hidden elements which don't have an offsetParent\n    while (offsetParent === noOffsetParent && element.nextElementSibling) {\n      offsetParent = (element = element.nextElementSibling).offsetParent;\n    }\n    var nodeName = offsetParent && offsetParent.nodeName;\n    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {\n      return element ? element.ownerDocument.documentElement : document.documentElement;\n    }\n\n    // .offsetParent will return the closest TH, TD or TABLE in case\n    // no offsetParent is present, I hate this job...\n    if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {\n      return getOffsetParent(offsetParent);\n    }\n    return offsetParent;\n  }\n  function isOffsetContainer(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY') {\n      return false;\n    }\n    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;\n  }\n\n  /**\n   * Finds the root node (document, shadowDOM root) of the given element\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} node\n   * @returns {Element} root node\n   */\n  function getRoot(node) {\n    if (node.parentNode !== null) {\n      return getRoot(node.parentNode);\n    }\n    return node;\n  }\n\n  /**\n   * Finds the offset parent common to the two provided nodes\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element1\n   * @argument {Element} element2\n   * @returns {Element} common offset parent\n   */\n  function findCommonOffsetParent(element1, element2) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {\n      return document.documentElement;\n    }\n\n    // Here we make sure to give as \"start\" the element that comes first in the DOM\n    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;\n    var start = order ? element1 : element2;\n    var end = order ? element2 : element1;\n\n    // Get common ancestor container\n    var range = document.createRange();\n    range.setStart(start, 0);\n    range.setEnd(end, 0);\n    var commonAncestorContainer = range.commonAncestorContainer;\n\n    // Both nodes are inside #document\n\n    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {\n      if (isOffsetContainer(commonAncestorContainer)) {\n        return commonAncestorContainer;\n      }\n      return getOffsetParent(commonAncestorContainer);\n    }\n\n    // one of the nodes is inside shadowDOM, find which one\n    var element1root = getRoot(element1);\n    if (element1root.host) {\n      return findCommonOffsetParent(element1root.host, element2);\n    } else {\n      return findCommonOffsetParent(element1, getRoot(element2).host);\n    }\n  }\n\n  /**\n   * Gets the scroll value of the given element in the given side (top and left)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {String} side `top` or `left`\n   * @returns {number} amount of scrolled pixels\n   */\n  function getScroll(element) {\n    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';\n    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      var html = element.ownerDocument.documentElement;\n      var scrollingElement = element.ownerDocument.scrollingElement || html;\n      return scrollingElement[upperSide];\n    }\n    return element[upperSide];\n  }\n\n  /*\n   * Sum or subtract the element scroll values (left and top) from a given rect object\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} rect - Rect object you want to change\n   * @param {HTMLElement} element - The element from the function reads the scroll values\n   * @param {Boolean} subtract - set to true if you want to subtract the scroll values\n   * @return {Object} rect - The modifier rect object\n   */\n  function includeScroll(rect, element) {\n    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var scrollTop = getScroll(element, 'top');\n    var scrollLeft = getScroll(element, 'left');\n    var modifier = subtract ? -1 : 1;\n    rect.top += scrollTop * modifier;\n    rect.bottom += scrollTop * modifier;\n    rect.left += scrollLeft * modifier;\n    rect.right += scrollLeft * modifier;\n    return rect;\n  }\n\n  /*\n   * Helper to detect borders of a given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {CSSStyleDeclaration} styles\n   * Result of `getStyleComputedProperty` on the given element\n   * @param {String} axis - `x` or `y`\n   * @return {number} borders - The borders size of the given axis\n   */\n\n  function getBordersSize(styles, axis) {\n    var sideA = axis === 'x' ? 'Left' : 'Top';\n    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';\n    return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);\n  }\n  function getSize(axis, body, html, computedStyle) {\n    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);\n  }\n  function getWindowSizes(document) {\n    var body = document.body;\n    var html = document.documentElement;\n    var computedStyle = isIE(10) && getComputedStyle(html);\n    return {\n      height: getSize('Height', body, html, computedStyle),\n      width: getSize('Width', body, html, computedStyle)\n    };\n  }\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n  var createClass = function () {\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n    return function (Constructor, protoProps, staticProps) {\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  }();\n  var defineProperty = function defineProperty(obj, key, value) {\n    if (key in obj) {\n      Object.defineProperty(obj, key, {\n        value: value,\n        enumerable: true,\n        configurable: true,\n        writable: true\n      });\n    } else {\n      obj[key] = value;\n    }\n    return obj;\n  };\n  var _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n\n  /**\n   * Given element offsets, generate an output similar to getBoundingClientRect\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} offsets\n   * @returns {Object} ClientRect like output\n   */\n  function getClientRect(offsets) {\n    return _extends({}, offsets, {\n      right: offsets.left + offsets.width,\n      bottom: offsets.top + offsets.height\n    });\n  }\n\n  /**\n   * Get bounding client rect of given element\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} element\n   * @return {Object} client rect\n   */\n  function getBoundingClientRect(element) {\n    var rect = {};\n\n    // IE10 10 FIX: Please, don't ask, the element isn't\n    // considered in DOM in some circumstances...\n    // This isn't reproducible in IE10 compatibility mode of IE11\n    try {\n      if (isIE(10)) {\n        rect = element.getBoundingClientRect();\n        var scrollTop = getScroll(element, 'top');\n        var scrollLeft = getScroll(element, 'left');\n        rect.top += scrollTop;\n        rect.left += scrollLeft;\n        rect.bottom += scrollTop;\n        rect.right += scrollLeft;\n      } else {\n        rect = element.getBoundingClientRect();\n      }\n    } catch (e) {}\n    var result = {\n      left: rect.left,\n      top: rect.top,\n      width: rect.right - rect.left,\n      height: rect.bottom - rect.top\n    };\n\n    // subtract scrollbar size from sizes\n    var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};\n    var width = sizes.width || element.clientWidth || result.width;\n    var height = sizes.height || element.clientHeight || result.height;\n    var horizScrollbar = element.offsetWidth - width;\n    var vertScrollbar = element.offsetHeight - height;\n\n    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`\n    // we make this check conditional for performance reasons\n    if (horizScrollbar || vertScrollbar) {\n      var styles = getStyleComputedProperty(element);\n      horizScrollbar -= getBordersSize(styles, 'x');\n      vertScrollbar -= getBordersSize(styles, 'y');\n      result.width -= horizScrollbar;\n      result.height -= vertScrollbar;\n    }\n    return getClientRect(result);\n  }\n  function getOffsetRectRelativeToArbitraryNode(children, parent) {\n    var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var isIE10 = isIE(10);\n    var isHTML = parent.nodeName === 'HTML';\n    var childrenRect = getBoundingClientRect(children);\n    var parentRect = getBoundingClientRect(parent);\n    var scrollParent = getScrollParent(children);\n    var styles = getStyleComputedProperty(parent);\n    var borderTopWidth = parseFloat(styles.borderTopWidth);\n    var borderLeftWidth = parseFloat(styles.borderLeftWidth);\n\n    // In cases where the parent is fixed, we must ignore negative scroll in offset calc\n    if (fixedPosition && isHTML) {\n      parentRect.top = Math.max(parentRect.top, 0);\n      parentRect.left = Math.max(parentRect.left, 0);\n    }\n    var offsets = getClientRect({\n      top: childrenRect.top - parentRect.top - borderTopWidth,\n      left: childrenRect.left - parentRect.left - borderLeftWidth,\n      width: childrenRect.width,\n      height: childrenRect.height\n    });\n    offsets.marginTop = 0;\n    offsets.marginLeft = 0;\n\n    // Subtract margins of documentElement in case it's being used as parent\n    // we do this only on HTML because it's the only element that behaves\n    // differently when margins are applied to it. The margins are included in\n    // the box of the documentElement, in the other cases not.\n    if (!isIE10 && isHTML) {\n      var marginTop = parseFloat(styles.marginTop);\n      var marginLeft = parseFloat(styles.marginLeft);\n      offsets.top -= borderTopWidth - marginTop;\n      offsets.bottom -= borderTopWidth - marginTop;\n      offsets.left -= borderLeftWidth - marginLeft;\n      offsets.right -= borderLeftWidth - marginLeft;\n\n      // Attach marginTop and marginLeft because in some circumstances we may need them\n      offsets.marginTop = marginTop;\n      offsets.marginLeft = marginLeft;\n    }\n    if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {\n      offsets = includeScroll(offsets, parent);\n    }\n    return offsets;\n  }\n  function getViewportOffsetRectRelativeToArtbitraryNode(element) {\n    var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var html = element.ownerDocument.documentElement;\n    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);\n    var width = Math.max(html.clientWidth, window.innerWidth || 0);\n    var height = Math.max(html.clientHeight, window.innerHeight || 0);\n    var scrollTop = !excludeScroll ? getScroll(html) : 0;\n    var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;\n    var offset = {\n      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,\n      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,\n      width: width,\n      height: height\n    };\n    return getClientRect(offset);\n  }\n\n  /**\n   * Check if the given element is fixed or is inside a fixed parent\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @argument {Element} customContainer\n   * @returns {Boolean} answer to \"isFixed?\"\n   */\n  function isFixed(element) {\n    var nodeName = element.nodeName;\n    if (nodeName === 'BODY' || nodeName === 'HTML') {\n      return false;\n    }\n    if (getStyleComputedProperty(element, 'position') === 'fixed') {\n      return true;\n    }\n    var parentNode = getParentNode(element);\n    if (!parentNode) {\n      return false;\n    }\n    return isFixed(parentNode);\n  }\n\n  /**\n   * Finds the first parent of an element that has a transformed property defined\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Element} first transformed parent or documentElement\n   */\n\n  function getFixedPositionOffsetParent(element) {\n    // This check is needed to avoid errors in case one of the elements isn't defined for any reason\n    if (!element || !element.parentElement || isIE()) {\n      return document.documentElement;\n    }\n    var el = element.parentElement;\n    while (el && getStyleComputedProperty(el, 'transform') === 'none') {\n      el = el.parentElement;\n    }\n    return el || document.documentElement;\n  }\n\n  /**\n   * Computed the boundaries limits and return them\n   * @method\n   * @memberof Popper.Utils\n   * @param {HTMLElement} popper\n   * @param {HTMLElement} reference\n   * @param {number} padding\n   * @param {HTMLElement} boundariesElement - Element used to define the boundaries\n   * @param {Boolean} fixedPosition - Is in fixed position mode\n   * @returns {Object} Coordinates of the boundaries\n   */\n  function getBoundaries(popper, reference, padding, boundariesElement) {\n    var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n    // NOTE: 1 DOM access here\n\n    var boundaries = {\n      top: 0,\n      left: 0\n    };\n    var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n\n    // Handle viewport case\n    if (boundariesElement === 'viewport') {\n      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);\n    } else {\n      // Handle other cases based on DOM element used as boundaries\n      var boundariesNode = void 0;\n      if (boundariesElement === 'scrollParent') {\n        boundariesNode = getScrollParent(getParentNode(reference));\n        if (boundariesNode.nodeName === 'BODY') {\n          boundariesNode = popper.ownerDocument.documentElement;\n        }\n      } else if (boundariesElement === 'window') {\n        boundariesNode = popper.ownerDocument.documentElement;\n      } else {\n        boundariesNode = boundariesElement;\n      }\n      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition);\n\n      // In case of HTML, we need a different computation\n      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {\n        var _getWindowSizes = getWindowSizes(popper.ownerDocument),\n          height = _getWindowSizes.height,\n          width = _getWindowSizes.width;\n        boundaries.top += offsets.top - offsets.marginTop;\n        boundaries.bottom = height + offsets.top;\n        boundaries.left += offsets.left - offsets.marginLeft;\n        boundaries.right = width + offsets.left;\n      } else {\n        // for all the other DOM elements, this one is good\n        boundaries = offsets;\n      }\n    }\n\n    // Add paddings\n    padding = padding || 0;\n    var isPaddingNumber = typeof padding === 'number';\n    boundaries.left += isPaddingNumber ? padding : padding.left || 0;\n    boundaries.top += isPaddingNumber ? padding : padding.top || 0;\n    boundaries.right -= isPaddingNumber ? padding : padding.right || 0;\n    boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;\n    return boundaries;\n  }\n  function getArea(_ref) {\n    var width = _ref.width,\n      height = _ref.height;\n    return width * height;\n  }\n\n  /**\n   * Utility used to transform the `auto` placement to the placement with more\n   * available space.\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {\n    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n    if (placement.indexOf('auto') === -1) {\n      return placement;\n    }\n    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);\n    var rects = {\n      top: {\n        width: boundaries.width,\n        height: refRect.top - boundaries.top\n      },\n      right: {\n        width: boundaries.right - refRect.right,\n        height: boundaries.height\n      },\n      bottom: {\n        width: boundaries.width,\n        height: boundaries.bottom - refRect.bottom\n      },\n      left: {\n        width: refRect.left - boundaries.left,\n        height: boundaries.height\n      }\n    };\n    var sortedAreas = Object.keys(rects).map(function (key) {\n      return _extends({\n        key: key\n      }, rects[key], {\n        area: getArea(rects[key])\n      });\n    }).sort(function (a, b) {\n      return b.area - a.area;\n    });\n    var filteredAreas = sortedAreas.filter(function (_ref2) {\n      var width = _ref2.width,\n        height = _ref2.height;\n      return width >= popper.clientWidth && height >= popper.clientHeight;\n    });\n    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;\n    var variation = placement.split('-')[1];\n    return computedPlacement + (variation ? '-' + variation : '');\n  }\n\n  /**\n   * Get offsets to the reference element\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} state\n   * @param {Element} popper - the popper element\n   * @param {Element} reference - the reference element (the popper will be relative to this)\n   * @param {Element} fixedPosition - is in fixed position mode\n   * @returns {Object} An object containing the offsets which will be applied to the popper\n   */\n  function getReferenceOffsets(state, popper, reference) {\n    var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));\n    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);\n  }\n\n  /**\n   * Get the outer sizes of the given element (offset size + margins)\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element\n   * @returns {Object} object containing width and height properties\n   */\n  function getOuterSizes(element) {\n    var window = element.ownerDocument.defaultView;\n    var styles = window.getComputedStyle(element);\n    var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);\n    var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);\n    var result = {\n      width: element.offsetWidth + y,\n      height: element.offsetHeight + x\n    };\n    return result;\n  }\n\n  /**\n   * Get the opposite placement of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement\n   * @returns {String} flipped placement\n   */\n  function getOppositePlacement(placement) {\n    var hash = {\n      left: 'right',\n      right: 'left',\n      bottom: 'top',\n      top: 'bottom'\n    };\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\n      return hash[matched];\n    });\n  }\n\n  /**\n   * Get offsets to the popper\n   * @method\n   * @memberof Popper.Utils\n   * @param {Object} position - CSS position the Popper will get applied\n   * @param {HTMLElement} popper - the popper element\n   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)\n   * @param {String} placement - one of the valid placement options\n   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper\n   */\n  function getPopperOffsets(popper, referenceOffsets, placement) {\n    placement = placement.split('-')[0];\n\n    // Get popper node sizes\n    var popperRect = getOuterSizes(popper);\n\n    // Add position, width and height to our offsets object\n    var popperOffsets = {\n      width: popperRect.width,\n      height: popperRect.height\n    };\n\n    // depending by the popper placement we have to compute its offsets slightly differently\n    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;\n    var mainSide = isHoriz ? 'top' : 'left';\n    var secondarySide = isHoriz ? 'left' : 'top';\n    var measurement = isHoriz ? 'height' : 'width';\n    var secondaryMeasurement = !isHoriz ? 'height' : 'width';\n    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;\n    if (placement === secondarySide) {\n      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];\n    } else {\n      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];\n    }\n    return popperOffsets;\n  }\n\n  /**\n   * Mimics the `find` method of Array\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function find(arr, check) {\n    // use native find if supported\n    if (Array.prototype.find) {\n      return arr.find(check);\n    }\n\n    // use `filter` to obtain the same behavior of `find`\n    return arr.filter(check)[0];\n  }\n\n  /**\n   * Return the index of the matching object\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Array} arr\n   * @argument prop\n   * @argument value\n   * @returns index or -1\n   */\n  function findIndex(arr, prop, value) {\n    // use native findIndex if supported\n    if (Array.prototype.findIndex) {\n      return arr.findIndex(function (cur) {\n        return cur[prop] === value;\n      });\n    }\n\n    // use `find` + `indexOf` if `findIndex` isn't supported\n    var match = find(arr, function (obj) {\n      return obj[prop] === value;\n    });\n    return arr.indexOf(match);\n  }\n\n  /**\n   * Loop trough the list of modifiers and run them in order,\n   * each of them will then edit the data object.\n   * @method\n   * @memberof Popper.Utils\n   * @param {dataObject} data\n   * @param {Array} modifiers\n   * @param {String} ends - Optional modifier name used as stopper\n   * @returns {dataObject}\n   */\n  function runModifiers(modifiers, data, ends) {\n    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));\n    modifiersToRun.forEach(function (modifier) {\n      if (modifier['function']) {\n        // eslint-disable-line dot-notation\n        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');\n      }\n      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation\n      if (modifier.enabled && isFunction(fn)) {\n        // Add properties to offsets to make them a complete clientRect object\n        // we do this before each modifier to make sure the previous one doesn't\n        // mess with these values\n        data.offsets.popper = getClientRect(data.offsets.popper);\n        data.offsets.reference = getClientRect(data.offsets.reference);\n        data = fn(data, modifier);\n      }\n    });\n    return data;\n  }\n\n  /**\n   * Updates the position of the popper, computing the new offsets and applying\n   * the new style.<br />\n   * Prefer `scheduleUpdate` over `update` because of performance reasons.\n   * @method\n   * @memberof Popper\n   */\n  function update() {\n    // if popper is destroyed, don't perform any further update\n    if (this.state.isDestroyed) {\n      return;\n    }\n    var data = {\n      instance: this,\n      styles: {},\n      arrowStyles: {},\n      attributes: {},\n      flipped: false,\n      offsets: {}\n    };\n\n    // compute reference element offsets\n    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);\n\n    // store the computed placement inside `originalPlacement`\n    data.originalPlacement = data.placement;\n    data.positionFixed = this.options.positionFixed;\n\n    // compute the popper offsets\n    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);\n    data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute';\n\n    // run the modifiers\n    data = runModifiers(this.modifiers, data);\n\n    // the first `update` will call `onCreate` callback\n    // the other ones will call `onUpdate` callback\n    if (!this.state.isCreated) {\n      this.state.isCreated = true;\n      this.options.onCreate(data);\n    } else {\n      this.options.onUpdate(data);\n    }\n  }\n\n  /**\n   * Helper used to know if the given modifier is enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @returns {Boolean}\n   */\n  function isModifierEnabled(modifiers, modifierName) {\n    return modifiers.some(function (_ref) {\n      var name = _ref.name,\n        enabled = _ref.enabled;\n      return enabled && name === modifierName;\n    });\n  }\n\n  /**\n   * Get the prefixed supported property name\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} property (camelCase)\n   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)\n   */\n  function getSupportedPropertyName(property) {\n    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];\n    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);\n    for (var i = 0; i < prefixes.length; i++) {\n      var prefix = prefixes[i];\n      var toCheck = prefix ? '' + prefix + upperProp : property;\n      if (typeof document.body.style[toCheck] !== 'undefined') {\n        return toCheck;\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Destroys the popper.\n   * @method\n   * @memberof Popper\n   */\n  function destroy() {\n    this.state.isDestroyed = true;\n\n    // touch DOM only if `applyStyle` modifier is enabled\n    if (isModifierEnabled(this.modifiers, 'applyStyle')) {\n      this.popper.removeAttribute('x-placement');\n      this.popper.style.position = '';\n      this.popper.style.top = '';\n      this.popper.style.left = '';\n      this.popper.style.right = '';\n      this.popper.style.bottom = '';\n      this.popper.style.willChange = '';\n      this.popper.style[getSupportedPropertyName('transform')] = '';\n    }\n    this.disableEventListeners();\n\n    // remove the popper if user explicitly asked for the deletion on destroy\n    // do not use `remove` because IE11 doesn't support it\n    if (this.options.removeOnDestroy) {\n      this.popper.parentNode.removeChild(this.popper);\n    }\n    return this;\n  }\n\n  /**\n   * Get the window associated with the element\n   * @argument {Element} element\n   * @returns {Window}\n   */\n  function getWindow(element) {\n    var ownerDocument = element.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView : window;\n  }\n  function attachToScrollParents(scrollParent, event, callback, scrollParents) {\n    var isBody = scrollParent.nodeName === 'BODY';\n    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;\n    target.addEventListener(event, callback, {\n      passive: true\n    });\n    if (!isBody) {\n      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);\n    }\n    scrollParents.push(target);\n  }\n\n  /**\n   * Setup needed event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function setupEventListeners(reference, options, state, updateBound) {\n    // Resize event listener on window\n    state.updateBound = updateBound;\n    getWindow(reference).addEventListener('resize', state.updateBound, {\n      passive: true\n    });\n\n    // Scroll event listener on scroll parents\n    var scrollElement = getScrollParent(reference);\n    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);\n    state.scrollElement = scrollElement;\n    state.eventsEnabled = true;\n    return state;\n  }\n\n  /**\n   * It will add resize/scroll events and start recalculating\n   * position of the popper element when they are triggered.\n   * @method\n   * @memberof Popper\n   */\n  function enableEventListeners() {\n    if (!this.state.eventsEnabled) {\n      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);\n    }\n  }\n\n  /**\n   * Remove event listeners used to update the popper position\n   * @method\n   * @memberof Popper.Utils\n   * @private\n   */\n  function removeEventListeners(reference, state) {\n    // Remove resize event listener on window\n    getWindow(reference).removeEventListener('resize', state.updateBound);\n\n    // Remove scroll event listener on scroll parents\n    state.scrollParents.forEach(function (target) {\n      target.removeEventListener('scroll', state.updateBound);\n    });\n\n    // Reset state\n    state.updateBound = null;\n    state.scrollParents = [];\n    state.scrollElement = null;\n    state.eventsEnabled = false;\n    return state;\n  }\n\n  /**\n   * It will remove resize/scroll events and won't recalculate popper position\n   * when they are triggered. It also won't trigger `onUpdate` callback anymore,\n   * unless you call `update` method manually.\n   * @method\n   * @memberof Popper\n   */\n  function disableEventListeners() {\n    if (this.state.eventsEnabled) {\n      cancelAnimationFrame(this.scheduleUpdate);\n      this.state = removeEventListeners(this.reference, this.state);\n    }\n  }\n\n  /**\n   * Tells if a given input is a number\n   * @method\n   * @memberof Popper.Utils\n   * @param {*} input to check\n   * @return {Boolean}\n   */\n  function isNumeric(n) {\n    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);\n  }\n\n  /**\n   * Set the style to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the style to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setStyles(element, styles) {\n    Object.keys(styles).forEach(function (prop) {\n      var unit = '';\n      // add unit if the value is numeric and is one of the following\n      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {\n        unit = 'px';\n      }\n      element.style[prop] = styles[prop] + unit;\n    });\n  }\n\n  /**\n   * Set the attributes to the given popper\n   * @method\n   * @memberof Popper.Utils\n   * @argument {Element} element - Element to apply the attributes to\n   * @argument {Object} styles\n   * Object with a list of properties and values which will be applied to the element\n   */\n  function setAttributes(element, attributes) {\n    Object.keys(attributes).forEach(function (prop) {\n      var value = attributes[prop];\n      if (value !== false) {\n        element.setAttribute(prop, attributes[prop]);\n      } else {\n        element.removeAttribute(prop);\n      }\n    });\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} data.styles - List of style properties - values to apply to popper element\n   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The same data object\n   */\n  function applyStyle(data) {\n    // any property present in `data.styles` will be applied to the popper,\n    // in this way we can make the 3rd party modifiers add custom styles to it\n    // Be aware, modifiers could override the properties defined in the previous\n    // lines of this modifier!\n    setStyles(data.instance.popper, data.styles);\n\n    // any property present in `data.attributes` will be applied to the popper,\n    // they will be set as HTML attributes of the element\n    setAttributes(data.instance.popper, data.attributes);\n\n    // if arrowElement is defined and arrowStyles has some properties\n    if (data.arrowElement && Object.keys(data.arrowStyles).length) {\n      setStyles(data.arrowElement, data.arrowStyles);\n    }\n    return data;\n  }\n\n  /**\n   * Set the x-placement attribute before everything else because it could be used\n   * to add margins to the popper margins needs to be calculated to get the\n   * correct popper offsets.\n   * @method\n   * @memberof Popper.modifiers\n   * @param {HTMLElement} reference - The reference element used to position the popper\n   * @param {HTMLElement} popper - The HTML element used as popper\n   * @param {Object} options - Popper.js options\n   */\n  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {\n    // compute reference element offsets\n    var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed);\n\n    // compute auto placement, store placement inside the data object,\n    // modifiers will be able to edit `placement` if needed\n    // and refer to originalPlacement to know the original value\n    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);\n    popper.setAttribute('x-placement', placement);\n\n    // Apply `position` to popper before anything else because\n    // without the position applied we can't guarantee correct computations\n    setStyles(popper, {\n      position: options.positionFixed ? 'fixed' : 'absolute'\n    });\n    return options;\n  }\n\n  /**\n   * @function\n   * @memberof Popper.Utils\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Boolean} shouldRound - If the offsets should be rounded at all\n   * @returns {Object} The popper's position offsets rounded\n   *\n   * The tale of pixel-perfect positioning. It's still not 100% perfect, but as\n   * good as it can be within reason.\n   * Discussion here: https://github.com/FezVrasta/popper.js/pull/715\n   *\n   * Low DPI screens cause a popper to be blurry if not using full pixels (Safari\n   * as well on High DPI screens).\n   *\n   * Firefox prefers no rounding for positioning and does not have blurriness on\n   * high DPI screens.\n   *\n   * Only horizontal placement and left/right values need to be considered.\n   */\n  function getRoundedOffsets(data, shouldRound) {\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var round = Math.round,\n      floor = Math.floor;\n    var noRound = function noRound(v) {\n      return v;\n    };\n    var referenceWidth = round(reference.width);\n    var popperWidth = round(popper.width);\n    var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;\n    var isVariation = data.placement.indexOf('-') !== -1;\n    var sameWidthParity = referenceWidth % 2 === popperWidth % 2;\n    var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;\n    var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;\n    var verticalToInteger = !shouldRound ? noRound : round;\n    return {\n      left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),\n      top: verticalToInteger(popper.top),\n      bottom: verticalToInteger(popper.bottom),\n      right: horizontalToInteger(popper.right)\n    };\n  }\n  var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function computeStyle(data, options) {\n    var x = options.x,\n      y = options.y;\n    var popper = data.offsets.popper;\n\n    // Remove this legacy support in Popper.js v2\n\n    var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'applyStyle';\n    }).gpuAcceleration;\n    if (legacyGpuAccelerationOption !== undefined) {\n      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');\n    }\n    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;\n    var offsetParent = getOffsetParent(data.instance.popper);\n    var offsetParentRect = getBoundingClientRect(offsetParent);\n\n    // Styles\n    var styles = {\n      position: popper.position\n    };\n    var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);\n    var sideA = x === 'bottom' ? 'top' : 'bottom';\n    var sideB = y === 'right' ? 'left' : 'right';\n\n    // if gpuAcceleration is set to `true` and transform is supported,\n    //  we use `translate3d` to apply the position to the popper we\n    // automatically use the supported prefixed version if needed\n    var prefixedProperty = getSupportedPropertyName('transform');\n\n    // now, let's make a step back and look at this code closely (wtf?)\n    // If the content of the popper grows once it's been positioned, it\n    // may happen that the popper gets misplaced because of the new content\n    // overflowing its reference element\n    // To avoid this problem, we provide two options (x and y), which allow\n    // the consumer to define the offset origin.\n    // If we position a popper on top of a reference element, we can set\n    // `x` to `top` to make the popper grow towards its top instead of\n    // its bottom.\n    var left = void 0,\n      top = void 0;\n    if (sideA === 'bottom') {\n      // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)\n      // and not the bottom of the html element\n      if (offsetParent.nodeName === 'HTML') {\n        top = -offsetParent.clientHeight + offsets.bottom;\n      } else {\n        top = -offsetParentRect.height + offsets.bottom;\n      }\n    } else {\n      top = offsets.top;\n    }\n    if (sideB === 'right') {\n      if (offsetParent.nodeName === 'HTML') {\n        left = -offsetParent.clientWidth + offsets.right;\n      } else {\n        left = -offsetParentRect.width + offsets.right;\n      }\n    } else {\n      left = offsets.left;\n    }\n    if (gpuAcceleration && prefixedProperty) {\n      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';\n      styles[sideA] = 0;\n      styles[sideB] = 0;\n      styles.willChange = 'transform';\n    } else {\n      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties\n      var invertTop = sideA === 'bottom' ? -1 : 1;\n      var invertLeft = sideB === 'right' ? -1 : 1;\n      styles[sideA] = top * invertTop;\n      styles[sideB] = left * invertLeft;\n      styles.willChange = sideA + ', ' + sideB;\n    }\n\n    // Attributes\n    var attributes = {\n      'x-placement': data.placement\n    };\n\n    // Update `data` attributes, styles and arrowStyles\n    data.attributes = _extends({}, attributes, data.attributes);\n    data.styles = _extends({}, styles, data.styles);\n    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);\n    return data;\n  }\n\n  /**\n   * Helper used to know if the given modifier depends from another one.<br />\n   * It checks if the needed modifier is listed and enabled.\n   * @method\n   * @memberof Popper.Utils\n   * @param {Array} modifiers - list of modifiers\n   * @param {String} requestingName - name of requesting modifier\n   * @param {String} requestedName - name of requested modifier\n   * @returns {Boolean}\n   */\n  function isModifierRequired(modifiers, requestingName, requestedName) {\n    var requesting = find(modifiers, function (_ref) {\n      var name = _ref.name;\n      return name === requestingName;\n    });\n    var isRequired = !!requesting && modifiers.some(function (modifier) {\n      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;\n    });\n    if (!isRequired) {\n      var _requesting = '`' + requestingName + '`';\n      var requested = '`' + requestedName + '`';\n      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');\n    }\n    return isRequired;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function arrow(data, options) {\n    var _data$offsets$arrow;\n\n    // arrow depends on keepTogether in order to work\n    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {\n      return data;\n    }\n    var arrowElement = options.element;\n\n    // if arrowElement is a string, suppose it's a CSS selector\n    if (typeof arrowElement === 'string') {\n      arrowElement = data.instance.popper.querySelector(arrowElement);\n\n      // if arrowElement is not found, don't run the modifier\n      if (!arrowElement) {\n        return data;\n      }\n    } else {\n      // if the arrowElement isn't a query selector we must check that the\n      // provided DOM node is child of its popper node\n      if (!data.instance.popper.contains(arrowElement)) {\n        console.warn('WARNING: `arrow.element` must be child of its popper element!');\n        return data;\n      }\n    }\n    var placement = data.placement.split('-')[0];\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var isVertical = ['left', 'right'].indexOf(placement) !== -1;\n    var len = isVertical ? 'height' : 'width';\n    var sideCapitalized = isVertical ? 'Top' : 'Left';\n    var side = sideCapitalized.toLowerCase();\n    var altSide = isVertical ? 'left' : 'top';\n    var opSide = isVertical ? 'bottom' : 'right';\n    var arrowElementSize = getOuterSizes(arrowElement)[len];\n\n    //\n    // extends keepTogether behavior making sure the popper and its\n    // reference have enough pixels in conjunction\n    //\n\n    // top/left side\n    if (reference[opSide] - arrowElementSize < popper[side]) {\n      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);\n    }\n    // bottom/right side\n    if (reference[side] + arrowElementSize > popper[opSide]) {\n      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];\n    }\n    data.offsets.popper = getClientRect(data.offsets.popper);\n\n    // compute center of the popper\n    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;\n\n    // Compute the sideValue using the updated popper offsets\n    // take popper margin in account because we don't have this info available\n    var css = getStyleComputedProperty(data.instance.popper);\n    var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);\n    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);\n    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;\n\n    // prevent arrowElement from being placed not contiguously to its popper\n    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);\n    data.arrowElement = arrowElement;\n    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);\n    return data;\n  }\n\n  /**\n   * Get the opposite placement variation of the given one\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement variation\n   * @returns {String} flipped placement variation\n   */\n  function getOppositeVariation(variation) {\n    if (variation === 'end') {\n      return 'start';\n    } else if (variation === 'start') {\n      return 'end';\n    }\n    return variation;\n  }\n\n  /**\n   * List of accepted placements to use as values of the `placement` option.<br />\n   * Valid placements are:\n   * - `auto`\n   * - `top`\n   * - `right`\n   * - `bottom`\n   * - `left`\n   *\n   * Each placement can have a variation from this list:\n   * - `-start`\n   * - `-end`\n   *\n   * Variations are interpreted easily if you think of them as the left to right\n   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`\n   * is right.<br />\n   * Vertically (`left` and `right`), `start` is top and `end` is bottom.\n   *\n   * Some valid examples are:\n   * - `top-end` (on top of reference, right aligned)\n   * - `right-start` (on right of reference, top aligned)\n   * - `bottom` (on bottom, centered)\n   * - `auto-end` (on the side with more space available, alignment depends by placement)\n   *\n   * @static\n   * @type {Array}\n   * @enum {String}\n   * @readonly\n   * @method placements\n   * @memberof Popper\n   */\n  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];\n\n  // Get rid of `auto` `auto-start` and `auto-end`\n  var validPlacements = placements.slice(3);\n\n  /**\n   * Given an initial placement, returns all the subsequent placements\n   * clockwise (or counter-clockwise).\n   *\n   * @method\n   * @memberof Popper.Utils\n   * @argument {String} placement - A valid placement (it accepts variations)\n   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise\n   * @returns {Array} placements including their variations\n   */\n  function clockwise(placement) {\n    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var index = validPlacements.indexOf(placement);\n    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));\n    return counter ? arr.reverse() : arr;\n  }\n  var BEHAVIORS = {\n    FLIP: 'flip',\n    CLOCKWISE: 'clockwise',\n    COUNTERCLOCKWISE: 'counterclockwise'\n  };\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function flip(data, options) {\n    // if `inner` modifier is enabled, we can't use the `flip` modifier\n    if (isModifierEnabled(data.instance.modifiers, 'inner')) {\n      return data;\n    }\n    if (data.flipped && data.placement === data.originalPlacement) {\n      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides\n      return data;\n    }\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);\n    var placement = data.placement.split('-')[0];\n    var placementOpposite = getOppositePlacement(placement);\n    var variation = data.placement.split('-')[1] || '';\n    var flipOrder = [];\n    switch (options.behavior) {\n      case BEHAVIORS.FLIP:\n        flipOrder = [placement, placementOpposite];\n        break;\n      case BEHAVIORS.CLOCKWISE:\n        flipOrder = clockwise(placement);\n        break;\n      case BEHAVIORS.COUNTERCLOCKWISE:\n        flipOrder = clockwise(placement, true);\n        break;\n      default:\n        flipOrder = options.behavior;\n    }\n    flipOrder.forEach(function (step, index) {\n      if (placement !== step || flipOrder.length === index + 1) {\n        return data;\n      }\n      placement = data.placement.split('-')[0];\n      placementOpposite = getOppositePlacement(placement);\n      var popperOffsets = data.offsets.popper;\n      var refOffsets = data.offsets.reference;\n\n      // using floor because the reference offsets may contain decimals we are not going to consider here\n      var floor = Math.floor;\n      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);\n      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);\n      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);\n      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);\n      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);\n      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;\n\n      // flip the variation if required\n      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n\n      // flips variation if reference element overflows boundaries\n      var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);\n\n      // flips variation if popper content overflows boundaries\n      var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);\n      var flippedVariation = flippedVariationByRef || flippedVariationByContent;\n      if (overlapsRef || overflowsBoundaries || flippedVariation) {\n        // this boolean to detect any flip loop\n        data.flipped = true;\n        if (overlapsRef || overflowsBoundaries) {\n          placement = flipOrder[index + 1];\n        }\n        if (flippedVariation) {\n          variation = getOppositeVariation(variation);\n        }\n        data.placement = placement + (variation ? '-' + variation : '');\n\n        // this object contains `position`, we want to preserve it along with\n        // any additional property we may add in the future\n        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));\n        data = runModifiers(data.instance.modifiers, data, 'flip');\n      }\n    });\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function keepTogether(data) {\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var placement = data.placement.split('-')[0];\n    var floor = Math.floor;\n    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;\n    var side = isVertical ? 'right' : 'bottom';\n    var opSide = isVertical ? 'left' : 'top';\n    var measurement = isVertical ? 'width' : 'height';\n    if (popper[side] < floor(reference[opSide])) {\n      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];\n    }\n    if (popper[opSide] > floor(reference[side])) {\n      data.offsets.popper[opSide] = floor(reference[side]);\n    }\n    return data;\n  }\n\n  /**\n   * Converts a string containing value + unit into a px value number\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} str - Value + unit string\n   * @argument {String} measurement - `height` or `width`\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @returns {Number|String}\n   * Value in pixels, or original string if no values were extracted\n   */\n  function toValue(str, measurement, popperOffsets, referenceOffsets) {\n    // separate value from unit\n    var split = str.match(/((?:\\-|\\+)?\\d*\\.?\\d*)(.*)/);\n    var value = +split[1];\n    var unit = split[2];\n\n    // If it's not a number it's an operator, I guess\n    if (!value) {\n      return str;\n    }\n    if (unit.indexOf('%') === 0) {\n      var element = void 0;\n      switch (unit) {\n        case '%p':\n          element = popperOffsets;\n          break;\n        case '%':\n        case '%r':\n        default:\n          element = referenceOffsets;\n      }\n      var rect = getClientRect(element);\n      return rect[measurement] / 100 * value;\n    } else if (unit === 'vh' || unit === 'vw') {\n      // if is a vh or vw, we calculate the size based on the viewport\n      var size = void 0;\n      if (unit === 'vh') {\n        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);\n      } else {\n        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);\n      }\n      return size / 100 * value;\n    } else {\n      // if is an explicit pixel unit, we get rid of the unit and keep the value\n      // if is an implicit unit, it's px, and we return just the value\n      return value;\n    }\n  }\n\n  /**\n   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.\n   * @function\n   * @memberof {modifiers~offset}\n   * @private\n   * @argument {String} offset\n   * @argument {Object} popperOffsets\n   * @argument {Object} referenceOffsets\n   * @argument {String} basePlacement\n   * @returns {Array} a two cells array with x and y offsets in numbers\n   */\n  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {\n    var offsets = [0, 0];\n\n    // Use height if placement is left or right and index is 0 otherwise use width\n    // in this way the first offset will use an axis and the second one\n    // will use the other one\n    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;\n\n    // Split the offset string to obtain a list of values and operands\n    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)\n    var fragments = offset.split(/(\\+|\\-)/).map(function (frag) {\n      return frag.trim();\n    });\n\n    // Detect if the offset string contains a pair of values or a single one\n    // they could be separated by comma or space\n    var divider = fragments.indexOf(find(fragments, function (frag) {\n      return frag.search(/,|\\s/) !== -1;\n    }));\n    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {\n      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');\n    }\n\n    // If divider is found, we divide the list of values and operands to divide\n    // them by ofset X and Y.\n    var splitRegex = /\\s*,\\s*|\\s+/;\n    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];\n\n    // Convert the values with units to absolute pixels to allow our computations\n    ops = ops.map(function (op, index) {\n      // Most of the units rely on the orientation of the popper\n      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';\n      var mergeWithPrevious = false;\n      return op\n      // This aggregates any `+` or `-` sign that aren't considered operators\n      // e.g.: 10 + +5 => [10, +, +5]\n      .reduce(function (a, b) {\n        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {\n          a[a.length - 1] = b;\n          mergeWithPrevious = true;\n          return a;\n        } else if (mergeWithPrevious) {\n          a[a.length - 1] += b;\n          mergeWithPrevious = false;\n          return a;\n        } else {\n          return a.concat(b);\n        }\n      }, [])\n      // Here we convert the string values into number values (in px)\n      .map(function (str) {\n        return toValue(str, measurement, popperOffsets, referenceOffsets);\n      });\n    });\n\n    // Loop trough the offsets arrays and execute the operations\n    ops.forEach(function (op, index) {\n      op.forEach(function (frag, index2) {\n        if (isNumeric(frag)) {\n          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);\n        }\n      });\n    });\n    return offsets;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @argument {Number|String} options.offset=0\n   * The offset value as described in the modifier description\n   * @returns {Object} The data object, properly modified\n   */\n  function offset(data, _ref) {\n    var offset = _ref.offset;\n    var placement = data.placement,\n      _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var basePlacement = placement.split('-')[0];\n    var offsets = void 0;\n    if (isNumeric(+offset)) {\n      offsets = [+offset, 0];\n    } else {\n      offsets = parseOffset(offset, popper, reference, basePlacement);\n    }\n    if (basePlacement === 'left') {\n      popper.top += offsets[0];\n      popper.left -= offsets[1];\n    } else if (basePlacement === 'right') {\n      popper.top += offsets[0];\n      popper.left += offsets[1];\n    } else if (basePlacement === 'top') {\n      popper.left += offsets[0];\n      popper.top -= offsets[1];\n    } else if (basePlacement === 'bottom') {\n      popper.left += offsets[0];\n      popper.top += offsets[1];\n    }\n    data.popper = popper;\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function preventOverflow(data, options) {\n    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);\n\n    // If offsetParent is the reference element, we really want to\n    // go one step up and use the next offsetParent as reference to\n    // avoid to make this modifier completely useless and look like broken\n    if (data.instance.reference === boundariesElement) {\n      boundariesElement = getOffsetParent(boundariesElement);\n    }\n\n    // NOTE: DOM access here\n    // resets the popper's position so that the document size can be calculated excluding\n    // the size of the popper element itself\n    var transformProp = getSupportedPropertyName('transform');\n    var popperStyles = data.instance.popper.style; // assignment to help minification\n    var top = popperStyles.top,\n      left = popperStyles.left,\n      transform = popperStyles[transformProp];\n    popperStyles.top = '';\n    popperStyles.left = '';\n    popperStyles[transformProp] = '';\n    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed);\n\n    // NOTE: DOM access here\n    // restores the original style properties after the offsets have been computed\n    popperStyles.top = top;\n    popperStyles.left = left;\n    popperStyles[transformProp] = transform;\n    options.boundaries = boundaries;\n    var order = options.priority;\n    var popper = data.offsets.popper;\n    var check = {\n      primary: function primary(placement) {\n        var value = popper[placement];\n        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {\n          value = Math.max(popper[placement], boundaries[placement]);\n        }\n        return defineProperty({}, placement, value);\n      },\n      secondary: function secondary(placement) {\n        var mainSide = placement === 'right' ? 'left' : 'top';\n        var value = popper[mainSide];\n        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {\n          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));\n        }\n        return defineProperty({}, mainSide, value);\n      }\n    };\n    order.forEach(function (placement) {\n      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';\n      popper = _extends({}, popper, check[side](placement));\n    });\n    data.offsets.popper = popper;\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function shift(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var shiftvariation = placement.split('-')[1];\n\n    // if shift shiftvariation is specified, run the modifier\n    if (shiftvariation) {\n      var _data$offsets = data.offsets,\n        reference = _data$offsets.reference,\n        popper = _data$offsets.popper;\n      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;\n      var side = isVertical ? 'left' : 'top';\n      var measurement = isVertical ? 'width' : 'height';\n      var shiftOffsets = {\n        start: defineProperty({}, side, reference[side]),\n        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])\n      };\n      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);\n    }\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by update method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function hide(data) {\n    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {\n      return data;\n    }\n    var refRect = data.offsets.reference;\n    var bound = find(data.instance.modifiers, function (modifier) {\n      return modifier.name === 'preventOverflow';\n    }).boundaries;\n    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === true) {\n        return data;\n      }\n      data.hide = true;\n      data.attributes['x-out-of-boundaries'] = '';\n    } else {\n      // Avoid unnecessary DOM access if visibility hasn't changed\n      if (data.hide === false) {\n        return data;\n      }\n      data.hide = false;\n      data.attributes['x-out-of-boundaries'] = false;\n    }\n    return data;\n  }\n\n  /**\n   * @function\n   * @memberof Modifiers\n   * @argument {Object} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {Object} The data object, properly modified\n   */\n  function inner(data) {\n    var placement = data.placement;\n    var basePlacement = placement.split('-')[0];\n    var _data$offsets = data.offsets,\n      popper = _data$offsets.popper,\n      reference = _data$offsets.reference;\n    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;\n    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;\n    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);\n    data.placement = getOppositePlacement(placement);\n    data.offsets.popper = getClientRect(popper);\n    return data;\n  }\n\n  /**\n   * Modifier function, each modifier can have a function of this type assigned\n   * to its `fn` property.<br />\n   * These functions will be called on each update, this means that you must\n   * make sure they are performant enough to avoid performance bottlenecks.\n   *\n   * @function ModifierFn\n   * @argument {dataObject} data - The data object generated by `update` method\n   * @argument {Object} options - Modifiers configuration and options\n   * @returns {dataObject} The data object, properly modified\n   */\n\n  /**\n   * Modifiers are plugins used to alter the behavior of your poppers.<br />\n   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities\n   * needed by the library.\n   *\n   * Usually you don't want to override the `order`, `fn` and `onLoad` props.\n   * All the other properties are configurations that could be tweaked.\n   * @namespace modifiers\n   */\n  var modifiers = {\n    /**\n     * Modifier used to shift the popper on the start or end of its reference\n     * element.<br />\n     * It will read the variation of the `placement` property.<br />\n     * It can be one either `-end` or `-start`.\n     * @memberof modifiers\n     * @inner\n     */\n    shift: {\n      /** @prop {number} order=100 - Index used to define the order of execution */\n      order: 100,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: shift\n    },\n    /**\n     * The `offset` modifier can shift your popper on both its axis.\n     *\n     * It accepts the following units:\n     * - `px` or unit-less, interpreted as pixels\n     * - `%` or `%r`, percentage relative to the length of the reference element\n     * - `%p`, percentage relative to the length of the popper element\n     * - `vw`, CSS viewport width unit\n     * - `vh`, CSS viewport height unit\n     *\n     * For length is intended the main axis relative to the placement of the popper.<br />\n     * This means that if the placement is `top` or `bottom`, the length will be the\n     * `width`. In case of `left` or `right`, it will be the `height`.\n     *\n     * You can provide a single value (as `Number` or `String`), or a pair of values\n     * as `String` divided by a comma or one (or more) white spaces.<br />\n     * The latter is a deprecated method because it leads to confusion and will be\n     * removed in v2.<br />\n     * Additionally, it accepts additions and subtractions between different units.\n     * Note that multiplications and divisions aren't supported.\n     *\n     * Valid examples are:\n     * ```\n     * 10\n     * '10%'\n     * '10, 10'\n     * '10%, 10'\n     * '10 + 10%'\n     * '10 - 5vh + 3%'\n     * '-10px + 5vh, 5px - 6%'\n     * ```\n     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap\n     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.\n     * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    offset: {\n      /** @prop {number} order=200 - Index used to define the order of execution */\n      order: 200,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: offset,\n      /** @prop {Number|String} offset=0\n       * The offset value as described in the modifier description\n       */\n      offset: 0\n    },\n    /**\n     * Modifier used to prevent the popper from being positioned outside the boundary.\n     *\n     * A scenario exists where the reference itself is not within the boundaries.<br />\n     * We can say it has \"escaped the boundaries\" — or just \"escaped\".<br />\n     * In this case we need to decide whether the popper should either:\n     *\n     * - detach from the reference and remain \"trapped\" in the boundaries, or\n     * - if it should ignore the boundary and \"escape with its reference\"\n     *\n     * When `escapeWithReference` is set to`true` and reference is completely\n     * outside its boundaries, the popper will overflow (or completely leave)\n     * the boundaries in order to remain attached to the edge of the reference.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    preventOverflow: {\n      /** @prop {number} order=300 - Index used to define the order of execution */\n      order: 300,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: preventOverflow,\n      /**\n       * @prop {Array} [priority=['left','right','top','bottom']]\n       * Popper will try to prevent overflow following these priorities by default,\n       * then, it could overflow on the left and on top of the `boundariesElement`\n       */\n      priority: ['left', 'right', 'top', 'bottom'],\n      /**\n       * @prop {number} padding=5\n       * Amount of pixel used to define a minimum distance between the boundaries\n       * and the popper. This makes sure the popper always has a little padding\n       * between the edges of its container\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='scrollParent'\n       * Boundaries used by the modifier. Can be `scrollParent`, `window`,\n       * `viewport` or any DOM element.\n       */\n      boundariesElement: 'scrollParent'\n    },\n    /**\n     * Modifier used to make sure the reference and its popper stay near each other\n     * without leaving any gap between the two. Especially useful when the arrow is\n     * enabled and you want to ensure that it points to its reference element.\n     * It cares only about the first axis. You can still have poppers with margin\n     * between the popper and its reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    keepTogether: {\n      /** @prop {number} order=400 - Index used to define the order of execution */\n      order: 400,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: keepTogether\n    },\n    /**\n     * This modifier is used to move the `arrowElement` of the popper to make\n     * sure it is positioned between the reference element and its popper element.\n     * It will read the outer size of the `arrowElement` node to detect how many\n     * pixels of conjunction are needed.\n     *\n     * It has no effect if no `arrowElement` is provided.\n     * @memberof modifiers\n     * @inner\n     */\n    arrow: {\n      /** @prop {number} order=500 - Index used to define the order of execution */\n      order: 500,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: arrow,\n      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */\n      element: '[x-arrow]'\n    },\n    /**\n     * Modifier used to flip the popper's placement when it starts to overlap its\n     * reference element.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     *\n     * **NOTE:** this modifier will interrupt the current update cycle and will\n     * restart it if it detects the need to flip the placement.\n     * @memberof modifiers\n     * @inner\n     */\n    flip: {\n      /** @prop {number} order=600 - Index used to define the order of execution */\n      order: 600,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: flip,\n      /**\n       * @prop {String|Array} behavior='flip'\n       * The behavior used to change the popper's placement. It can be one of\n       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid\n       * placements (with optional variations)\n       */\n      behavior: 'flip',\n      /**\n       * @prop {number} padding=5\n       * The popper will flip if it hits the edges of the `boundariesElement`\n       */\n      padding: 5,\n      /**\n       * @prop {String|HTMLElement} boundariesElement='viewport'\n       * The element which will define the boundaries of the popper position.\n       * The popper will never be placed outside of the defined boundaries\n       * (except if `keepTogether` is enabled)\n       */\n      boundariesElement: 'viewport',\n      /**\n       * @prop {Boolean} flipVariations=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the reference element overlaps its boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariations: false,\n      /**\n       * @prop {Boolean} flipVariationsByContent=false\n       * The popper will switch placement variation between `-start` and `-end` when\n       * the popper element overlaps its reference boundaries.\n       *\n       * The original placement should have a set variation.\n       */\n      flipVariationsByContent: false\n    },\n    /**\n     * Modifier used to make the popper flow toward the inner of the reference element.\n     * By default, when this modifier is disabled, the popper will be placed outside\n     * the reference element.\n     * @memberof modifiers\n     * @inner\n     */\n    inner: {\n      /** @prop {number} order=700 - Index used to define the order of execution */\n      order: 700,\n      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */\n      enabled: false,\n      /** @prop {ModifierFn} */\n      fn: inner\n    },\n    /**\n     * Modifier used to hide the popper when its reference element is outside of the\n     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can\n     * be used to hide with a CSS selector the popper when its reference is\n     * out of boundaries.\n     *\n     * Requires the `preventOverflow` modifier before it in order to work.\n     * @memberof modifiers\n     * @inner\n     */\n    hide: {\n      /** @prop {number} order=800 - Index used to define the order of execution */\n      order: 800,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: hide\n    },\n    /**\n     * Computes the style that will be applied to the popper element to gets\n     * properly positioned.\n     *\n     * Note that this modifier will not touch the DOM, it just prepares the styles\n     * so that `applyStyle` modifier can apply it. This separation is useful\n     * in case you need to replace `applyStyle` with a custom implementation.\n     *\n     * This modifier has `850` as `order` value to maintain backward compatibility\n     * with previous versions of Popper.js. Expect the modifiers ordering method\n     * to change in future major versions of the library.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    computeStyle: {\n      /** @prop {number} order=850 - Index used to define the order of execution */\n      order: 850,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: computeStyle,\n      /**\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: true,\n      /**\n       * @prop {string} [x='bottom']\n       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.\n       * Change this if your popper should grow in a direction different from `bottom`\n       */\n      x: 'bottom',\n      /**\n       * @prop {string} [x='left']\n       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.\n       * Change this if your popper should grow in a direction different from `right`\n       */\n      y: 'right'\n    },\n    /**\n     * Applies the computed styles to the popper element.\n     *\n     * All the DOM manipulations are limited to this modifier. This is useful in case\n     * you want to integrate Popper.js inside a framework or view library and you\n     * want to delegate all the DOM manipulations to it.\n     *\n     * Note that if you disable this modifier, you must make sure the popper element\n     * has its position set to `absolute` before Popper.js can do its work!\n     *\n     * Just disable this modifier and define your own to achieve the desired effect.\n     *\n     * @memberof modifiers\n     * @inner\n     */\n    applyStyle: {\n      /** @prop {number} order=900 - Index used to define the order of execution */\n      order: 900,\n      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */\n      enabled: true,\n      /** @prop {ModifierFn} */\n      fn: applyStyle,\n      /** @prop {Function} */\n      onLoad: applyStyleOnLoad,\n      /**\n       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier\n       * @prop {Boolean} gpuAcceleration=true\n       * If true, it uses the CSS 3D transformation to position the popper.\n       * Otherwise, it will use the `top` and `left` properties\n       */\n      gpuAcceleration: undefined\n    }\n  };\n\n  /**\n   * The `dataObject` is an object containing all the information used by Popper.js.\n   * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.\n   * @name dataObject\n   * @property {Object} data.instance The Popper.js instance\n   * @property {String} data.placement Placement applied to popper\n   * @property {String} data.originalPlacement Placement originally defined on init\n   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier\n   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper\n   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier\n   * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)\n   * @property {Object} data.boundaries Offsets of the popper boundaries\n   * @property {Object} data.offsets The measurements of popper, reference and arrow elements\n   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values\n   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0\n   */\n\n  /**\n   * Default options provided to Popper.js constructor.<br />\n   * These can be overridden using the `options` argument of Popper.js.<br />\n   * To override an option, simply pass an object with the same\n   * structure of the `options` object, as the 3rd argument. For example:\n   * ```\n   * new Popper(ref, pop, {\n   *   modifiers: {\n   *     preventOverflow: { enabled: false }\n   *   }\n   * })\n   * ```\n   * @type {Object}\n   * @static\n   * @memberof Popper\n   */\n  var Defaults = {\n    /**\n     * Popper's placement.\n     * @prop {Popper.placements} placement='bottom'\n     */\n    placement: 'bottom',\n    /**\n     * Set this to true if you want popper to position it self in 'fixed' mode\n     * @prop {Boolean} positionFixed=false\n     */\n    positionFixed: false,\n    /**\n     * Whether events (resize, scroll) are initially enabled.\n     * @prop {Boolean} eventsEnabled=true\n     */\n    eventsEnabled: true,\n    /**\n     * Set to true if you want to automatically remove the popper when\n     * you call the `destroy` method.\n     * @prop {Boolean} removeOnDestroy=false\n     */\n    removeOnDestroy: false,\n    /**\n     * Callback called when the popper is created.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onCreate}\n     */\n    onCreate: function onCreate() {},\n    /**\n     * Callback called when the popper is updated. This callback is not called\n     * on the initialization/creation of the popper, but only on subsequent\n     * updates.<br />\n     * By default, it is set to no-op.<br />\n     * Access Popper.js instance with `data.instance`.\n     * @prop {onUpdate}\n     */\n    onUpdate: function onUpdate() {},\n    /**\n     * List of modifiers used to modify the offsets before they are applied to the popper.\n     * They provide most of the functionalities of Popper.js.\n     * @prop {modifiers}\n     */\n    modifiers: modifiers\n  };\n\n  /**\n   * @callback onCreate\n   * @param {dataObject} data\n   */\n\n  /**\n   * @callback onUpdate\n   * @param {dataObject} data\n   */\n\n  // Utils\n  // Methods\n  var Popper = function () {\n    /**\n     * Creates a new Popper.js instance.\n     * @class Popper\n     * @param {Element|referenceObject} reference - The reference element used to position the popper\n     * @param {Element} popper - The HTML / XML element used as the popper\n     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)\n     * @return {Object} instance - The generated Popper.js instance\n     */\n    function Popper(reference, popper) {\n      var _this = this;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      classCallCheck(this, Popper);\n      this.scheduleUpdate = function () {\n        return requestAnimationFrame(_this.update);\n      };\n\n      // make update() debounced, so that it only runs at most once-per-tick\n      this.update = debounce(this.update.bind(this));\n\n      // with {} we create a new object with the options inside it\n      this.options = _extends({}, Popper.Defaults, options);\n\n      // init state\n      this.state = {\n        isDestroyed: false,\n        isCreated: false,\n        scrollParents: []\n      };\n\n      // get reference and popper elements (allow jQuery wrappers)\n      this.reference = reference && reference.jquery ? reference[0] : reference;\n      this.popper = popper && popper.jquery ? popper[0] : popper;\n\n      // Deep merge modifiers options\n      this.options.modifiers = {};\n      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {\n        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});\n      });\n\n      // Refactoring modifiers' list (Object => Array)\n      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {\n        return _extends({\n          name: name\n        }, _this.options.modifiers[name]);\n      })\n      // sort the modifiers by order\n      .sort(function (a, b) {\n        return a.order - b.order;\n      });\n\n      // modifiers have the ability to execute arbitrary code when Popper.js get inited\n      // such code is executed in the same order of its modifier\n      // they could add new properties to their options configuration\n      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!\n      this.modifiers.forEach(function (modifierOptions) {\n        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {\n          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);\n        }\n      });\n\n      // fire the first update to position the popper in the right place\n      this.update();\n      var eventsEnabled = this.options.eventsEnabled;\n      if (eventsEnabled) {\n        // setup event listeners, they will take care of update the position in specific situations\n        this.enableEventListeners();\n      }\n      this.state.eventsEnabled = eventsEnabled;\n    }\n\n    // We can't use class properties because they don't get listed in the\n    // class prototype and break stuff like Sinon stubs\n\n    createClass(Popper, [{\n      key: 'update',\n      value: function update$$1() {\n        return update.call(this);\n      }\n    }, {\n      key: 'destroy',\n      value: function destroy$$1() {\n        return destroy.call(this);\n      }\n    }, {\n      key: 'enableEventListeners',\n      value: function enableEventListeners$$1() {\n        return enableEventListeners.call(this);\n      }\n    }, {\n      key: 'disableEventListeners',\n      value: function disableEventListeners$$1() {\n        return disableEventListeners.call(this);\n      }\n\n      /**\n       * Schedules an update. It will run on the next UI update available.\n       * @method scheduleUpdate\n       * @memberof Popper\n       */\n\n      /**\n       * Collection of utilities useful when writing custom modifiers.\n       * Starting from version 1.7, this method is available only if you\n       * include `popper-utils.js` before `popper.js`.\n       *\n       * **DEPRECATION**: This way to access PopperUtils is deprecated\n       * and will be removed in v2! Use the PopperUtils module directly instead.\n       * Due to the high instability of the methods contained in Utils, we can't\n       * guarantee them to follow semver. Use them at your own risk!\n       * @static\n       * @private\n       * @type {Object}\n       * @deprecated since version 1.8\n       * @member Utils\n       * @memberof Popper\n       */\n    }]);\n\n    return Popper;\n  }();\n\n  /**\n   * The `referenceObject` is an object that provides an interface compatible with Popper.js\n   * and lets you use it as replacement of a real DOM node.<br />\n   * You can use this method to position a popper relatively to a set of coordinates\n   * in case you don't have a DOM node to use as reference.\n   *\n   * ```\n   * new Popper(referenceObject, popperNode);\n   * ```\n   *\n   * NB: This feature isn't supported in Internet Explorer 10.\n   * @name referenceObject\n   * @property {Function} data.getBoundingClientRect\n   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.\n   * @property {number} data.clientWidth\n   * An ES6 getter that will return the width of the virtual reference element.\n   * @property {number} data.clientHeight\n   * An ES6 getter that will return the height of the virtual reference element.\n   */\n\n  Popper.Utils = (typeof window !== 'undefined' ? window : __webpack_require__.g).PopperUtils;\n  Popper.placements = placements;\n  Popper.Defaults = Defaults;\n  var Popper$1 = Popper;\n\n  /**\n   * Constants\n   */\n\n  var NAME$6 = 'dropdown';\n  var VERSION$6 = '4.6.1';\n  var DATA_KEY$6 = 'bs.dropdown';\n  var EVENT_KEY$6 = \".\" + DATA_KEY$6;\n  var DATA_API_KEY$3 = '.data-api';\n  var JQUERY_NO_CONFLICT$6 = $__default[\"default\"].fn[NAME$6];\n  var ESCAPE_KEYCODE$1 = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var SPACE_KEYCODE = 32; // KeyboardEvent.which value for space key\n\n  var TAB_KEYCODE = 9; // KeyboardEvent.which value for tab key\n\n  var ARROW_UP_KEYCODE = 38; // KeyboardEvent.which value for up arrow key\n\n  var ARROW_DOWN_KEYCODE = 40; // KeyboardEvent.which value for down arrow key\n\n  var RIGHT_MOUSE_BUTTON_WHICH = 3; // MouseEvent.which value for the right button (assuming a right-handed mouse)\n\n  var REGEXP_KEYDOWN = new RegExp(ARROW_UP_KEYCODE + \"|\" + ARROW_DOWN_KEYCODE + \"|\" + ESCAPE_KEYCODE$1);\n  var CLASS_NAME_DISABLED$1 = 'disabled';\n  var CLASS_NAME_SHOW$5 = 'show';\n  var CLASS_NAME_DROPUP = 'dropup';\n  var CLASS_NAME_DROPRIGHT = 'dropright';\n  var CLASS_NAME_DROPLEFT = 'dropleft';\n  var CLASS_NAME_MENURIGHT = 'dropdown-menu-right';\n  var CLASS_NAME_POSITION_STATIC = 'position-static';\n  var EVENT_HIDE$3 = \"hide\" + EVENT_KEY$6;\n  var EVENT_HIDDEN$3 = \"hidden\" + EVENT_KEY$6;\n  var EVENT_SHOW$3 = \"show\" + EVENT_KEY$6;\n  var EVENT_SHOWN$3 = \"shown\" + EVENT_KEY$6;\n  var EVENT_CLICK = \"click\" + EVENT_KEY$6;\n  var EVENT_CLICK_DATA_API$2 = \"click\" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var EVENT_KEYDOWN_DATA_API = \"keydown\" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var EVENT_KEYUP_DATA_API = \"keyup\" + EVENT_KEY$6 + DATA_API_KEY$3;\n  var SELECTOR_DATA_TOGGLE$2 = '[data-toggle=\"dropdown\"]';\n  var SELECTOR_FORM_CHILD = '.dropdown form';\n  var SELECTOR_MENU = '.dropdown-menu';\n  var SELECTOR_NAVBAR_NAV = '.navbar-nav';\n  var SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\n  var PLACEMENT_TOP = 'top-start';\n  var PLACEMENT_TOPEND = 'top-end';\n  var PLACEMENT_BOTTOM = 'bottom-start';\n  var PLACEMENT_BOTTOMEND = 'bottom-end';\n  var PLACEMENT_RIGHT = 'right-start';\n  var PLACEMENT_LEFT = 'left-start';\n  var Default$5 = {\n    offset: 0,\n    flip: true,\n    boundary: 'scrollParent',\n    reference: 'toggle',\n    display: 'dynamic',\n    popperConfig: null\n  };\n  var DefaultType$5 = {\n    offset: '(number|string|function)',\n    flip: 'boolean',\n    boundary: '(string|element)',\n    reference: '(string|element)',\n    display: 'string',\n    popperConfig: '(null|object)'\n  };\n  /**\n   * Class definition\n   */\n\n  var Dropdown = /*#__PURE__*/function () {\n    function Dropdown(element, config) {\n      this._element = element;\n      this._popper = null;\n      this._config = this._getConfig(config);\n      this._menu = this._getMenuElement();\n      this._inNavbar = this._detectNavbar();\n      this._addEventListeners();\n    } // Getters\n\n    var _proto = Dropdown.prototype;\n\n    // Public\n    _proto.toggle = function toggle() {\n      if (this._element.disabled || $__default[\"default\"](this._element).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n      var isActive = $__default[\"default\"](this._menu).hasClass(CLASS_NAME_SHOW$5);\n      Dropdown._clearMenus();\n      if (isActive) {\n        return;\n      }\n      this.show(true);\n    };\n    _proto.show = function show(usePopper) {\n      if (usePopper === void 0) {\n        usePopper = false;\n      }\n      if (this._element.disabled || $__default[\"default\"](this._element).hasClass(CLASS_NAME_DISABLED$1) || $__default[\"default\"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var showEvent = $__default[\"default\"].Event(EVENT_SHOW$3, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      $__default[\"default\"](parent).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      } // Totally disable Popper for Dropdowns in Navbar\n\n      if (!this._inNavbar && usePopper) {\n        // Check for Popper dependency\n        if (typeof Popper$1 === 'undefined') {\n          throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org)');\n        }\n        var referenceElement = this._element;\n        if (this._config.reference === 'parent') {\n          referenceElement = parent;\n        } else if (Util.isElement(this._config.reference)) {\n          referenceElement = this._config.reference; // Check if it's jQuery element\n\n          if (typeof this._config.reference.jquery !== 'undefined') {\n            referenceElement = this._config.reference[0];\n          }\n        } // If boundary is not `scrollParent`, then set position to `static`\n        // to allow the menu to \"escape\" the scroll parent's boundaries\n        // https://github.com/twbs/bootstrap/issues/24251\n\n        if (this._config.boundary !== 'scrollParent') {\n          $__default[\"default\"](parent).addClass(CLASS_NAME_POSITION_STATIC);\n        }\n        this._popper = new Popper$1(referenceElement, this._menu, this._getPopperConfig());\n      } // If this is a touch-enabled device we add extra\n      // empty mouseover listeners to the body's immediate children;\n      // only needed because of broken event delegation on iOS\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n      if ('ontouchstart' in document.documentElement && $__default[\"default\"](parent).closest(SELECTOR_NAVBAR_NAV).length === 0) {\n        $__default[\"default\"](document.body).children().on('mouseover', null, $__default[\"default\"].noop);\n      }\n      this._element.focus();\n      this._element.setAttribute('aria-expanded', true);\n      $__default[\"default\"](this._menu).toggleClass(CLASS_NAME_SHOW$5);\n      $__default[\"default\"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default[\"default\"].Event(EVENT_SHOWN$3, relatedTarget));\n    };\n    _proto.hide = function hide() {\n      if (this._element.disabled || $__default[\"default\"](this._element).hasClass(CLASS_NAME_DISABLED$1) || !$__default[\"default\"](this._menu).hasClass(CLASS_NAME_SHOW$5)) {\n        return;\n      }\n      var relatedTarget = {\n        relatedTarget: this._element\n      };\n      var hideEvent = $__default[\"default\"].Event(EVENT_HIDE$3, relatedTarget);\n      var parent = Dropdown._getParentFromElement(this._element);\n      $__default[\"default\"](parent).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      $__default[\"default\"](this._menu).toggleClass(CLASS_NAME_SHOW$5);\n      $__default[\"default\"](parent).toggleClass(CLASS_NAME_SHOW$5).trigger($__default[\"default\"].Event(EVENT_HIDDEN$3, relatedTarget));\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$6);\n      $__default[\"default\"](this._element).off(EVENT_KEY$6);\n      this._element = null;\n      this._menu = null;\n      if (this._popper !== null) {\n        this._popper.destroy();\n        this._popper = null;\n      }\n    };\n    _proto.update = function update() {\n      this._inNavbar = this._detectNavbar();\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Private\n    ;\n\n    _proto._addEventListeners = function _addEventListeners() {\n      var _this = this;\n      $__default[\"default\"](this._element).on(EVENT_CLICK, function (event) {\n        event.preventDefault();\n        event.stopPropagation();\n        _this.toggle();\n      });\n    };\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, this.constructor.Default, $__default[\"default\"](this._element).data(), config);\n      Util.typeCheckConfig(NAME$6, config, this.constructor.DefaultType);\n      return config;\n    };\n    _proto._getMenuElement = function _getMenuElement() {\n      if (!this._menu) {\n        var parent = Dropdown._getParentFromElement(this._element);\n        if (parent) {\n          this._menu = parent.querySelector(SELECTOR_MENU);\n        }\n      }\n      return this._menu;\n    };\n    _proto._getPlacement = function _getPlacement() {\n      var $parentDropdown = $__default[\"default\"](this._element.parentNode);\n      var placement = PLACEMENT_BOTTOM; // Handle dropup\n\n      if ($parentDropdown.hasClass(CLASS_NAME_DROPUP)) {\n        placement = $__default[\"default\"](this._menu).hasClass(CLASS_NAME_MENURIGHT) ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPRIGHT)) {\n        placement = PLACEMENT_RIGHT;\n      } else if ($parentDropdown.hasClass(CLASS_NAME_DROPLEFT)) {\n        placement = PLACEMENT_LEFT;\n      } else if ($__default[\"default\"](this._menu).hasClass(CLASS_NAME_MENURIGHT)) {\n        placement = PLACEMENT_BOTTOMEND;\n      }\n      return placement;\n    };\n    _proto._detectNavbar = function _detectNavbar() {\n      return $__default[\"default\"](this._element).closest('.navbar').length > 0;\n    };\n    _proto._getOffset = function _getOffset() {\n      var _this2 = this;\n      var offset = {};\n      if (typeof this._config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends$1({}, data.offsets, _this2._config.offset(data.offsets, _this2._element));\n          return data;\n        };\n      } else {\n        offset.offset = this._config.offset;\n      }\n      return offset;\n    };\n    _proto._getPopperConfig = function _getPopperConfig() {\n      var popperConfig = {\n        placement: this._getPlacement(),\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            enabled: this._config.flip\n          },\n          preventOverflow: {\n            boundariesElement: this._config.boundary\n          }\n        }\n      }; // Disable Popper if we have a static display\n\n      if (this._config.display === 'static') {\n        popperConfig.modifiers.applyStyle = {\n          enabled: false\n        };\n      }\n      return _extends$1({}, popperConfig, this._config.popperConfig);\n    } // Static\n    ;\n\n    Dropdown._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default[\"default\"](this).data(DATA_KEY$6);\n        var _config = _typeof(config) === 'object' ? config : null;\n        if (!data) {\n          data = new Dropdown(this, _config);\n          $__default[\"default\"](this).data(DATA_KEY$6, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    Dropdown._clearMenus = function _clearMenus(event) {\n      if (event && (event.which === RIGHT_MOUSE_BUTTON_WHICH || event.type === 'keyup' && event.which !== TAB_KEYCODE)) {\n        return;\n      }\n      var toggles = [].slice.call(document.querySelectorAll(SELECTOR_DATA_TOGGLE$2));\n      for (var i = 0, len = toggles.length; i < len; i++) {\n        var parent = Dropdown._getParentFromElement(toggles[i]);\n        var context = $__default[\"default\"](toggles[i]).data(DATA_KEY$6);\n        var relatedTarget = {\n          relatedTarget: toggles[i]\n        };\n        if (event && event.type === 'click') {\n          relatedTarget.clickEvent = event;\n        }\n        if (!context) {\n          continue;\n        }\n        var dropdownMenu = context._menu;\n        if (!$__default[\"default\"](parent).hasClass(CLASS_NAME_SHOW$5)) {\n          continue;\n        }\n        if (event && (event.type === 'click' && /input|textarea/i.test(event.target.tagName) || event.type === 'keyup' && event.which === TAB_KEYCODE) && $__default[\"default\"].contains(parent, event.target)) {\n          continue;\n        }\n        var hideEvent = $__default[\"default\"].Event(EVENT_HIDE$3, relatedTarget);\n        $__default[\"default\"](parent).trigger(hideEvent);\n        if (hideEvent.isDefaultPrevented()) {\n          continue;\n        } // If this is a touch-enabled device we remove the extra\n        // empty mouseover listeners we added for iOS support\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default[\"default\"](document.body).children().off('mouseover', null, $__default[\"default\"].noop);\n        }\n        toggles[i].setAttribute('aria-expanded', 'false');\n        if (context._popper) {\n          context._popper.destroy();\n        }\n        $__default[\"default\"](dropdownMenu).removeClass(CLASS_NAME_SHOW$5);\n        $__default[\"default\"](parent).removeClass(CLASS_NAME_SHOW$5).trigger($__default[\"default\"].Event(EVENT_HIDDEN$3, relatedTarget));\n      }\n    };\n    Dropdown._getParentFromElement = function _getParentFromElement(element) {\n      var parent;\n      var selector = Util.getSelectorFromElement(element);\n      if (selector) {\n        parent = document.querySelector(selector);\n      }\n      return parent || element.parentNode;\n    } // eslint-disable-next-line complexity\n    ;\n\n    Dropdown._dataApiKeydownHandler = function _dataApiKeydownHandler(event) {\n      // If not input/textarea:\n      //  - And not a key in REGEXP_KEYDOWN => not a dropdown command\n      // If input/textarea:\n      //  - If space key => not a dropdown command\n      //  - If key is other than escape\n      //    - If key is not up or down => not a dropdown command\n      //    - If trigger inside the menu => not a dropdown command\n      if (/input|textarea/i.test(event.target.tagName) ? event.which === SPACE_KEYCODE || event.which !== ESCAPE_KEYCODE$1 && (event.which !== ARROW_DOWN_KEYCODE && event.which !== ARROW_UP_KEYCODE || $__default[\"default\"](event.target).closest(SELECTOR_MENU).length) : !REGEXP_KEYDOWN.test(event.which)) {\n        return;\n      }\n      if (this.disabled || $__default[\"default\"](this).hasClass(CLASS_NAME_DISABLED$1)) {\n        return;\n      }\n      var parent = Dropdown._getParentFromElement(this);\n      var isActive = $__default[\"default\"](parent).hasClass(CLASS_NAME_SHOW$5);\n      if (!isActive && event.which === ESCAPE_KEYCODE$1) {\n        return;\n      }\n      event.preventDefault();\n      event.stopPropagation();\n      if (!isActive || event.which === ESCAPE_KEYCODE$1 || event.which === SPACE_KEYCODE) {\n        if (event.which === ESCAPE_KEYCODE$1) {\n          $__default[\"default\"](parent.querySelector(SELECTOR_DATA_TOGGLE$2)).trigger('focus');\n        }\n        $__default[\"default\"](this).trigger('click');\n        return;\n      }\n      var items = [].slice.call(parent.querySelectorAll(SELECTOR_VISIBLE_ITEMS)).filter(function (item) {\n        return $__default[\"default\"](item).is(':visible');\n      });\n      if (items.length === 0) {\n        return;\n      }\n      var index = items.indexOf(event.target);\n      if (event.which === ARROW_UP_KEYCODE && index > 0) {\n        // Up\n        index--;\n      }\n      if (event.which === ARROW_DOWN_KEYCODE && index < items.length - 1) {\n        // Down\n        index++;\n      }\n      if (index < 0) {\n        index = 0;\n      }\n      items[index].focus();\n    };\n    _createClass(Dropdown, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$6;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$5;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$5;\n      }\n    }]);\n    return Dropdown;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$2, Dropdown._dataApiKeydownHandler).on(EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown._dataApiKeydownHandler).on(EVENT_CLICK_DATA_API$2 + \" \" + EVENT_KEYUP_DATA_API, Dropdown._clearMenus).on(EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\n    event.preventDefault();\n    event.stopPropagation();\n    Dropdown._jQueryInterface.call($__default[\"default\"](this), 'toggle');\n  }).on(EVENT_CLICK_DATA_API$2, SELECTOR_FORM_CHILD, function (e) {\n    e.stopPropagation();\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$6] = Dropdown._jQueryInterface;\n  $__default[\"default\"].fn[NAME$6].Constructor = Dropdown;\n  $__default[\"default\"].fn[NAME$6].noConflict = function () {\n    $__default[\"default\"].fn[NAME$6] = JQUERY_NO_CONFLICT$6;\n    return Dropdown._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$5 = 'modal';\n  var VERSION$5 = '4.6.1';\n  var DATA_KEY$5 = 'bs.modal';\n  var EVENT_KEY$5 = \".\" + DATA_KEY$5;\n  var DATA_API_KEY$2 = '.data-api';\n  var JQUERY_NO_CONFLICT$5 = $__default[\"default\"].fn[NAME$5];\n  var ESCAPE_KEYCODE = 27; // KeyboardEvent.which value for Escape (Esc) key\n\n  var CLASS_NAME_SCROLLABLE = 'modal-dialog-scrollable';\n  var CLASS_NAME_SCROLLBAR_MEASURER = 'modal-scrollbar-measure';\n  var CLASS_NAME_BACKDROP = 'modal-backdrop';\n  var CLASS_NAME_OPEN = 'modal-open';\n  var CLASS_NAME_FADE$4 = 'fade';\n  var CLASS_NAME_SHOW$4 = 'show';\n  var CLASS_NAME_STATIC = 'modal-static';\n  var EVENT_HIDE$2 = \"hide\" + EVENT_KEY$5;\n  var EVENT_HIDE_PREVENTED = \"hidePrevented\" + EVENT_KEY$5;\n  var EVENT_HIDDEN$2 = \"hidden\" + EVENT_KEY$5;\n  var EVENT_SHOW$2 = \"show\" + EVENT_KEY$5;\n  var EVENT_SHOWN$2 = \"shown\" + EVENT_KEY$5;\n  var EVENT_FOCUSIN = \"focusin\" + EVENT_KEY$5;\n  var EVENT_RESIZE = \"resize\" + EVENT_KEY$5;\n  var EVENT_CLICK_DISMISS$1 = \"click.dismiss\" + EVENT_KEY$5;\n  var EVENT_KEYDOWN_DISMISS = \"keydown.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEUP_DISMISS = \"mouseup.dismiss\" + EVENT_KEY$5;\n  var EVENT_MOUSEDOWN_DISMISS = \"mousedown.dismiss\" + EVENT_KEY$5;\n  var EVENT_CLICK_DATA_API$1 = \"click\" + EVENT_KEY$5 + DATA_API_KEY$2;\n  var SELECTOR_DIALOG = '.modal-dialog';\n  var SELECTOR_MODAL_BODY = '.modal-body';\n  var SELECTOR_DATA_TOGGLE$1 = '[data-toggle=\"modal\"]';\n  var SELECTOR_DATA_DISMISS$1 = '[data-dismiss=\"modal\"]';\n  var SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\n  var SELECTOR_STICKY_CONTENT = '.sticky-top';\n  var Default$4 = {\n    backdrop: true,\n    keyboard: true,\n    focus: true,\n    show: true\n  };\n  var DefaultType$4 = {\n    backdrop: '(boolean|string)',\n    keyboard: 'boolean',\n    focus: 'boolean',\n    show: 'boolean'\n  };\n  /**\n   * Class definition\n   */\n\n  var Modal = /*#__PURE__*/function () {\n    function Modal(element, config) {\n      this._config = this._getConfig(config);\n      this._element = element;\n      this._dialog = element.querySelector(SELECTOR_DIALOG);\n      this._backdrop = null;\n      this._isShown = false;\n      this._isBodyOverflowing = false;\n      this._ignoreBackdropClick = false;\n      this._isTransitioning = false;\n      this._scrollbarWidth = 0;\n    } // Getters\n\n    var _proto = Modal.prototype;\n\n    // Public\n    _proto.toggle = function toggle(relatedTarget) {\n      return this._isShown ? this.hide() : this.show(relatedTarget);\n    };\n    _proto.show = function show(relatedTarget) {\n      var _this = this;\n      if (this._isShown || this._isTransitioning) {\n        return;\n      }\n      var showEvent = $__default[\"default\"].Event(EVENT_SHOW$2, {\n        relatedTarget: relatedTarget\n      });\n      $__default[\"default\"](this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = true;\n      if ($__default[\"default\"](this._element).hasClass(CLASS_NAME_FADE$4)) {\n        this._isTransitioning = true;\n      }\n      this._checkScrollbar();\n      this._setScrollbar();\n      this._adjustDialog();\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      $__default[\"default\"](this._element).on(EVENT_CLICK_DISMISS$1, SELECTOR_DATA_DISMISS$1, function (event) {\n        return _this.hide(event);\n      });\n      $__default[\"default\"](this._dialog).on(EVENT_MOUSEDOWN_DISMISS, function () {\n        $__default[\"default\"](_this._element).one(EVENT_MOUSEUP_DISMISS, function (event) {\n          if ($__default[\"default\"](event.target).is(_this._element)) {\n            _this._ignoreBackdropClick = true;\n          }\n        });\n      });\n      this._showBackdrop(function () {\n        return _this._showElement(relatedTarget);\n      });\n    };\n    _proto.hide = function hide(event) {\n      var _this2 = this;\n      if (event) {\n        event.preventDefault();\n      }\n      if (!this._isShown || this._isTransitioning) {\n        return;\n      }\n      var hideEvent = $__default[\"default\"].Event(EVENT_HIDE$2);\n      $__default[\"default\"](this._element).trigger(hideEvent);\n      if (!this._isShown || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._isShown = false;\n      var transition = $__default[\"default\"](this._element).hasClass(CLASS_NAME_FADE$4);\n      if (transition) {\n        this._isTransitioning = true;\n      }\n      this._setEscapeEvent();\n      this._setResizeEvent();\n      $__default[\"default\"](document).off(EVENT_FOCUSIN);\n      $__default[\"default\"](this._element).removeClass(CLASS_NAME_SHOW$4);\n      $__default[\"default\"](this._element).off(EVENT_CLICK_DISMISS$1);\n      $__default[\"default\"](this._dialog).off(EVENT_MOUSEDOWN_DISMISS);\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default[\"default\"](this._element).one(Util.TRANSITION_END, function (event) {\n          return _this2._hideModal(event);\n        }).emulateTransitionEnd(transitionDuration);\n      } else {\n        this._hideModal();\n      }\n    };\n    _proto.dispose = function dispose() {\n      [window, this._element, this._dialog].forEach(function (htmlElement) {\n        return $__default[\"default\"](htmlElement).off(EVENT_KEY$5);\n      });\n      /**\n       * `document` has 2 events `EVENT_FOCUSIN` and `EVENT_CLICK_DATA_API`\n       * Do not move `document` in `htmlElements` array\n       * It will remove `EVENT_CLICK_DATA_API` event that should remain\n       */\n\n      $__default[\"default\"](document).off(EVENT_FOCUSIN);\n      $__default[\"default\"].removeData(this._element, DATA_KEY$5);\n      this._config = null;\n      this._element = null;\n      this._dialog = null;\n      this._backdrop = null;\n      this._isShown = null;\n      this._isBodyOverflowing = null;\n      this._ignoreBackdropClick = null;\n      this._isTransitioning = null;\n      this._scrollbarWidth = null;\n    };\n    _proto.handleUpdate = function handleUpdate() {\n      this._adjustDialog();\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, Default$4, config);\n      Util.typeCheckConfig(NAME$5, config, DefaultType$4);\n      return config;\n    };\n    _proto._triggerBackdropTransition = function _triggerBackdropTransition() {\n      var _this3 = this;\n      var hideEventPrevented = $__default[\"default\"].Event(EVENT_HIDE_PREVENTED);\n      $__default[\"default\"](this._element).trigger(hideEventPrevented);\n      if (hideEventPrevented.isDefaultPrevented()) {\n        return;\n      }\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!isModalOverflowing) {\n        this._element.style.overflowY = 'hidden';\n      }\n      this._element.classList.add(CLASS_NAME_STATIC);\n      var modalTransitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n      $__default[\"default\"](this._element).off(Util.TRANSITION_END);\n      $__default[\"default\"](this._element).one(Util.TRANSITION_END, function () {\n        _this3._element.classList.remove(CLASS_NAME_STATIC);\n        if (!isModalOverflowing) {\n          $__default[\"default\"](_this3._element).one(Util.TRANSITION_END, function () {\n            _this3._element.style.overflowY = '';\n          }).emulateTransitionEnd(_this3._element, modalTransitionDuration);\n        }\n      }).emulateTransitionEnd(modalTransitionDuration);\n      this._element.focus();\n    };\n    _proto._showElement = function _showElement(relatedTarget) {\n      var _this4 = this;\n      var transition = $__default[\"default\"](this._element).hasClass(CLASS_NAME_FADE$4);\n      var modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;\n      if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {\n        // Don't move modal's DOM position\n        document.body.appendChild(this._element);\n      }\n      this._element.style.display = 'block';\n      this._element.removeAttribute('aria-hidden');\n      this._element.setAttribute('aria-modal', true);\n      this._element.setAttribute('role', 'dialog');\n      if ($__default[\"default\"](this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {\n        modalBody.scrollTop = 0;\n      } else {\n        this._element.scrollTop = 0;\n      }\n      if (transition) {\n        Util.reflow(this._element);\n      }\n      $__default[\"default\"](this._element).addClass(CLASS_NAME_SHOW$4);\n      if (this._config.focus) {\n        this._enforceFocus();\n      }\n      var shownEvent = $__default[\"default\"].Event(EVENT_SHOWN$2, {\n        relatedTarget: relatedTarget\n      });\n      var transitionComplete = function transitionComplete() {\n        if (_this4._config.focus) {\n          _this4._element.focus();\n        }\n        _this4._isTransitioning = false;\n        $__default[\"default\"](_this4._element).trigger(shownEvent);\n      };\n      if (transition) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._dialog);\n        $__default[\"default\"](this._dialog).one(Util.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);\n      } else {\n        transitionComplete();\n      }\n    };\n    _proto._enforceFocus = function _enforceFocus() {\n      var _this5 = this;\n      $__default[\"default\"](document).off(EVENT_FOCUSIN) // Guard against infinite focus loop\n      .on(EVENT_FOCUSIN, function (event) {\n        if (document !== event.target && _this5._element !== event.target && $__default[\"default\"](_this5._element).has(event.target).length === 0) {\n          _this5._element.focus();\n        }\n      });\n    };\n    _proto._setEscapeEvent = function _setEscapeEvent() {\n      var _this6 = this;\n      if (this._isShown) {\n        $__default[\"default\"](this._element).on(EVENT_KEYDOWN_DISMISS, function (event) {\n          if (_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {\n            event.preventDefault();\n            _this6.hide();\n          } else if (!_this6._config.keyboard && event.which === ESCAPE_KEYCODE) {\n            _this6._triggerBackdropTransition();\n          }\n        });\n      } else if (!this._isShown) {\n        $__default[\"default\"](this._element).off(EVENT_KEYDOWN_DISMISS);\n      }\n    };\n    _proto._setResizeEvent = function _setResizeEvent() {\n      var _this7 = this;\n      if (this._isShown) {\n        $__default[\"default\"](window).on(EVENT_RESIZE, function (event) {\n          return _this7.handleUpdate(event);\n        });\n      } else {\n        $__default[\"default\"](window).off(EVENT_RESIZE);\n      }\n    };\n    _proto._hideModal = function _hideModal() {\n      var _this8 = this;\n      this._element.style.display = 'none';\n      this._element.setAttribute('aria-hidden', true);\n      this._element.removeAttribute('aria-modal');\n      this._element.removeAttribute('role');\n      this._isTransitioning = false;\n      this._showBackdrop(function () {\n        $__default[\"default\"](document.body).removeClass(CLASS_NAME_OPEN);\n        _this8._resetAdjustments();\n        _this8._resetScrollbar();\n        $__default[\"default\"](_this8._element).trigger(EVENT_HIDDEN$2);\n      });\n    };\n    _proto._removeBackdrop = function _removeBackdrop() {\n      if (this._backdrop) {\n        $__default[\"default\"](this._backdrop).remove();\n        this._backdrop = null;\n      }\n    };\n    _proto._showBackdrop = function _showBackdrop(callback) {\n      var _this9 = this;\n      var animate = $__default[\"default\"](this._element).hasClass(CLASS_NAME_FADE$4) ? CLASS_NAME_FADE$4 : '';\n      if (this._isShown && this._config.backdrop) {\n        this._backdrop = document.createElement('div');\n        this._backdrop.className = CLASS_NAME_BACKDROP;\n        if (animate) {\n          this._backdrop.classList.add(animate);\n        }\n        $__default[\"default\"](this._backdrop).appendTo(document.body);\n        $__default[\"default\"](this._element).on(EVENT_CLICK_DISMISS$1, function (event) {\n          if (_this9._ignoreBackdropClick) {\n            _this9._ignoreBackdropClick = false;\n            return;\n          }\n          if (event.target !== event.currentTarget) {\n            return;\n          }\n          if (_this9._config.backdrop === 'static') {\n            _this9._triggerBackdropTransition();\n          } else {\n            _this9.hide();\n          }\n        });\n        if (animate) {\n          Util.reflow(this._backdrop);\n        }\n        $__default[\"default\"](this._backdrop).addClass(CLASS_NAME_SHOW$4);\n        if (!callback) {\n          return;\n        }\n        if (!animate) {\n          callback();\n          return;\n        }\n        var backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n        $__default[\"default\"](this._backdrop).one(Util.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);\n      } else if (!this._isShown && this._backdrop) {\n        $__default[\"default\"](this._backdrop).removeClass(CLASS_NAME_SHOW$4);\n        var callbackRemove = function callbackRemove() {\n          _this9._removeBackdrop();\n          if (callback) {\n            callback();\n          }\n        };\n        if ($__default[\"default\"](this._element).hasClass(CLASS_NAME_FADE$4)) {\n          var _backdropTransitionDuration = Util.getTransitionDurationFromElement(this._backdrop);\n          $__default[\"default\"](this._backdrop).one(Util.TRANSITION_END, callbackRemove).emulateTransitionEnd(_backdropTransitionDuration);\n        } else {\n          callbackRemove();\n        }\n      } else if (callback) {\n        callback();\n      }\n    } // ----------------------------------------------------------------------\n    // the following methods are used to handle overflowing modals\n    // todo (fat): these should probably be refactored out of modal.js\n    // ----------------------------------------------------------------------\n    ;\n\n    _proto._adjustDialog = function _adjustDialog() {\n      var isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n      if (!this._isBodyOverflowing && isModalOverflowing) {\n        this._element.style.paddingLeft = this._scrollbarWidth + \"px\";\n      }\n      if (this._isBodyOverflowing && !isModalOverflowing) {\n        this._element.style.paddingRight = this._scrollbarWidth + \"px\";\n      }\n    };\n    _proto._resetAdjustments = function _resetAdjustments() {\n      this._element.style.paddingLeft = '';\n      this._element.style.paddingRight = '';\n    };\n    _proto._checkScrollbar = function _checkScrollbar() {\n      var rect = document.body.getBoundingClientRect();\n      this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;\n      this._scrollbarWidth = this._getScrollbarWidth();\n    };\n    _proto._setScrollbar = function _setScrollbar() {\n      var _this10 = this;\n      if (this._isBodyOverflowing) {\n        // Note: DOMNode.style.paddingRight returns the actual value or '' if not set\n        //   while $(DOMNode).css('padding-right') returns the calculated value or 0 if not set\n        var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n        var stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT)); // Adjust fixed content padding\n\n        $__default[\"default\"](fixedContent).each(function (index, element) {\n          var actualPadding = element.style.paddingRight;\n          var calculatedPadding = $__default[\"default\"](element).css('padding-right');\n          $__default[\"default\"](element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + _this10._scrollbarWidth + \"px\");\n        }); // Adjust sticky content margin\n\n        $__default[\"default\"](stickyContent).each(function (index, element) {\n          var actualMargin = element.style.marginRight;\n          var calculatedMargin = $__default[\"default\"](element).css('margin-right');\n          $__default[\"default\"](element).data('margin-right', actualMargin).css('margin-right', parseFloat(calculatedMargin) - _this10._scrollbarWidth + \"px\");\n        }); // Adjust body padding\n\n        var actualPadding = document.body.style.paddingRight;\n        var calculatedPadding = $__default[\"default\"](document.body).css('padding-right');\n        $__default[\"default\"](document.body).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + this._scrollbarWidth + \"px\");\n      }\n      $__default[\"default\"](document.body).addClass(CLASS_NAME_OPEN);\n    };\n    _proto._resetScrollbar = function _resetScrollbar() {\n      // Restore fixed content padding\n      var fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));\n      $__default[\"default\"](fixedContent).each(function (index, element) {\n        var padding = $__default[\"default\"](element).data('padding-right');\n        $__default[\"default\"](element).removeData('padding-right');\n        element.style.paddingRight = padding ? padding : '';\n      }); // Restore sticky content\n\n      var elements = [].slice.call(document.querySelectorAll(\"\" + SELECTOR_STICKY_CONTENT));\n      $__default[\"default\"](elements).each(function (index, element) {\n        var margin = $__default[\"default\"](element).data('margin-right');\n        if (typeof margin !== 'undefined') {\n          $__default[\"default\"](element).css('margin-right', margin).removeData('margin-right');\n        }\n      }); // Restore body padding\n\n      var padding = $__default[\"default\"](document.body).data('padding-right');\n      $__default[\"default\"](document.body).removeData('padding-right');\n      document.body.style.paddingRight = padding ? padding : '';\n    };\n    _proto._getScrollbarWidth = function _getScrollbarWidth() {\n      // thx d.walsh\n      var scrollDiv = document.createElement('div');\n      scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;\n      document.body.appendChild(scrollDiv);\n      var scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;\n      document.body.removeChild(scrollDiv);\n      return scrollbarWidth;\n    } // Static\n    ;\n\n    Modal._jQueryInterface = function _jQueryInterface(config, relatedTarget) {\n      return this.each(function () {\n        var data = $__default[\"default\"](this).data(DATA_KEY$5);\n        var _config = _extends$1({}, Default$4, $__default[\"default\"](this).data(), _typeof(config) === 'object' && config ? config : {});\n        if (!data) {\n          data = new Modal(this, _config);\n          $__default[\"default\"](this).data(DATA_KEY$5, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config](relatedTarget);\n        } else if (_config.show) {\n          data.show(relatedTarget);\n        }\n      });\n    };\n    _createClass(Modal, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$5;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$4;\n      }\n    }]);\n    return Modal;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\n    var _this11 = this;\n    var target;\n    var selector = Util.getSelectorFromElement(this);\n    if (selector) {\n      target = document.querySelector(selector);\n    }\n    var config = $__default[\"default\"](target).data(DATA_KEY$5) ? 'toggle' : _extends$1({}, $__default[\"default\"](target).data(), $__default[\"default\"](this).data());\n    if (this.tagName === 'A' || this.tagName === 'AREA') {\n      event.preventDefault();\n    }\n    var $target = $__default[\"default\"](target).one(EVENT_SHOW$2, function (showEvent) {\n      if (showEvent.isDefaultPrevented()) {\n        // Only register focus restorer if modal will actually get shown\n        return;\n      }\n      $target.one(EVENT_HIDDEN$2, function () {\n        if ($__default[\"default\"](_this11).is(':visible')) {\n          _this11.focus();\n        }\n      });\n    });\n    Modal._jQueryInterface.call($__default[\"default\"](target), config, this);\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$5] = Modal._jQueryInterface;\n  $__default[\"default\"].fn[NAME$5].Constructor = Modal;\n  $__default[\"default\"].fn[NAME$5].noConflict = function () {\n    $__default[\"default\"].fn[NAME$5] = JQUERY_NO_CONFLICT$5;\n    return Modal._jQueryInterface;\n  };\n\n  /**\n   * --------------------------------------------------------------------------\n   * Bootstrap (v4.6.1): tools/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */\n  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];\n  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n  var DefaultWhitelist = {\n    // Global attributes allowed on any supplied element below.\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\n    a: ['target', 'href', 'title', 'rel'],\n    area: [],\n    b: [],\n    br: [],\n    col: [],\n    code: [],\n    div: [],\n    em: [],\n    hr: [],\n    h1: [],\n    h2: [],\n    h3: [],\n    h4: [],\n    h5: [],\n    h6: [],\n    i: [],\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\n    li: [],\n    ol: [],\n    p: [],\n    pre: [],\n    s: [],\n    small: [],\n    span: [],\n    sub: [],\n    sup: [],\n    strong: [],\n    u: [],\n    ul: []\n  };\n  /**\n   * A pattern that recognizes a commonly useful subset of URLs that are safe.\n   *\n   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i;\n  /**\n   * A pattern that matches safe data URLs. Only matches image, video and audio types.\n   *\n   * Shoutout to Angular https://github.com/angular/angular/blob/12.2.x/packages/core/src/sanitization/url_sanitizer.ts\n   */\n\n  var DATA_URL_PATTERN = /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[\\d+/a-z]+=*$/i;\n  function allowedAttribute(attr, allowedAttributeList) {\n    var attrName = attr.nodeName.toLowerCase();\n    if (allowedAttributeList.indexOf(attrName) !== -1) {\n      if (uriAttrs.indexOf(attrName) !== -1) {\n        return Boolean(SAFE_URL_PATTERN.test(attr.nodeValue) || DATA_URL_PATTERN.test(attr.nodeValue));\n      }\n      return true;\n    }\n    var regExp = allowedAttributeList.filter(function (attrRegex) {\n      return attrRegex instanceof RegExp;\n    }); // Check if a regular expression validates the attribute.\n\n    for (var i = 0, len = regExp.length; i < len; i++) {\n      if (regExp[i].test(attrName)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {\n    if (unsafeHtml.length === 0) {\n      return unsafeHtml;\n    }\n    if (sanitizeFn && typeof sanitizeFn === 'function') {\n      return sanitizeFn(unsafeHtml);\n    }\n    var domParser = new window.DOMParser();\n    var createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\n    var whitelistKeys = Object.keys(whiteList);\n    var elements = [].slice.call(createdDocument.body.querySelectorAll('*'));\n    var _loop = function _loop(i, len) {\n      var el = elements[i];\n      var elName = el.nodeName.toLowerCase();\n      if (whitelistKeys.indexOf(el.nodeName.toLowerCase()) === -1) {\n        el.parentNode.removeChild(el);\n        return \"continue\";\n      }\n      var attributeList = [].slice.call(el.attributes); // eslint-disable-next-line unicorn/prefer-spread\n\n      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);\n      attributeList.forEach(function (attr) {\n        if (!allowedAttribute(attr, whitelistedAttributes)) {\n          el.removeAttribute(attr.nodeName);\n        }\n      });\n    };\n    for (var i = 0, len = elements.length; i < len; i++) {\n      var _ret = _loop(i);\n      if (_ret === \"continue\") continue;\n    }\n    return createdDocument.body.innerHTML;\n  }\n\n  /**\n   * Constants\n   */\n\n  var NAME$4 = 'tooltip';\n  var VERSION$4 = '4.6.1';\n  var DATA_KEY$4 = 'bs.tooltip';\n  var EVENT_KEY$4 = \".\" + DATA_KEY$4;\n  var JQUERY_NO_CONFLICT$4 = $__default[\"default\"].fn[NAME$4];\n  var CLASS_PREFIX$1 = 'bs-tooltip';\n  var BSCLS_PREFIX_REGEX$1 = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX$1 + \"\\\\S+\", 'g');\n  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];\n  var CLASS_NAME_FADE$3 = 'fade';\n  var CLASS_NAME_SHOW$3 = 'show';\n  var HOVER_STATE_SHOW = 'show';\n  var HOVER_STATE_OUT = 'out';\n  var SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\n  var SELECTOR_ARROW = '.arrow';\n  var TRIGGER_HOVER = 'hover';\n  var TRIGGER_FOCUS = 'focus';\n  var TRIGGER_CLICK = 'click';\n  var TRIGGER_MANUAL = 'manual';\n  var AttachmentMap = {\n    AUTO: 'auto',\n    TOP: 'top',\n    RIGHT: 'right',\n    BOTTOM: 'bottom',\n    LEFT: 'left'\n  };\n  var Default$3 = {\n    animation: true,\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<div class=\"tooltip-inner\"></div></div>',\n    trigger: 'hover focus',\n    title: '',\n    delay: 0,\n    html: false,\n    selector: false,\n    placement: 'top',\n    offset: 0,\n    container: false,\n    fallbackPlacement: 'flip',\n    boundary: 'scrollParent',\n    customClass: '',\n    sanitize: true,\n    sanitizeFn: null,\n    whiteList: DefaultWhitelist,\n    popperConfig: null\n  };\n  var DefaultType$3 = {\n    animation: 'boolean',\n    template: 'string',\n    title: '(string|element|function)',\n    trigger: 'string',\n    delay: '(number|object)',\n    html: 'boolean',\n    selector: '(string|boolean)',\n    placement: '(string|function)',\n    offset: '(number|string|function)',\n    container: '(string|element|boolean)',\n    fallbackPlacement: '(string|array)',\n    boundary: '(string|element)',\n    customClass: '(string|function)',\n    sanitize: 'boolean',\n    sanitizeFn: '(null|function)',\n    whiteList: 'object',\n    popperConfig: '(null|object)'\n  };\n  var Event$1 = {\n    HIDE: \"hide\" + EVENT_KEY$4,\n    HIDDEN: \"hidden\" + EVENT_KEY$4,\n    SHOW: \"show\" + EVENT_KEY$4,\n    SHOWN: \"shown\" + EVENT_KEY$4,\n    INSERTED: \"inserted\" + EVENT_KEY$4,\n    CLICK: \"click\" + EVENT_KEY$4,\n    FOCUSIN: \"focusin\" + EVENT_KEY$4,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$4,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$4,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$4\n  };\n  /**\n   * Class definition\n   */\n\n  var Tooltip = /*#__PURE__*/function () {\n    function Tooltip(element, config) {\n      if (typeof Popper$1 === 'undefined') {\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org)');\n      } // Private\n\n      this._isEnabled = true;\n      this._timeout = 0;\n      this._hoverState = '';\n      this._activeTrigger = {};\n      this._popper = null; // Protected\n\n      this.element = element;\n      this.config = this._getConfig(config);\n      this.tip = null;\n      this._setListeners();\n    } // Getters\n\n    var _proto = Tooltip.prototype;\n\n    // Public\n    _proto.enable = function enable() {\n      this._isEnabled = true;\n    };\n    _proto.disable = function disable() {\n      this._isEnabled = false;\n    };\n    _proto.toggleEnabled = function toggleEnabled() {\n      this._isEnabled = !this._isEnabled;\n    };\n    _proto.toggle = function toggle(event) {\n      if (!this._isEnabled) {\n        return;\n      }\n      if (event) {\n        var dataKey = this.constructor.DATA_KEY;\n        var context = $__default[\"default\"](event.currentTarget).data(dataKey);\n        if (!context) {\n          context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n          $__default[\"default\"](event.currentTarget).data(dataKey, context);\n        }\n        context._activeTrigger.click = !context._activeTrigger.click;\n        if (context._isWithActiveTrigger()) {\n          context._enter(null, context);\n        } else {\n          context._leave(null, context);\n        }\n      } else {\n        if ($__default[\"default\"](this.getTipElement()).hasClass(CLASS_NAME_SHOW$3)) {\n          this._leave(null, this);\n          return;\n        }\n        this._enter(null, this);\n      }\n    };\n    _proto.dispose = function dispose() {\n      clearTimeout(this._timeout);\n      $__default[\"default\"].removeData(this.element, this.constructor.DATA_KEY);\n      $__default[\"default\"](this.element).off(this.constructor.EVENT_KEY);\n      $__default[\"default\"](this.element).closest('.modal').off('hide.bs.modal', this._hideModalHandler);\n      if (this.tip) {\n        $__default[\"default\"](this.tip).remove();\n      }\n      this._isEnabled = null;\n      this._timeout = null;\n      this._hoverState = null;\n      this._activeTrigger = null;\n      if (this._popper) {\n        this._popper.destroy();\n      }\n      this._popper = null;\n      this.element = null;\n      this.config = null;\n      this.tip = null;\n    };\n    _proto.show = function show() {\n      var _this = this;\n      if ($__default[\"default\"](this.element).css('display') === 'none') {\n        throw new Error('Please use show on visible elements');\n      }\n      var showEvent = $__default[\"default\"].Event(this.constructor.Event.SHOW);\n      if (this.isWithContent() && this._isEnabled) {\n        $__default[\"default\"](this.element).trigger(showEvent);\n        var shadowRoot = Util.findShadowRoot(this.element);\n        var isInTheDom = $__default[\"default\"].contains(shadowRoot !== null ? shadowRoot : this.element.ownerDocument.documentElement, this.element);\n        if (showEvent.isDefaultPrevented() || !isInTheDom) {\n          return;\n        }\n        var tip = this.getTipElement();\n        var tipId = Util.getUID(this.constructor.NAME);\n        tip.setAttribute('id', tipId);\n        this.element.setAttribute('aria-describedby', tipId);\n        this.setContent();\n        if (this.config.animation) {\n          $__default[\"default\"](tip).addClass(CLASS_NAME_FADE$3);\n        }\n        var placement = typeof this.config.placement === 'function' ? this.config.placement.call(this, tip, this.element) : this.config.placement;\n        var attachment = this._getAttachment(placement);\n        this.addAttachmentClass(attachment);\n        var container = this._getContainer();\n        $__default[\"default\"](tip).data(this.constructor.DATA_KEY, this);\n        if (!$__default[\"default\"].contains(this.element.ownerDocument.documentElement, this.tip)) {\n          $__default[\"default\"](tip).appendTo(container);\n        }\n        $__default[\"default\"](this.element).trigger(this.constructor.Event.INSERTED);\n        this._popper = new Popper$1(this.element, tip, this._getPopperConfig(attachment));\n        $__default[\"default\"](tip).addClass(CLASS_NAME_SHOW$3);\n        $__default[\"default\"](tip).addClass(this.config.customClass); // If this is a touch-enabled device we add extra\n        // empty mouseover listeners to the body's immediate children;\n        // only needed because of broken event delegation on iOS\n        // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n\n        if ('ontouchstart' in document.documentElement) {\n          $__default[\"default\"](document.body).children().on('mouseover', null, $__default[\"default\"].noop);\n        }\n        var complete = function complete() {\n          if (_this.config.animation) {\n            _this._fixTransition();\n          }\n          var prevHoverState = _this._hoverState;\n          _this._hoverState = null;\n          $__default[\"default\"](_this.element).trigger(_this.constructor.Event.SHOWN);\n          if (prevHoverState === HOVER_STATE_OUT) {\n            _this._leave(null, _this);\n          }\n        };\n        if ($__default[\"default\"](this.tip).hasClass(CLASS_NAME_FADE$3)) {\n          var transitionDuration = Util.getTransitionDurationFromElement(this.tip);\n          $__default[\"default\"](this.tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n        } else {\n          complete();\n        }\n      }\n    };\n    _proto.hide = function hide(callback) {\n      var _this2 = this;\n      var tip = this.getTipElement();\n      var hideEvent = $__default[\"default\"].Event(this.constructor.Event.HIDE);\n      var complete = function complete() {\n        if (_this2._hoverState !== HOVER_STATE_SHOW && tip.parentNode) {\n          tip.parentNode.removeChild(tip);\n        }\n        _this2._cleanTipClass();\n        _this2.element.removeAttribute('aria-describedby');\n        $__default[\"default\"](_this2.element).trigger(_this2.constructor.Event.HIDDEN);\n        if (_this2._popper !== null) {\n          _this2._popper.destroy();\n        }\n        if (callback) {\n          callback();\n        }\n      };\n      $__default[\"default\"](this.element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      $__default[\"default\"](tip).removeClass(CLASS_NAME_SHOW$3); // If this is a touch-enabled device we remove the extra\n      // empty mouseover listeners we added for iOS support\n\n      if ('ontouchstart' in document.documentElement) {\n        $__default[\"default\"](document.body).children().off('mouseover', null, $__default[\"default\"].noop);\n      }\n      this._activeTrigger[TRIGGER_CLICK] = false;\n      this._activeTrigger[TRIGGER_FOCUS] = false;\n      this._activeTrigger[TRIGGER_HOVER] = false;\n      if ($__default[\"default\"](this.tip).hasClass(CLASS_NAME_FADE$3)) {\n        var transitionDuration = Util.getTransitionDurationFromElement(tip);\n        $__default[\"default\"](tip).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n      this._hoverState = '';\n    };\n    _proto.update = function update() {\n      if (this._popper !== null) {\n        this._popper.scheduleUpdate();\n      }\n    } // Protected\n    ;\n\n    _proto.isWithContent = function isWithContent() {\n      return Boolean(this.getTitle());\n    };\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default[\"default\"](this.getTipElement()).addClass(CLASS_PREFIX$1 + \"-\" + attachment);\n    };\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default[\"default\"](this.config.template)[0];\n      return this.tip;\n    };\n    _proto.setContent = function setContent() {\n      var tip = this.getTipElement();\n      this.setElementContent($__default[\"default\"](tip.querySelectorAll(SELECTOR_TOOLTIP_INNER)), this.getTitle());\n      $__default[\"default\"](tip).removeClass(CLASS_NAME_FADE$3 + \" \" + CLASS_NAME_SHOW$3);\n    };\n    _proto.setElementContent = function setElementContent($element, content) {\n      if (_typeof(content) === 'object' && (content.nodeType || content.jquery)) {\n        // Content is a DOM node or a jQuery\n        if (this.config.html) {\n          if (!$__default[\"default\"](content).parent().is($element)) {\n            $element.empty().append(content);\n          }\n        } else {\n          $element.text($__default[\"default\"](content).text());\n        }\n        return;\n      }\n      if (this.config.html) {\n        if (this.config.sanitize) {\n          content = sanitizeHtml(content, this.config.whiteList, this.config.sanitizeFn);\n        }\n        $element.html(content);\n      } else {\n        $element.text(content);\n      }\n    };\n    _proto.getTitle = function getTitle() {\n      var title = this.element.getAttribute('data-original-title');\n      if (!title) {\n        title = typeof this.config.title === 'function' ? this.config.title.call(this.element) : this.config.title;\n      }\n      return title;\n    } // Private\n    ;\n\n    _proto._getPopperConfig = function _getPopperConfig(attachment) {\n      var _this3 = this;\n      var defaultBsConfig = {\n        placement: attachment,\n        modifiers: {\n          offset: this._getOffset(),\n          flip: {\n            behavior: this.config.fallbackPlacement\n          },\n          arrow: {\n            element: SELECTOR_ARROW\n          },\n          preventOverflow: {\n            boundariesElement: this.config.boundary\n          }\n        },\n        onCreate: function onCreate(data) {\n          if (data.originalPlacement !== data.placement) {\n            _this3._handlePopperPlacementChange(data);\n          }\n        },\n        onUpdate: function onUpdate(data) {\n          return _this3._handlePopperPlacementChange(data);\n        }\n      };\n      return _extends$1({}, defaultBsConfig, this.config.popperConfig);\n    };\n    _proto._getOffset = function _getOffset() {\n      var _this4 = this;\n      var offset = {};\n      if (typeof this.config.offset === 'function') {\n        offset.fn = function (data) {\n          data.offsets = _extends$1({}, data.offsets, _this4.config.offset(data.offsets, _this4.element));\n          return data;\n        };\n      } else {\n        offset.offset = this.config.offset;\n      }\n      return offset;\n    };\n    _proto._getContainer = function _getContainer() {\n      if (this.config.container === false) {\n        return document.body;\n      }\n      if (Util.isElement(this.config.container)) {\n        return $__default[\"default\"](this.config.container);\n      }\n      return $__default[\"default\"](document).find(this.config.container);\n    };\n    _proto._getAttachment = function _getAttachment(placement) {\n      return AttachmentMap[placement.toUpperCase()];\n    };\n    _proto._setListeners = function _setListeners() {\n      var _this5 = this;\n      var triggers = this.config.trigger.split(' ');\n      triggers.forEach(function (trigger) {\n        if (trigger === 'click') {\n          $__default[\"default\"](_this5.element).on(_this5.constructor.Event.CLICK, _this5.config.selector, function (event) {\n            return _this5.toggle(event);\n          });\n        } else if (trigger !== TRIGGER_MANUAL) {\n          var eventIn = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSEENTER : _this5.constructor.Event.FOCUSIN;\n          var eventOut = trigger === TRIGGER_HOVER ? _this5.constructor.Event.MOUSELEAVE : _this5.constructor.Event.FOCUSOUT;\n          $__default[\"default\"](_this5.element).on(eventIn, _this5.config.selector, function (event) {\n            return _this5._enter(event);\n          }).on(eventOut, _this5.config.selector, function (event) {\n            return _this5._leave(event);\n          });\n        }\n      });\n      this._hideModalHandler = function () {\n        if (_this5.element) {\n          _this5.hide();\n        }\n      };\n      $__default[\"default\"](this.element).closest('.modal').on('hide.bs.modal', this._hideModalHandler);\n      if (this.config.selector) {\n        this.config = _extends$1({}, this.config, {\n          trigger: 'manual',\n          selector: ''\n        });\n      } else {\n        this._fixTitle();\n      }\n    };\n    _proto._fixTitle = function _fixTitle() {\n      var titleType = _typeof(this.element.getAttribute('data-original-title'));\n      if (this.element.getAttribute('title') || titleType !== 'string') {\n        this.element.setAttribute('data-original-title', this.element.getAttribute('title') || '');\n        this.element.setAttribute('title', '');\n      }\n    };\n    _proto._enter = function _enter(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default[\"default\"](event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default[\"default\"](event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n      }\n      if ($__default[\"default\"](context.getTipElement()).hasClass(CLASS_NAME_SHOW$3) || context._hoverState === HOVER_STATE_SHOW) {\n        context._hoverState = HOVER_STATE_SHOW;\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_SHOW;\n      if (!context.config.delay || !context.config.delay.show) {\n        context.show();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_SHOW) {\n          context.show();\n        }\n      }, context.config.delay.show);\n    };\n    _proto._leave = function _leave(event, context) {\n      var dataKey = this.constructor.DATA_KEY;\n      context = context || $__default[\"default\"](event.currentTarget).data(dataKey);\n      if (!context) {\n        context = new this.constructor(event.currentTarget, this._getDelegateConfig());\n        $__default[\"default\"](event.currentTarget).data(dataKey, context);\n      }\n      if (event) {\n        context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = false;\n      }\n      if (context._isWithActiveTrigger()) {\n        return;\n      }\n      clearTimeout(context._timeout);\n      context._hoverState = HOVER_STATE_OUT;\n      if (!context.config.delay || !context.config.delay.hide) {\n        context.hide();\n        return;\n      }\n      context._timeout = setTimeout(function () {\n        if (context._hoverState === HOVER_STATE_OUT) {\n          context.hide();\n        }\n      }, context.config.delay.hide);\n    };\n    _proto._isWithActiveTrigger = function _isWithActiveTrigger() {\n      for (var trigger in this._activeTrigger) {\n        if (this._activeTrigger[trigger]) {\n          return true;\n        }\n      }\n      return false;\n    };\n    _proto._getConfig = function _getConfig(config) {\n      var dataAttributes = $__default[\"default\"](this.element).data();\n      Object.keys(dataAttributes).forEach(function (dataAttr) {\n        if (DISALLOWED_ATTRIBUTES.indexOf(dataAttr) !== -1) {\n          delete dataAttributes[dataAttr];\n        }\n      });\n      config = _extends$1({}, this.constructor.Default, dataAttributes, _typeof(config) === 'object' && config ? config : {});\n      if (typeof config.delay === 'number') {\n        config.delay = {\n          show: config.delay,\n          hide: config.delay\n        };\n      }\n      if (typeof config.title === 'number') {\n        config.title = config.title.toString();\n      }\n      if (typeof config.content === 'number') {\n        config.content = config.content.toString();\n      }\n      Util.typeCheckConfig(NAME$4, config, this.constructor.DefaultType);\n      if (config.sanitize) {\n        config.template = sanitizeHtml(config.template, config.whiteList, config.sanitizeFn);\n      }\n      return config;\n    };\n    _proto._getDelegateConfig = function _getDelegateConfig() {\n      var config = {};\n      if (this.config) {\n        for (var key in this.config) {\n          if (this.constructor.Default[key] !== this.config[key]) {\n            config[key] = this.config[key];\n          }\n        }\n      }\n      return config;\n    };\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default[\"default\"](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX$1);\n      if (tabClass !== null && tabClass.length) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    };\n    _proto._handlePopperPlacementChange = function _handlePopperPlacementChange(popperData) {\n      this.tip = popperData.instance.popper;\n      this._cleanTipClass();\n      this.addAttachmentClass(this._getAttachment(popperData.placement));\n    };\n    _proto._fixTransition = function _fixTransition() {\n      var tip = this.getTipElement();\n      var initConfigAnimation = this.config.animation;\n      if (tip.getAttribute('x-placement') !== null) {\n        return;\n      }\n      $__default[\"default\"](tip).removeClass(CLASS_NAME_FADE$3);\n      this.config.animation = false;\n      this.hide();\n      this.show();\n      this.config.animation = initConfigAnimation;\n    } // Static\n    ;\n\n    Tooltip._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default[\"default\"](this);\n        var data = $element.data(DATA_KEY$4);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Tooltip(this, _config);\n          $element.data(DATA_KEY$4, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Tooltip, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$4;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$3;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$4;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$4;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event$1;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$4;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$3;\n      }\n    }]);\n    return Tooltip;\n  }();\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$4] = Tooltip._jQueryInterface;\n  $__default[\"default\"].fn[NAME$4].Constructor = Tooltip;\n  $__default[\"default\"].fn[NAME$4].noConflict = function () {\n    $__default[\"default\"].fn[NAME$4] = JQUERY_NO_CONFLICT$4;\n    return Tooltip._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$3 = 'popover';\n  var VERSION$3 = '4.6.1';\n  var DATA_KEY$3 = 'bs.popover';\n  var EVENT_KEY$3 = \".\" + DATA_KEY$3;\n  var JQUERY_NO_CONFLICT$3 = $__default[\"default\"].fn[NAME$3];\n  var CLASS_PREFIX = 'bs-popover';\n  var BSCLS_PREFIX_REGEX = new RegExp(\"(^|\\\\s)\" + CLASS_PREFIX + \"\\\\S+\", 'g');\n  var CLASS_NAME_FADE$2 = 'fade';\n  var CLASS_NAME_SHOW$2 = 'show';\n  var SELECTOR_TITLE = '.popover-header';\n  var SELECTOR_CONTENT = '.popover-body';\n  var Default$2 = _extends$1({}, Tooltip.Default, {\n    placement: 'right',\n    trigger: 'click',\n    content: '',\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div></div>'\n  });\n  var DefaultType$2 = _extends$1({}, Tooltip.DefaultType, {\n    content: '(string|element|function)'\n  });\n  var Event = {\n    HIDE: \"hide\" + EVENT_KEY$3,\n    HIDDEN: \"hidden\" + EVENT_KEY$3,\n    SHOW: \"show\" + EVENT_KEY$3,\n    SHOWN: \"shown\" + EVENT_KEY$3,\n    INSERTED: \"inserted\" + EVENT_KEY$3,\n    CLICK: \"click\" + EVENT_KEY$3,\n    FOCUSIN: \"focusin\" + EVENT_KEY$3,\n    FOCUSOUT: \"focusout\" + EVENT_KEY$3,\n    MOUSEENTER: \"mouseenter\" + EVENT_KEY$3,\n    MOUSELEAVE: \"mouseleave\" + EVENT_KEY$3\n  };\n  /**\n   * Class definition\n   */\n\n  var Popover = /*#__PURE__*/function (_Tooltip) {\n    _inheritsLoose(Popover, _Tooltip);\n    function Popover() {\n      return _Tooltip.apply(this, arguments) || this;\n    }\n    var _proto = Popover.prototype;\n\n    // Overrides\n    _proto.isWithContent = function isWithContent() {\n      return this.getTitle() || this._getContent();\n    };\n    _proto.addAttachmentClass = function addAttachmentClass(attachment) {\n      $__default[\"default\"](this.getTipElement()).addClass(CLASS_PREFIX + \"-\" + attachment);\n    };\n    _proto.getTipElement = function getTipElement() {\n      this.tip = this.tip || $__default[\"default\"](this.config.template)[0];\n      return this.tip;\n    };\n    _proto.setContent = function setContent() {\n      var $tip = $__default[\"default\"](this.getTipElement()); // We use append for html objects to maintain js events\n\n      this.setElementContent($tip.find(SELECTOR_TITLE), this.getTitle());\n      var content = this._getContent();\n      if (typeof content === 'function') {\n        content = content.call(this.element);\n      }\n      this.setElementContent($tip.find(SELECTOR_CONTENT), content);\n      $tip.removeClass(CLASS_NAME_FADE$2 + \" \" + CLASS_NAME_SHOW$2);\n    } // Private\n    ;\n\n    _proto._getContent = function _getContent() {\n      return this.element.getAttribute('data-content') || this.config.content;\n    };\n    _proto._cleanTipClass = function _cleanTipClass() {\n      var $tip = $__default[\"default\"](this.getTipElement());\n      var tabClass = $tip.attr('class').match(BSCLS_PREFIX_REGEX);\n      if (tabClass !== null && tabClass.length > 0) {\n        $tip.removeClass(tabClass.join(''));\n      }\n    } // Static\n    ;\n\n    Popover._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default[\"default\"](this).data(DATA_KEY$3);\n        var _config = _typeof(config) === 'object' ? config : null;\n        if (!data && /dispose|hide/.test(config)) {\n          return;\n        }\n        if (!data) {\n          data = new Popover(this, _config);\n          $__default[\"default\"](this).data(DATA_KEY$3, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Popover, null, [{\n      key: \"VERSION\",\n      get:\n      // Getters\n      function get() {\n        return VERSION$3;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$2;\n      }\n    }, {\n      key: \"NAME\",\n      get: function get() {\n        return NAME$3;\n      }\n    }, {\n      key: \"DATA_KEY\",\n      get: function get() {\n        return DATA_KEY$3;\n      }\n    }, {\n      key: \"Event\",\n      get: function get() {\n        return Event;\n      }\n    }, {\n      key: \"EVENT_KEY\",\n      get: function get() {\n        return EVENT_KEY$3;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType$2;\n      }\n    }]);\n    return Popover;\n  }(Tooltip);\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$3] = Popover._jQueryInterface;\n  $__default[\"default\"].fn[NAME$3].Constructor = Popover;\n  $__default[\"default\"].fn[NAME$3].noConflict = function () {\n    $__default[\"default\"].fn[NAME$3] = JQUERY_NO_CONFLICT$3;\n    return Popover._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$2 = 'scrollspy';\n  var VERSION$2 = '4.6.1';\n  var DATA_KEY$2 = 'bs.scrollspy';\n  var EVENT_KEY$2 = \".\" + DATA_KEY$2;\n  var DATA_API_KEY$1 = '.data-api';\n  var JQUERY_NO_CONFLICT$2 = $__default[\"default\"].fn[NAME$2];\n  var CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\n  var CLASS_NAME_ACTIVE$1 = 'active';\n  var EVENT_ACTIVATE = \"activate\" + EVENT_KEY$2;\n  var EVENT_SCROLL = \"scroll\" + EVENT_KEY$2;\n  var EVENT_LOAD_DATA_API = \"load\" + EVENT_KEY$2 + DATA_API_KEY$1;\n  var METHOD_OFFSET = 'offset';\n  var METHOD_POSITION = 'position';\n  var SELECTOR_DATA_SPY = '[data-spy=\"scroll\"]';\n  var SELECTOR_NAV_LIST_GROUP$1 = '.nav, .list-group';\n  var SELECTOR_NAV_LINKS = '.nav-link';\n  var SELECTOR_NAV_ITEMS = '.nav-item';\n  var SELECTOR_LIST_ITEMS = '.list-group-item';\n  var SELECTOR_DROPDOWN$1 = '.dropdown';\n  var SELECTOR_DROPDOWN_ITEMS = '.dropdown-item';\n  var SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\n  var Default$1 = {\n    offset: 10,\n    method: 'auto',\n    target: ''\n  };\n  var DefaultType$1 = {\n    offset: 'number',\n    method: 'string',\n    target: '(string|element)'\n  };\n  /**\n   * Class definition\n   */\n\n  var ScrollSpy = /*#__PURE__*/function () {\n    function ScrollSpy(element, config) {\n      var _this = this;\n      this._element = element;\n      this._scrollElement = element.tagName === 'BODY' ? window : element;\n      this._config = this._getConfig(config);\n      this._selector = this._config.target + \" \" + SELECTOR_NAV_LINKS + \",\" + (this._config.target + \" \" + SELECTOR_LIST_ITEMS + \",\") + (this._config.target + \" \" + SELECTOR_DROPDOWN_ITEMS);\n      this._offsets = [];\n      this._targets = [];\n      this._activeTarget = null;\n      this._scrollHeight = 0;\n      $__default[\"default\"](this._scrollElement).on(EVENT_SCROLL, function (event) {\n        return _this._process(event);\n      });\n      this.refresh();\n      this._process();\n    } // Getters\n\n    var _proto = ScrollSpy.prototype;\n\n    // Public\n    _proto.refresh = function refresh() {\n      var _this2 = this;\n      var autoMethod = this._scrollElement === this._scrollElement.window ? METHOD_OFFSET : METHOD_POSITION;\n      var offsetMethod = this._config.method === 'auto' ? autoMethod : this._config.method;\n      var offsetBase = offsetMethod === METHOD_POSITION ? this._getScrollTop() : 0;\n      this._offsets = [];\n      this._targets = [];\n      this._scrollHeight = this._getScrollHeight();\n      var targets = [].slice.call(document.querySelectorAll(this._selector));\n      targets.map(function (element) {\n        var target;\n        var targetSelector = Util.getSelectorFromElement(element);\n        if (targetSelector) {\n          target = document.querySelector(targetSelector);\n        }\n        if (target) {\n          var targetBCR = target.getBoundingClientRect();\n          if (targetBCR.width || targetBCR.height) {\n            // TODO (fat): remove sketch reliance on jQuery position/offset\n            return [$__default[\"default\"](target)[offsetMethod]().top + offsetBase, targetSelector];\n          }\n        }\n        return null;\n      }).filter(function (item) {\n        return item;\n      }).sort(function (a, b) {\n        return a[0] - b[0];\n      }).forEach(function (item) {\n        _this2._offsets.push(item[0]);\n        _this2._targets.push(item[1]);\n      });\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$2);\n      $__default[\"default\"](this._scrollElement).off(EVENT_KEY$2);\n      this._element = null;\n      this._scrollElement = null;\n      this._config = null;\n      this._selector = null;\n      this._offsets = null;\n      this._targets = null;\n      this._activeTarget = null;\n      this._scrollHeight = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, Default$1, _typeof(config) === 'object' && config ? config : {});\n      if (typeof config.target !== 'string' && Util.isElement(config.target)) {\n        var id = $__default[\"default\"](config.target).attr('id');\n        if (!id) {\n          id = Util.getUID(NAME$2);\n          $__default[\"default\"](config.target).attr('id', id);\n        }\n        config.target = \"#\" + id;\n      }\n      Util.typeCheckConfig(NAME$2, config, DefaultType$1);\n      return config;\n    };\n    _proto._getScrollTop = function _getScrollTop() {\n      return this._scrollElement === window ? this._scrollElement.pageYOffset : this._scrollElement.scrollTop;\n    };\n    _proto._getScrollHeight = function _getScrollHeight() {\n      return this._scrollElement.scrollHeight || Math.max(document.body.scrollHeight, document.documentElement.scrollHeight);\n    };\n    _proto._getOffsetHeight = function _getOffsetHeight() {\n      return this._scrollElement === window ? window.innerHeight : this._scrollElement.getBoundingClientRect().height;\n    };\n    _proto._process = function _process() {\n      var scrollTop = this._getScrollTop() + this._config.offset;\n      var scrollHeight = this._getScrollHeight();\n      var maxScroll = this._config.offset + scrollHeight - this._getOffsetHeight();\n      if (this._scrollHeight !== scrollHeight) {\n        this.refresh();\n      }\n      if (scrollTop >= maxScroll) {\n        var target = this._targets[this._targets.length - 1];\n        if (this._activeTarget !== target) {\n          this._activate(target);\n        }\n        return;\n      }\n      if (this._activeTarget && scrollTop < this._offsets[0] && this._offsets[0] > 0) {\n        this._activeTarget = null;\n        this._clear();\n        return;\n      }\n      for (var i = this._offsets.length; i--;) {\n        var isActiveTarget = this._activeTarget !== this._targets[i] && scrollTop >= this._offsets[i] && (typeof this._offsets[i + 1] === 'undefined' || scrollTop < this._offsets[i + 1]);\n        if (isActiveTarget) {\n          this._activate(this._targets[i]);\n        }\n      }\n    };\n    _proto._activate = function _activate(target) {\n      this._activeTarget = target;\n      this._clear();\n      var queries = this._selector.split(',').map(function (selector) {\n        return selector + \"[data-target=\\\"\" + target + \"\\\"],\" + selector + \"[href=\\\"\" + target + \"\\\"]\";\n      });\n      var $link = $__default[\"default\"]([].slice.call(document.querySelectorAll(queries.join(','))));\n      if ($link.hasClass(CLASS_NAME_DROPDOWN_ITEM)) {\n        $link.closest(SELECTOR_DROPDOWN$1).find(SELECTOR_DROPDOWN_TOGGLE$1).addClass(CLASS_NAME_ACTIVE$1);\n        $link.addClass(CLASS_NAME_ACTIVE$1);\n      } else {\n        // Set triggered link as active\n        $link.addClass(CLASS_NAME_ACTIVE$1); // Set triggered links parents as active\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_LINKS + \", \" + SELECTOR_LIST_ITEMS).addClass(CLASS_NAME_ACTIVE$1); // Handle special case when .nav-link is inside .nav-item\n\n        $link.parents(SELECTOR_NAV_LIST_GROUP$1).prev(SELECTOR_NAV_ITEMS).children(SELECTOR_NAV_LINKS).addClass(CLASS_NAME_ACTIVE$1);\n      }\n      $__default[\"default\"](this._scrollElement).trigger(EVENT_ACTIVATE, {\n        relatedTarget: target\n      });\n    };\n    _proto._clear = function _clear() {\n      [].slice.call(document.querySelectorAll(this._selector)).filter(function (node) {\n        return node.classList.contains(CLASS_NAME_ACTIVE$1);\n      }).forEach(function (node) {\n        return node.classList.remove(CLASS_NAME_ACTIVE$1);\n      });\n    } // Static\n    ;\n\n    ScrollSpy._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var data = $__default[\"default\"](this).data(DATA_KEY$2);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data) {\n          data = new ScrollSpy(this, _config);\n          $__default[\"default\"](this).data(DATA_KEY$2, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(ScrollSpy, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$2;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default$1;\n      }\n    }]);\n    return ScrollSpy;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](window).on(EVENT_LOAD_DATA_API, function () {\n    var scrollSpys = [].slice.call(document.querySelectorAll(SELECTOR_DATA_SPY));\n    var scrollSpysLength = scrollSpys.length;\n    for (var i = scrollSpysLength; i--;) {\n      var $spy = $__default[\"default\"](scrollSpys[i]);\n      ScrollSpy._jQueryInterface.call($spy, $spy.data());\n    }\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$2] = ScrollSpy._jQueryInterface;\n  $__default[\"default\"].fn[NAME$2].Constructor = ScrollSpy;\n  $__default[\"default\"].fn[NAME$2].noConflict = function () {\n    $__default[\"default\"].fn[NAME$2] = JQUERY_NO_CONFLICT$2;\n    return ScrollSpy._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME$1 = 'tab';\n  var VERSION$1 = '4.6.1';\n  var DATA_KEY$1 = 'bs.tab';\n  var EVENT_KEY$1 = \".\" + DATA_KEY$1;\n  var DATA_API_KEY = '.data-api';\n  var JQUERY_NO_CONFLICT$1 = $__default[\"default\"].fn[NAME$1];\n  var CLASS_NAME_DROPDOWN_MENU = 'dropdown-menu';\n  var CLASS_NAME_ACTIVE = 'active';\n  var CLASS_NAME_DISABLED = 'disabled';\n  var CLASS_NAME_FADE$1 = 'fade';\n  var CLASS_NAME_SHOW$1 = 'show';\n  var EVENT_HIDE$1 = \"hide\" + EVENT_KEY$1;\n  var EVENT_HIDDEN$1 = \"hidden\" + EVENT_KEY$1;\n  var EVENT_SHOW$1 = \"show\" + EVENT_KEY$1;\n  var EVENT_SHOWN$1 = \"shown\" + EVENT_KEY$1;\n  var EVENT_CLICK_DATA_API = \"click\" + EVENT_KEY$1 + DATA_API_KEY;\n  var SELECTOR_DROPDOWN = '.dropdown';\n  var SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\n  var SELECTOR_ACTIVE = '.active';\n  var SELECTOR_ACTIVE_UL = '> li > .active';\n  var SELECTOR_DATA_TOGGLE = '[data-toggle=\"tab\"], [data-toggle=\"pill\"], [data-toggle=\"list\"]';\n  var SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\n  var SELECTOR_DROPDOWN_ACTIVE_CHILD = '> .dropdown-menu .active';\n  /**\n   * Class definition\n   */\n\n  var Tab = /*#__PURE__*/function () {\n    function Tab(element) {\n      this._element = element;\n    } // Getters\n\n    var _proto = Tab.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n      if (this._element.parentNode && this._element.parentNode.nodeType === Node.ELEMENT_NODE && $__default[\"default\"](this._element).hasClass(CLASS_NAME_ACTIVE) || $__default[\"default\"](this._element).hasClass(CLASS_NAME_DISABLED)) {\n        return;\n      }\n      var target;\n      var previous;\n      var listElement = $__default[\"default\"](this._element).closest(SELECTOR_NAV_LIST_GROUP)[0];\n      var selector = Util.getSelectorFromElement(this._element);\n      if (listElement) {\n        var itemSelector = listElement.nodeName === 'UL' || listElement.nodeName === 'OL' ? SELECTOR_ACTIVE_UL : SELECTOR_ACTIVE;\n        previous = $__default[\"default\"].makeArray($__default[\"default\"](listElement).find(itemSelector));\n        previous = previous[previous.length - 1];\n      }\n      var hideEvent = $__default[\"default\"].Event(EVENT_HIDE$1, {\n        relatedTarget: this._element\n      });\n      var showEvent = $__default[\"default\"].Event(EVENT_SHOW$1, {\n        relatedTarget: previous\n      });\n      if (previous) {\n        $__default[\"default\"](previous).trigger(hideEvent);\n      }\n      $__default[\"default\"](this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      if (selector) {\n        target = document.querySelector(selector);\n      }\n      this._activate(this._element, listElement);\n      var complete = function complete() {\n        var hiddenEvent = $__default[\"default\"].Event(EVENT_HIDDEN$1, {\n          relatedTarget: _this._element\n        });\n        var shownEvent = $__default[\"default\"].Event(EVENT_SHOWN$1, {\n          relatedTarget: previous\n        });\n        $__default[\"default\"](previous).trigger(hiddenEvent);\n        $__default[\"default\"](_this._element).trigger(shownEvent);\n      };\n      if (target) {\n        this._activate(target, target.parentNode, complete);\n      } else {\n        complete();\n      }\n    };\n    _proto.dispose = function dispose() {\n      $__default[\"default\"].removeData(this._element, DATA_KEY$1);\n      this._element = null;\n    } // Private\n    ;\n\n    _proto._activate = function _activate(element, container, callback) {\n      var _this2 = this;\n      var activeElements = container && (container.nodeName === 'UL' || container.nodeName === 'OL') ? $__default[\"default\"](container).find(SELECTOR_ACTIVE_UL) : $__default[\"default\"](container).children(SELECTOR_ACTIVE);\n      var active = activeElements[0];\n      var isTransitioning = callback && active && $__default[\"default\"](active).hasClass(CLASS_NAME_FADE$1);\n      var complete = function complete() {\n        return _this2._transitionComplete(element, active, callback);\n      };\n      if (active && isTransitioning) {\n        var transitionDuration = Util.getTransitionDurationFromElement(active);\n        $__default[\"default\"](active).removeClass(CLASS_NAME_SHOW$1).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto._transitionComplete = function _transitionComplete(element, active, callback) {\n      if (active) {\n        $__default[\"default\"](active).removeClass(CLASS_NAME_ACTIVE);\n        var dropdownChild = $__default[\"default\"](active.parentNode).find(SELECTOR_DROPDOWN_ACTIVE_CHILD)[0];\n        if (dropdownChild) {\n          $__default[\"default\"](dropdownChild).removeClass(CLASS_NAME_ACTIVE);\n        }\n        if (active.getAttribute('role') === 'tab') {\n          active.setAttribute('aria-selected', false);\n        }\n      }\n      $__default[\"default\"](element).addClass(CLASS_NAME_ACTIVE);\n      if (element.getAttribute('role') === 'tab') {\n        element.setAttribute('aria-selected', true);\n      }\n      Util.reflow(element);\n      if (element.classList.contains(CLASS_NAME_FADE$1)) {\n        element.classList.add(CLASS_NAME_SHOW$1);\n      }\n      var parent = element.parentNode;\n      if (parent && parent.nodeName === 'LI') {\n        parent = parent.parentNode;\n      }\n      if (parent && $__default[\"default\"](parent).hasClass(CLASS_NAME_DROPDOWN_MENU)) {\n        var dropdownElement = $__default[\"default\"](element).closest(SELECTOR_DROPDOWN)[0];\n        if (dropdownElement) {\n          var dropdownToggleList = [].slice.call(dropdownElement.querySelectorAll(SELECTOR_DROPDOWN_TOGGLE));\n          $__default[\"default\"](dropdownToggleList).addClass(CLASS_NAME_ACTIVE);\n        }\n        element.setAttribute('aria-expanded', true);\n      }\n      if (callback) {\n        callback();\n      }\n    } // Static\n    ;\n\n    Tab._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $this = $__default[\"default\"](this);\n        var data = $this.data(DATA_KEY$1);\n        if (!data) {\n          data = new Tab(this);\n          $this.data(DATA_KEY$1, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config]();\n        }\n      });\n    };\n    _createClass(Tab, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION$1;\n      }\n    }]);\n    return Tab;\n  }();\n  /**\n   * Data API implementation\n   */\n\n  $__default[\"default\"](document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\n    event.preventDefault();\n    Tab._jQueryInterface.call($__default[\"default\"](this), 'show');\n  });\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME$1] = Tab._jQueryInterface;\n  $__default[\"default\"].fn[NAME$1].Constructor = Tab;\n  $__default[\"default\"].fn[NAME$1].noConflict = function () {\n    $__default[\"default\"].fn[NAME$1] = JQUERY_NO_CONFLICT$1;\n    return Tab._jQueryInterface;\n  };\n\n  /**\n   * Constants\n   */\n\n  var NAME = 'toast';\n  var VERSION = '4.6.1';\n  var DATA_KEY = 'bs.toast';\n  var EVENT_KEY = \".\" + DATA_KEY;\n  var JQUERY_NO_CONFLICT = $__default[\"default\"].fn[NAME];\n  var CLASS_NAME_FADE = 'fade';\n  var CLASS_NAME_HIDE = 'hide';\n  var CLASS_NAME_SHOW = 'show';\n  var CLASS_NAME_SHOWING = 'showing';\n  var EVENT_CLICK_DISMISS = \"click.dismiss\" + EVENT_KEY;\n  var EVENT_HIDE = \"hide\" + EVENT_KEY;\n  var EVENT_HIDDEN = \"hidden\" + EVENT_KEY;\n  var EVENT_SHOW = \"show\" + EVENT_KEY;\n  var EVENT_SHOWN = \"shown\" + EVENT_KEY;\n  var SELECTOR_DATA_DISMISS = '[data-dismiss=\"toast\"]';\n  var Default = {\n    animation: true,\n    autohide: true,\n    delay: 500\n  };\n  var DefaultType = {\n    animation: 'boolean',\n    autohide: 'boolean',\n    delay: 'number'\n  };\n  /**\n   * Class definition\n   */\n\n  var Toast = /*#__PURE__*/function () {\n    function Toast(element, config) {\n      this._element = element;\n      this._config = this._getConfig(config);\n      this._timeout = null;\n      this._setListeners();\n    } // Getters\n\n    var _proto = Toast.prototype;\n\n    // Public\n    _proto.show = function show() {\n      var _this = this;\n      var showEvent = $__default[\"default\"].Event(EVENT_SHOW);\n      $__default[\"default\"](this._element).trigger(showEvent);\n      if (showEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._clearTimeout();\n      if (this._config.animation) {\n        this._element.classList.add(CLASS_NAME_FADE);\n      }\n      var complete = function complete() {\n        _this._element.classList.remove(CLASS_NAME_SHOWING);\n        _this._element.classList.add(CLASS_NAME_SHOW);\n        $__default[\"default\"](_this._element).trigger(EVENT_SHOWN);\n        if (_this._config.autohide) {\n          _this._timeout = setTimeout(function () {\n            _this.hide();\n          }, _this._config.delay);\n        }\n      };\n      this._element.classList.remove(CLASS_NAME_HIDE);\n      Util.reflow(this._element);\n      this._element.classList.add(CLASS_NAME_SHOWING);\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default[\"default\"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto.hide = function hide() {\n      if (!this._element.classList.contains(CLASS_NAME_SHOW)) {\n        return;\n      }\n      var hideEvent = $__default[\"default\"].Event(EVENT_HIDE);\n      $__default[\"default\"](this._element).trigger(hideEvent);\n      if (hideEvent.isDefaultPrevented()) {\n        return;\n      }\n      this._close();\n    };\n    _proto.dispose = function dispose() {\n      this._clearTimeout();\n      if (this._element.classList.contains(CLASS_NAME_SHOW)) {\n        this._element.classList.remove(CLASS_NAME_SHOW);\n      }\n      $__default[\"default\"](this._element).off(EVENT_CLICK_DISMISS);\n      $__default[\"default\"].removeData(this._element, DATA_KEY);\n      this._element = null;\n      this._config = null;\n    } // Private\n    ;\n\n    _proto._getConfig = function _getConfig(config) {\n      config = _extends$1({}, Default, $__default[\"default\"](this._element).data(), _typeof(config) === 'object' && config ? config : {});\n      Util.typeCheckConfig(NAME, config, this.constructor.DefaultType);\n      return config;\n    };\n    _proto._setListeners = function _setListeners() {\n      var _this2 = this;\n      $__default[\"default\"](this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, function () {\n        return _this2.hide();\n      });\n    };\n    _proto._close = function _close() {\n      var _this3 = this;\n      var complete = function complete() {\n        _this3._element.classList.add(CLASS_NAME_HIDE);\n        $__default[\"default\"](_this3._element).trigger(EVENT_HIDDEN);\n      };\n      this._element.classList.remove(CLASS_NAME_SHOW);\n      if (this._config.animation) {\n        var transitionDuration = Util.getTransitionDurationFromElement(this._element);\n        $__default[\"default\"](this._element).one(Util.TRANSITION_END, complete).emulateTransitionEnd(transitionDuration);\n      } else {\n        complete();\n      }\n    };\n    _proto._clearTimeout = function _clearTimeout() {\n      clearTimeout(this._timeout);\n      this._timeout = null;\n    } // Static\n    ;\n\n    Toast._jQueryInterface = function _jQueryInterface(config) {\n      return this.each(function () {\n        var $element = $__default[\"default\"](this);\n        var data = $element.data(DATA_KEY);\n        var _config = _typeof(config) === 'object' && config;\n        if (!data) {\n          data = new Toast(this, _config);\n          $element.data(DATA_KEY, data);\n        }\n        if (typeof config === 'string') {\n          if (typeof data[config] === 'undefined') {\n            throw new TypeError(\"No method named \\\"\" + config + \"\\\"\");\n          }\n          data[config](this);\n        }\n      });\n    };\n    _createClass(Toast, null, [{\n      key: \"VERSION\",\n      get: function get() {\n        return VERSION;\n      }\n    }, {\n      key: \"DefaultType\",\n      get: function get() {\n        return DefaultType;\n      }\n    }, {\n      key: \"Default\",\n      get: function get() {\n        return Default;\n      }\n    }]);\n    return Toast;\n  }();\n  /**\n   * jQuery\n   */\n\n  $__default[\"default\"].fn[NAME] = Toast._jQueryInterface;\n  $__default[\"default\"].fn[NAME].Constructor = Toast;\n  $__default[\"default\"].fn[NAME].noConflict = function () {\n    $__default[\"default\"].fn[NAME] = JQUERY_NO_CONFLICT;\n    return Toast._jQueryInterface;\n  };\n  exports.Alert = Alert;\n  exports.Button = Button;\n  exports.Carousel = Carousel;\n  exports.Collapse = Collapse;\n  exports.Dropdown = Dropdown;\n  exports.Modal = Modal;\n  exports.Popover = Popover;\n  exports.Scrollspy = ScrollSpy;\n  exports.Tab = Tab;\n  exports.Toast = Toast;\n  exports.Tooltip = Tooltip;\n  exports.Util = Util;\n  Object.defineProperty(exports, '__esModule', {\n    value: true\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvYWRtaW5sdGUvcGx1Z2lucy9ib290c3RyYXAvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBQUE7Ozs7OztFQVNBOzs7O0VBSUEsSUFBTUEsY0FBYyxHQUFHLGVBQXZCO0VBQ0EsSUFBTUMsT0FBTyxHQUFHLE9BQWhCO0VBQ0EsSUFBTUMsdUJBQXVCLEdBQUcsSUFBaEM7O0VBR0EsU0FBU0MsTUFBVCxDQUFnQkMsR0FBaEIsRUFBcUI7SUFDbkIsSUFBSUEsR0FBRyxLQUFLLElBQVIsSUFBZ0IsT0FBT0EsR0FBUCxLQUFlLFdBQW5DLEVBQWdEO01BQzlDLFlBQVVBLEdBQVY7SUFDRDtJQUVELE9BQU8sR0FBR0MsUUFBSCxDQUFZQyxJQUFaLENBQWlCRixHQUFqQixFQUFzQkcsS0FBdEIsQ0FBNEIsYUFBNUIsRUFBMkMsQ0FBM0MsRUFBOENDLFdBQTlDLEVBQVA7RUFDRDtFQUVELFNBQVNDLDRCQUFULEdBQXdDO0lBQ3RDLE9BQU87TUFDTEMsUUFBUSxFQUFFVixjQURMO01BRUxXLFlBQVksRUFBRVgsY0FGVDtNQUdMWSxNQUhLLGtCQUdFQyxLQUhGLEVBR1M7UUFDWixJQUFJQyxxQkFBQyxDQUFDRCxLQUFLLENBQUNFLE1BQVAsQ0FBRCxDQUFnQkMsRUFBaEIsQ0FBbUIsSUFBbkIsQ0FBSixFQUE4QjtVQUM1QixPQUFPSCxLQUFLLENBQUNJLFNBQU4sQ0FBZ0JDLE9BQWhCLENBQXdCQyxLQUF4QixDQUE4QixJQUE5QixFQUFvQ0MsU0FBcEMsQ0FBUCxDQUQ0QjtRQUU3Qjs7UUFFRCxPQUFPQyxTQUFQO01BQ0Q7SUFUSSxDQUFQO0VBV0Q7RUFFRCxTQUFTQyxxQkFBVCxDQUErQkMsUUFBL0IsRUFBeUM7SUFBQTtJQUN2QyxJQUFJQyxNQUFNLEdBQUcsS0FBYjtJQUVBVixxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRVyxHQUFSLENBQVlDLElBQUksQ0FBQzFCLGNBQWpCLEVBQWlDLFlBQU07TUFDckN3QixNQUFNLEdBQUcsSUFBVDtJQUNELENBRkQ7SUFJQUcsVUFBVSxDQUFDLFlBQU07TUFDZixJQUFJLENBQUNILE1BQUwsRUFBYTtRQUNYRSxJQUFJLENBQUNFLG9CQUFMLENBQTBCQyxLQUExQjtNQUNEO0lBQ0YsQ0FKUyxFQUlQTixRQUpPLENBQVY7SUFNQSxPQUFPLElBQVA7RUFDRDtFQUVELFNBQVNPLHVCQUFULEdBQW1DO0lBQ2pDaEIscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBS0Msb0JBQUwsR0FBNEJWLHFCQUE1QjtJQUNBUixxQkFBQyxDQUFDRCxLQUFGLENBQVFvQixPQUFSLENBQWdCUCxJQUFJLENBQUMxQixjQUFyQixJQUF1Q1MsNEJBQTRCLEVBQW5FO0VBQ0Q7RUFFRDs7OztNQUlNaUIsSUFBSSxHQUFHO0lBQ1gxQixjQUFjLEVBQUUsaUJBREw7SUFHWGtDLE1BSFcsa0JBR0pDLE1BSEksRUFHSTtNQUNiLEdBQUc7UUFDRDtRQUNBQSxNQUFNLElBQUksQ0FBQyxFQUFFQyxJQUFJLENBQUNDLE1BQUwsS0FBZ0JwQyxPQUFsQixDQUFYLENBRkM7TUFHRixDQUhELFFBR1NxQyxRQUFRLENBQUNDLGNBQVQsQ0FBd0JKLE1BQXhCLENBSFQ7TUFLQSxPQUFPQSxNQUFQO0lBQ0QsQ0FWVTtJQVlYSyxzQkFaVyxrQ0FZWUMsT0FaWixFQVlxQjtNQUM5QixJQUFJQyxRQUFRLEdBQUdELE9BQU8sQ0FBQ0UsWUFBUixDQUFxQixhQUFyQixDQUFmO01BRUEsSUFBSSxDQUFDRCxRQUFELElBQWFBLFFBQVEsS0FBSyxHQUE5QixFQUFtQztRQUNqQyxJQUFNRSxRQUFRLEdBQUdILE9BQU8sQ0FBQ0UsWUFBUixDQUFxQixNQUFyQixDQUFqQjtRQUNBRCxRQUFRLEdBQUdFLFFBQVEsSUFBSUEsUUFBUSxLQUFLLEdBQXpCLEdBQStCQSxRQUFRLENBQUNDLElBQVQsRUFBL0IsR0FBaUQsRUFBNUQ7TUFDRDtNQUVELElBQUk7UUFDRixPQUFPUCxRQUFRLENBQUNRLGFBQVQsQ0FBdUJKLFFBQXZCLElBQW1DQSxRQUFuQyxHQUE4QyxJQUFyRDtNQUNELENBRkQsQ0FFRSxPQUFPSyxDQUFQLEVBQVU7UUFDVixPQUFPLElBQVA7TUFDRDtJQUNGLENBekJVO0lBMkJYQyxnQ0EzQlcsNENBMkJzQlAsT0EzQnRCLEVBMkIrQjtNQUN4QyxJQUFJLENBQUNBLE9BQUwsRUFBYztRQUNaLE9BQU8sQ0FBUDtNQUNELENBSHVDOztNQU14QyxJQUFJUSxrQkFBa0IsR0FBR25DLHFCQUFDLENBQUMyQixPQUFELENBQUQsQ0FBV1MsR0FBWCxDQUFlLHFCQUFmLENBQXpCO01BQ0EsSUFBSUMsZUFBZSxHQUFHckMscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXUyxHQUFYLENBQWUsa0JBQWYsQ0FBdEI7TUFFQSxJQUFNRSx1QkFBdUIsR0FBR0MsVUFBVSxDQUFDSixrQkFBRCxDQUExQztNQUNBLElBQU1LLG9CQUFvQixHQUFHRCxVQUFVLENBQUNGLGVBQUQsQ0FBdkMsQ0FWd0M7O01BYXhDLElBQUksQ0FBQ0MsdUJBQUQsSUFBNEIsQ0FBQ0Usb0JBQWpDLEVBQXVEO1FBQ3JELE9BQU8sQ0FBUDtNQUNELENBZnVDOztNQWtCeENMLGtCQUFrQixHQUFHQSxrQkFBa0IsQ0FBQ00sS0FBbkIsQ0FBeUIsR0FBekIsRUFBOEIsQ0FBOUIsQ0FBckI7TUFDQUosZUFBZSxHQUFHQSxlQUFlLENBQUNJLEtBQWhCLENBQXNCLEdBQXRCLEVBQTJCLENBQTNCLENBQWxCO01BRUEsT0FBTyxDQUFDRixVQUFVLENBQUNKLGtCQUFELENBQVYsR0FBaUNJLFVBQVUsQ0FBQ0YsZUFBRCxDQUE1QyxJQUFpRWpELHVCQUF4RTtJQUNELENBakRVO0lBbURYc0QsTUFuRFcsa0JBbURKZixPQW5ESSxFQW1ESztNQUNkLE9BQU9BLE9BQU8sQ0FBQ2dCLFlBQWY7SUFDRCxDQXJEVTtJQXVEWDdCLG9CQXZEVyxnQ0F1RFVhLE9BdkRWLEVBdURtQjtNQUM1QjNCLHFCQUFDLENBQUMyQixPQUFELENBQUQsQ0FBV2lCLE9BQVgsQ0FBbUIxRCxjQUFuQjtJQUNELENBekRVO0lBMkRYMkQscUJBM0RXLG1DQTJEYTtNQUN0QixPQUFPQyxPQUFPLENBQUM1RCxjQUFELENBQWQ7SUFDRCxDQTdEVTtJQStEWDZELFNBL0RXLHFCQStERHpELEdBL0RDLEVBK0RJO01BQ2IsT0FBTyxDQUFDQSxHQUFHLENBQUMsQ0FBRCxDQUFILElBQVVBLEdBQVgsRUFBZ0IwRCxRQUF2QjtJQUNELENBakVVO0lBbUVYQyxlQW5FVywyQkFtRUtDLGFBbkVMLEVBbUVvQkMsTUFuRXBCLEVBbUU0QkMsV0FuRTVCLEVBbUV5QztNQUNsRCxLQUFLLElBQU1DLFFBQVgsSUFBdUJELFdBQXZCLEVBQW9DO1FBQ2xDLElBQUlFLE1BQU0sQ0FBQ0MsU0FBUCxDQUFpQkMsY0FBakIsQ0FBZ0NoRSxJQUFoQyxDQUFxQzRELFdBQXJDLEVBQWtEQyxRQUFsRCxDQUFKLEVBQWlFO1VBQy9ELElBQU1JLGFBQWEsR0FBR0wsV0FBVyxDQUFDQyxRQUFELENBQWpDO1VBQ0EsSUFBTUssS0FBSyxHQUFHUCxNQUFNLENBQUNFLFFBQUQsQ0FBcEI7VUFDQSxJQUFNTSxTQUFTLEdBQUdELEtBQUssSUFBSTlDLElBQUksQ0FBQ21DLFNBQUwsQ0FBZVcsS0FBZixDQUFULEdBQ2hCLFNBRGdCLEdBQ0pyRSxNQUFNLENBQUNxRSxLQUFELENBRHBCO1VBR0EsSUFBSSxDQUFDLElBQUlFLE1BQUosQ0FBV0gsYUFBWCxFQUEwQkksSUFBMUIsQ0FBK0JGLFNBQS9CLENBQUwsRUFBZ0Q7WUFDOUMsTUFBTSxJQUFJRyxLQUFKLENBQ0RaLGFBQWEsQ0FBQ2EsV0FBZCxFQUFILHlCQUNXVixRQURYLDJCQUN1Q00sU0FEdkMsc0NBRXNCRixhQUZ0QixTQURJLENBQU47VUFJRDtRQUNGO01BQ0Y7SUFDRixDQW5GVTtJQXFGWE8sY0FyRlcsMEJBcUZJckMsT0FyRkosRUFxRmE7TUFDdEIsSUFBSSxDQUFDSCxRQUFRLENBQUN5QyxlQUFULENBQXlCQyxZQUE5QixFQUE0QztRQUMxQyxPQUFPLElBQVA7TUFDRCxDQUhxQjs7TUFNdEIsSUFBSSxPQUFPdkMsT0FBTyxDQUFDd0MsV0FBZixLQUErQixVQUFuQyxFQUErQztRQUM3QyxJQUFNQyxJQUFJLEdBQUd6QyxPQUFPLENBQUN3QyxXQUFSLEVBQWI7UUFDQSxPQUFPQyxJQUFJLFlBQVlDLFVBQWhCLEdBQTZCRCxJQUE3QixHQUFvQyxJQUEzQztNQUNEO01BRUQsSUFBSXpDLE9BQU8sWUFBWTBDLFVBQXZCLEVBQW1DO1FBQ2pDLE9BQU8xQyxPQUFQO01BQ0QsQ0FicUI7O01BZ0J0QixJQUFJLENBQUNBLE9BQU8sQ0FBQzJDLFVBQWIsRUFBeUI7UUFDdkIsT0FBTyxJQUFQO01BQ0Q7TUFFRCxPQUFPMUQsSUFBSSxDQUFDb0QsY0FBTCxDQUFvQnJDLE9BQU8sQ0FBQzJDLFVBQTVCLENBQVA7SUFDRCxDQTFHVTtJQTRHWEMsZUE1R1csNkJBNEdPO01BQ2hCLElBQUksT0FBT3ZFLHFCQUFQLEtBQWEsV0FBakIsRUFBOEI7UUFDNUIsTUFBTSxJQUFJd0UsU0FBSixDQUFjLGtHQUFkLENBQU47TUFDRDtNQUVELElBQU1DLE9BQU8sR0FBR3pFLHFCQUFDLENBQUNpQixFQUFGLENBQUt5RCxNQUFMLENBQVlqQyxLQUFaLENBQWtCLEdBQWxCLEVBQXVCLENBQXZCLEVBQTBCQSxLQUExQixDQUFnQyxHQUFoQyxDQUFoQjtNQUNBLElBQU1rQyxRQUFRLEdBQUcsQ0FBakI7TUFDQSxJQUFNQyxPQUFPLEdBQUcsQ0FBaEI7TUFDQSxJQUFNQyxRQUFRLEdBQUcsQ0FBakI7TUFDQSxJQUFNQyxRQUFRLEdBQUcsQ0FBakI7TUFDQSxJQUFNQyxRQUFRLEdBQUcsQ0FBakI7TUFFQSxJQUFJTixPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFHLE9BQWIsSUFBd0JILE9BQU8sQ0FBQyxDQUFELENBQVAsR0FBYUksUUFBckMsSUFBaURKLE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZUUsUUFBZixJQUEyQkYsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlSSxRQUExQyxJQUFzREosT0FBTyxDQUFDLENBQUQsQ0FBUCxHQUFhSyxRQUFwSCxJQUFnSUwsT0FBTyxDQUFDLENBQUQsQ0FBUCxJQUFjTSxRQUFsSixFQUE0SjtRQUMxSixNQUFNLElBQUlqQixLQUFKLENBQVUsOEVBQVYsQ0FBTjtNQUNEO0lBQ0Y7RUEzSFU7RUE4SGJsRCxJQUFJLENBQUMyRCxlQUFMO0VBQ0F2RCx1QkFBdUI7O0VDdEx2Qjs7OztFQUlBLElBQU1nRSxNQUFJLEdBQUcsT0FBYjtFQUNBLElBQU1DLFNBQU8sR0FBRyxPQUFoQjtFQUNBLElBQU1DLFVBQVEsR0FBRyxVQUFqQjtFQUNBLElBQU1DLFdBQVMsU0FBT0QsVUFBdEI7RUFDQSxJQUFNRSxjQUFZLEdBQUcsV0FBckI7RUFDQSxJQUFNQyxvQkFBa0IsR0FBR3JGLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLENBQTNCO0VBRUEsSUFBTU0sZ0JBQWdCLEdBQUcsT0FBekI7RUFDQSxJQUFNQyxpQkFBZSxHQUFHLE1BQXhCO0VBQ0EsSUFBTUMsaUJBQWUsR0FBRyxNQUF4QjtFQUVBLElBQU1DLFdBQVcsYUFBV04sV0FBNUI7RUFDQSxJQUFNTyxZQUFZLGNBQVlQLFdBQTlCO0VBQ0EsSUFBTVEsc0JBQW9CLGFBQVdSLFdBQVgsR0FBdUJDLGNBQWpEO0VBRUEsSUFBTVEsZ0JBQWdCLEdBQUcsd0JBQXpCO0VBRUE7Ozs7TUFJTUM7SUFDSixlQUFZbEUsT0FBWixFQUFxQjtNQUNuQixLQUFLbUUsUUFBTCxHQUFnQm5FLE9BQWhCO0lBQ0Q7Ozs7SUFPRDtXQUNBb0UsdUJBQU1wRSxPQUFOLEVBQWU7TUFDYixJQUFJcUUsV0FBVyxHQUFHLEtBQUtGLFFBQXZCO01BQ0EsSUFBSW5FLE9BQUosRUFBYTtRQUNYcUUsV0FBVyxHQUFHLEtBQUtDLGVBQUwsQ0FBcUJ0RSxPQUFyQixDQUFkO01BQ0Q7TUFFRCxJQUFNdUUsV0FBVyxHQUFHLEtBQUtDLGtCQUFMLENBQXdCSCxXQUF4QixDQUFwQjtNQUVBLElBQUlFLFdBQVcsQ0FBQ0Usa0JBQVosRUFBSixFQUFzQztRQUNwQztNQUNEO01BRUQsS0FBS0MsY0FBTCxDQUFvQkwsV0FBcEI7SUFDRDtXQUVETSw2QkFBVTtNQUNSdEcscUJBQUMsQ0FBQ3VHLFVBQUYsQ0FBYSxLQUFLVCxRQUFsQixFQUE0QlosVUFBNUI7TUFDQSxLQUFLWSxRQUFMLEdBQWdCLElBQWhCO0lBQ0Q7SUFBQTs7V0FHREcsMkNBQWdCdEUsT0FBaEIsRUFBeUI7TUFDdkIsSUFBTUMsUUFBUSxHQUFHaEIsSUFBSSxDQUFDYyxzQkFBTCxDQUE0QkMsT0FBNUIsQ0FBakI7TUFDQSxJQUFJNkUsTUFBTSxHQUFHLEtBQWI7TUFFQSxJQUFJNUUsUUFBSixFQUFjO1FBQ1o0RSxNQUFNLEdBQUdoRixRQUFRLENBQUNRLGFBQVQsQ0FBdUJKLFFBQXZCLENBQVQ7TUFDRDtNQUVELElBQUksQ0FBQzRFLE1BQUwsRUFBYTtRQUNYQSxNQUFNLEdBQUd4RyxxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVc4RSxPQUFYLE9BQXVCbkIsZ0JBQXZCLEVBQTJDLENBQTNDLENBQVQ7TUFDRDtNQUVELE9BQU9rQixNQUFQO0lBQ0Q7V0FFREwsaURBQW1CeEUsT0FBbkIsRUFBNEI7TUFDMUIsSUFBTStFLFVBQVUsR0FBRzFHLHFCQUFDLENBQUMyRyxLQUFGLENBQVFsQixXQUFSLENBQW5CO01BRUF6RixxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVdpQixPQUFYLENBQW1COEQsVUFBbkI7TUFDQSxPQUFPQSxVQUFQO0lBQ0Q7V0FFREwseUNBQWUxRSxPQUFmLEVBQXdCO01BQUE7TUFDdEIzQixxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVdpRixXQUFYLENBQXVCcEIsaUJBQXZCO01BRUEsSUFBSSxDQUFDeEYscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXa0YsUUFBWCxDQUFvQnRCLGlCQUFwQixDQUFMLEVBQTJDO1FBQ3pDLEtBQUt1QixlQUFMLENBQXFCbkYsT0FBckI7UUFDQTtNQUNEO01BRUQsSUFBTVEsa0JBQWtCLEdBQUd2QixJQUFJLENBQUNzQixnQ0FBTCxDQUFzQ1AsT0FBdEMsQ0FBM0I7TUFFQTNCLHFCQUFDLENBQUMyQixPQUFELENBQUQsQ0FDR2hCLEdBREgsQ0FDT0MsSUFBSSxDQUFDMUIsY0FEWixFQUM0QixlQUFLO1FBQUEsT0FBSTZCLEtBQUksQ0FBQytGLGVBQUwsQ0FBcUJuRixPQUFyQixFQUE4QjVCLEtBQTlCLENBQUo7TUFBQSxDQURqQyxFQUVHbUIsb0JBRkgsQ0FFd0JpQixrQkFGeEI7SUFHRDtXQUVEMkUsMkNBQWdCbkYsT0FBaEIsRUFBeUI7TUFDdkIzQixxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQ0dvRixNQURILEdBRUduRSxPQUZILENBRVc4QyxZQUZYLEVBR0dzQixNQUhIO0lBSUQ7SUFBQTs7VUFHTUMsbUJBQVAsMEJBQXdCOUQsTUFBeEIsRUFBZ0M7TUFDOUIsT0FBTyxLQUFLK0QsSUFBTCxDQUFVLFlBQVk7UUFDM0IsSUFBTUMsUUFBUSxHQUFHbkgscUJBQUMsQ0FBQyxJQUFELENBQWxCO1FBQ0EsSUFBSW9ILElBQUksR0FBR0QsUUFBUSxDQUFDQyxJQUFULENBQWNsQyxVQUFkLENBQVg7UUFFQSxJQUFJLENBQUNrQyxJQUFMLEVBQVc7VUFDVEEsSUFBSSxHQUFHLElBQUl2QixLQUFKLENBQVUsSUFBVixDQUFQO1VBQ0FzQixRQUFRLENBQUNDLElBQVQsQ0FBY2xDLFVBQWQsRUFBd0JrQyxJQUF4QjtRQUNEO1FBRUQsSUFBSWpFLE1BQU0sS0FBSyxPQUFmLEVBQXdCO1VBQ3RCaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFKLENBQWEsSUFBYjtRQUNEO01BQ0YsQ0FaTSxDQUFQO0lBYUQ7VUFFTWtFLGlCQUFQLHdCQUFzQkMsYUFBdEIsRUFBcUM7TUFDbkMsT0FBTyxVQUFVdkgsS0FBVixFQUFpQjtRQUN0QixJQUFJQSxLQUFKLEVBQVc7VUFDVEEsS0FBSyxDQUFDd0gsY0FBTjtRQUNEO1FBRURELGFBQWEsQ0FBQ3ZCLEtBQWQsQ0FBb0IsSUFBcEI7TUFDRCxDQU5EO0lBT0Q7OztXQS9GRCxlQUFxQjtRQUNuQixPQUFPZCxTQUFQO01BQ0Q7Ozs7RUFnR0g7Ozs7RUFJQWpGLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWWdHLEVBQVosQ0FDRTdCLHNCQURGLEVBRUVDLGdCQUZGLEVBR0VDLEtBQUssQ0FBQ3dCLGNBQU4sQ0FBcUIsSUFBSXhCLEtBQUosRUFBckIsQ0FIRjtFQU1BOzs7O0VBSUE3RixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhYSxLQUFLLENBQUNvQixnQkFBbkI7RUFDQWpILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVd5QyxXQUFYLEdBQXlCNUIsS0FBekI7RUFDQTdGLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU9RLEtBQUssQ0FBQ29CLGdCQUFiO0VBQ0QsQ0FIRDs7RUNsSkE7Ozs7RUFJQSxJQUFNakMsTUFBSSxHQUFHLFFBQWI7RUFDQSxJQUFNQyxTQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyxVQUFRLEdBQUcsV0FBakI7RUFDQSxJQUFNQyxXQUFTLFNBQU9ELFVBQXRCO0VBQ0EsSUFBTUUsY0FBWSxHQUFHLFdBQXJCO0VBQ0EsSUFBTUMsb0JBQWtCLEdBQUdyRixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxDQUEzQjtFQUVBLElBQU0yQyxtQkFBaUIsR0FBRyxRQUExQjtFQUNBLElBQU1DLGlCQUFpQixHQUFHLEtBQTFCO0VBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsT0FBekI7RUFFQSxJQUFNbEMsc0JBQW9CLGFBQVdSLFdBQVgsR0FBdUJDLGNBQWpEO0VBQ0EsSUFBTTBDLHlCQUF5QixHQUFHLFVBQVEzQyxXQUFSLEdBQW9CQyxjQUFwQixtQkFDREQsV0FEQyxHQUNXQyxjQURYLENBQWxDO0VBRUEsSUFBTTJDLHFCQUFtQixZQUFVNUMsV0FBVixHQUFzQkMsY0FBL0M7RUFFQSxJQUFNNEMsMkJBQTJCLEdBQUcseUJBQXBDO0VBQ0EsSUFBTUMscUJBQXFCLEdBQUcseUJBQTlCO0VBQ0EsSUFBTUMsc0JBQW9CLEdBQUcsd0JBQTdCO0VBQ0EsSUFBTUMsNkJBQTZCLEdBQUcsOEJBQXRDO0VBQ0EsSUFBTUMsY0FBYyxHQUFHLDRCQUF2QjtFQUNBLElBQU1DLGlCQUFlLEdBQUcsU0FBeEI7RUFDQSxJQUFNQyxlQUFlLEdBQUcsTUFBeEI7RUFFQTs7OztNQUlNQztJQUNKLGdCQUFZNUcsT0FBWixFQUFxQjtNQUNuQixLQUFLbUUsUUFBTCxHQUFnQm5FLE9BQWhCO01BQ0EsS0FBSzZHLHdCQUFMLEdBQWdDLEtBQWhDO0lBQ0Q7Ozs7SUFPRDtXQUNBQywyQkFBUztNQUNQLElBQUlDLGtCQUFrQixHQUFHLElBQXpCO01BQ0EsSUFBSUMsY0FBYyxHQUFHLElBQXJCO01BQ0EsSUFBTTNDLFdBQVcsR0FBR2hHLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQlcsT0FBakIsQ0FBeUJ3QixxQkFBekIsRUFBZ0QsQ0FBaEQsQ0FBcEI7TUFFQSxJQUFJakMsV0FBSixFQUFpQjtRQUNmLElBQU00QyxLQUFLLEdBQUcsS0FBSzlDLFFBQUwsQ0FBYzlELGFBQWQsQ0FBNEJvRyxjQUE1QixDQUFkO1FBRUEsSUFBSVEsS0FBSixFQUFXO1VBQ1QsSUFBSUEsS0FBSyxDQUFDQyxJQUFOLEtBQWUsT0FBbkIsRUFBNEI7WUFDMUIsSUFBSUQsS0FBSyxDQUFDRSxPQUFOLElBQWlCLEtBQUtoRCxRQUFMLENBQWNpRCxTQUFkLENBQXdCQyxRQUF4QixDQUFpQ3JCLG1CQUFqQyxDQUFyQixFQUEwRTtjQUN4RWUsa0JBQWtCLEdBQUcsS0FBckI7WUFDRCxDQUZELE1BRU87Y0FDTCxJQUFNTyxhQUFhLEdBQUdqRCxXQUFXLENBQUNoRSxhQUFaLENBQTBCcUcsaUJBQTFCLENBQXRCO2NBRUEsSUFBSVksYUFBSixFQUFtQjtnQkFDakJqSixxQkFBQyxDQUFDaUosYUFBRCxDQUFELENBQWlCckMsV0FBakIsQ0FBNkJlLG1CQUE3QjtjQUNEO1lBQ0Y7VUFDRjtVQUVELElBQUllLGtCQUFKLEVBQXdCO1lBQ3RCO1lBQ0EsSUFBSUUsS0FBSyxDQUFDQyxJQUFOLEtBQWUsVUFBZixJQUE2QkQsS0FBSyxDQUFDQyxJQUFOLEtBQWUsT0FBaEQsRUFBeUQ7Y0FDdkRELEtBQUssQ0FBQ0UsT0FBTixHQUFnQixDQUFDLEtBQUtoRCxRQUFMLENBQWNpRCxTQUFkLENBQXdCQyxRQUF4QixDQUFpQ3JCLG1CQUFqQyxDQUFqQjtZQUNEO1lBRUQsSUFBSSxDQUFDLEtBQUthLHdCQUFWLEVBQW9DO2NBQ2xDeEkscUJBQUMsQ0FBQzRJLEtBQUQsQ0FBRCxDQUFTaEcsT0FBVCxDQUFpQixRQUFqQjtZQUNEO1VBQ0Y7VUFFRGdHLEtBQUssQ0FBQ00sS0FBTjtVQUNBUCxjQUFjLEdBQUcsS0FBakI7UUFDRDtNQUNGO01BRUQsSUFBSSxFQUFFLEtBQUs3QyxRQUFMLENBQWNxRCxZQUFkLENBQTJCLFVBQTNCLEtBQTBDLEtBQUtyRCxRQUFMLENBQWNpRCxTQUFkLENBQXdCQyxRQUF4QixDQUFpQyxVQUFqQyxDQUE1QyxDQUFKLEVBQStGO1FBQzdGLElBQUlMLGNBQUosRUFBb0I7VUFDbEIsS0FBSzdDLFFBQUwsQ0FBY3NELFlBQWQsQ0FBMkIsY0FBM0IsRUFBMkMsQ0FBQyxLQUFLdEQsUUFBTCxDQUFjaUQsU0FBZCxDQUF3QkMsUUFBeEIsQ0FBaUNyQixtQkFBakMsQ0FBNUM7UUFDRDtRQUVELElBQUllLGtCQUFKLEVBQXdCO1VBQ3RCMUkscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCdUQsV0FBakIsQ0FBNkIxQixtQkFBN0I7UUFDRDtNQUNGO0lBQ0Y7V0FFRHJCLDZCQUFVO01BQ1J0RyxxQkFBQyxDQUFDdUcsVUFBRixDQUFhLEtBQUtULFFBQWxCLEVBQTRCWixVQUE1QjtNQUNBLEtBQUtZLFFBQUwsR0FBZ0IsSUFBaEI7SUFDRDtJQUFBOztXQUdNbUIsbUJBQVAsMEJBQXdCOUQsTUFBeEIsRUFBZ0NtRyxrQkFBaEMsRUFBb0Q7TUFDbEQsT0FBTyxLQUFLcEMsSUFBTCxDQUFVLFlBQVk7UUFDM0IsSUFBTUMsUUFBUSxHQUFHbkgscUJBQUMsQ0FBQyxJQUFELENBQWxCO1FBQ0EsSUFBSW9ILElBQUksR0FBR0QsUUFBUSxDQUFDQyxJQUFULENBQWNsQyxVQUFkLENBQVg7UUFFQSxJQUFJLENBQUNrQyxJQUFMLEVBQVc7VUFDVEEsSUFBSSxHQUFHLElBQUltQixNQUFKLENBQVcsSUFBWCxDQUFQO1VBQ0FwQixRQUFRLENBQUNDLElBQVQsQ0FBY2xDLFVBQWQsRUFBd0JrQyxJQUF4QjtRQUNEO1FBRURBLElBQUksQ0FBQ29CLHdCQUFMLEdBQWdDYyxrQkFBaEM7UUFFQSxJQUFJbkcsTUFBTSxLQUFLLFFBQWYsRUFBeUI7VUFDdkJpRSxJQUFJLENBQUNqRSxNQUFELENBQUo7UUFDRDtNQUNGLENBZE0sQ0FBUDtJQWVEOzs7V0EzRUQsZUFBcUI7UUFDbkIsT0FBTzhCLFNBQVA7TUFDRDs7OztFQTRFSDs7OztFQUlBakYscUJBQUMsQ0FBQ3dCLFFBQUQsQ0FBRCxDQUNHZ0csRUFESCxDQUNNN0Isc0JBRE4sRUFDNEJxQywyQkFENUIsRUFDeUQsZUFBSyxFQUFJO0lBQzlELElBQUl1QixNQUFNLEdBQUd4SixLQUFLLENBQUNFLE1BQW5CO0lBQ0EsSUFBTXVKLGFBQWEsR0FBR0QsTUFBdEI7SUFFQSxJQUFJLENBQUN2SixxQkFBQyxDQUFDdUosTUFBRCxDQUFELENBQVUxQyxRQUFWLENBQW1CZSxpQkFBbkIsQ0FBTCxFQUE0QztNQUMxQzJCLE1BQU0sR0FBR3ZKLHFCQUFDLENBQUN1SixNQUFELENBQUQsQ0FBVTlDLE9BQVYsQ0FBa0I2QixlQUFsQixFQUFtQyxDQUFuQyxDQUFUO0lBQ0Q7SUFFRCxJQUFJLENBQUNpQixNQUFELElBQVdBLE1BQU0sQ0FBQ0osWUFBUCxDQUFvQixVQUFwQixDQUFYLElBQThDSSxNQUFNLENBQUNSLFNBQVAsQ0FBaUJDLFFBQWpCLENBQTBCLFVBQTFCLENBQWxELEVBQXlGO01BQ3ZGakosS0FBSyxDQUFDd0gsY0FBTixHQUR1RjtJQUV4RixDQUZELE1BRU87TUFDTCxJQUFNa0MsUUFBUSxHQUFHRixNQUFNLENBQUN2SCxhQUFQLENBQXFCb0csY0FBckIsQ0FBakI7TUFFQSxJQUFJcUIsUUFBUSxLQUFLQSxRQUFRLENBQUNOLFlBQVQsQ0FBc0IsVUFBdEIsS0FBcUNNLFFBQVEsQ0FBQ1YsU0FBVCxDQUFtQkMsUUFBbkIsQ0FBNEIsVUFBNUIsQ0FBMUMsQ0FBWixFQUFnRztRQUM5RmpKLEtBQUssQ0FBQ3dILGNBQU4sR0FEOEY7O1FBRTlGO01BQ0Q7TUFFRCxJQUFJaUMsYUFBYSxDQUFDRSxPQUFkLEtBQTBCLE9BQTFCLElBQXFDSCxNQUFNLENBQUNHLE9BQVAsS0FBbUIsT0FBNUQsRUFBcUU7UUFDbkVuQixNQUFNLENBQUN0QixnQkFBUCxDQUF3QnpILElBQXhCLENBQTZCUSxxQkFBQyxDQUFDdUosTUFBRCxDQUE5QixFQUF3QyxRQUF4QyxFQUFrREMsYUFBYSxDQUFDRSxPQUFkLEtBQTBCLE9BQTVFO01BQ0Q7SUFDRjtFQUNGLENBdkJILEVBd0JHbEMsRUF4QkgsQ0F3Qk1NLHlCQXhCTixFQXdCaUNFLDJCQXhCakMsRUF3QjhELGVBQUssRUFBSTtJQUNuRSxJQUFNdUIsTUFBTSxHQUFHdkoscUJBQUMsQ0FBQ0QsS0FBSyxDQUFDRSxNQUFQLENBQUQsQ0FBZ0J3RyxPQUFoQixDQUF3QjZCLGVBQXhCLEVBQXlDLENBQXpDLENBQWY7SUFDQXRJLHFCQUFDLENBQUN1SixNQUFELENBQUQsQ0FBVUYsV0FBVixDQUFzQnhCLGdCQUF0QixFQUF3QyxlQUFlaEUsSUFBZixDQUFvQjlELEtBQUssQ0FBQzhJLElBQTFCLENBQXhDO0VBQ0QsQ0EzQkg7RUE2QkE3SSxxQkFBQyxDQUFDMkosTUFBRCxDQUFELENBQVVuQyxFQUFWLENBQWFPLHFCQUFiLEVBQWtDLFlBQU07SUFDdEM7SUFFQTtJQUNBLElBQUk2QixPQUFPLEdBQUcsR0FBR0MsS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FBMEIzQiw2QkFBMUIsQ0FBZCxDQUFkO0lBQ0EsS0FBSyxJQUFJNEIsQ0FBQyxHQUFHLENBQVIsRUFBV0MsR0FBRyxHQUFHSixPQUFPLENBQUNLLE1BQTlCLEVBQXNDRixDQUFDLEdBQUdDLEdBQTFDLEVBQStDRCxDQUFDLEVBQWhELEVBQW9EO01BQ2xELElBQU1SLE1BQU0sR0FBR0ssT0FBTyxDQUFDRyxDQUFELENBQXRCO01BQ0EsSUFBTW5CLEtBQUssR0FBR1csTUFBTSxDQUFDdkgsYUFBUCxDQUFxQm9HLGNBQXJCLENBQWQ7TUFDQSxJQUFJUSxLQUFLLENBQUNFLE9BQU4sSUFBaUJGLEtBQUssQ0FBQ08sWUFBTixDQUFtQixTQUFuQixDQUFyQixFQUFvRDtRQUNsREksTUFBTSxDQUFDUixTQUFQLENBQWlCbUIsR0FBakIsQ0FBcUJ2QyxtQkFBckI7TUFDRCxDQUZELE1BRU87UUFDTDRCLE1BQU0sQ0FBQ1IsU0FBUCxDQUFpQi9CLE1BQWpCLENBQXdCVyxtQkFBeEI7TUFDRDtJQUNGLENBYnFDOztJQWdCdENpQyxPQUFPLEdBQUcsR0FBR0MsS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FBMEI1QixzQkFBMUIsQ0FBZCxDQUFWO0lBQ0EsS0FBSyxJQUFJNkIsRUFBQyxHQUFHLENBQVIsRUFBV0MsSUFBRyxHQUFHSixPQUFPLENBQUNLLE1BQTlCLEVBQXNDRixFQUFDLEdBQUdDLElBQTFDLEVBQStDRCxFQUFDLEVBQWhELEVBQW9EO01BQ2xELElBQU1SLE9BQU0sR0FBR0ssT0FBTyxDQUFDRyxFQUFELENBQXRCO01BQ0EsSUFBSVIsT0FBTSxDQUFDMUgsWUFBUCxDQUFvQixjQUFwQixNQUF3QyxNQUE1QyxFQUFvRDtRQUNsRDBILE9BQU0sQ0FBQ1IsU0FBUCxDQUFpQm1CLEdBQWpCLENBQXFCdkMsbUJBQXJCO01BQ0QsQ0FGRCxNQUVPO1FBQ0w0QixPQUFNLENBQUNSLFNBQVAsQ0FBaUIvQixNQUFqQixDQUF3QlcsbUJBQXhCO01BQ0Q7SUFDRjtFQUNGLENBekJEO0VBMkJBOzs7O0VBSUEzSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhdUQsTUFBTSxDQUFDdEIsZ0JBQXBCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5QmMsTUFBekI7RUFDQXZJLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU9rRCxNQUFNLENBQUN0QixnQkFBZDtFQUNELENBSEQ7O0VDdExBOzs7O0VBSUEsSUFBTWpDLE1BQUksR0FBRyxVQUFiO0VBQ0EsSUFBTUMsU0FBTyxHQUFHLE9BQWhCO0VBQ0EsSUFBTUMsVUFBUSxHQUFHLGFBQWpCO0VBQ0EsSUFBTUMsV0FBUyxTQUFPRCxVQUF0QjtFQUNBLElBQU1FLGNBQVksR0FBRyxXQUFyQjtFQUNBLElBQU1DLG9CQUFrQixHQUFHckYscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsQ0FBM0I7RUFDQSxJQUFNbUYsa0JBQWtCLEdBQUcsRUFBM0I7O0VBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsRUFBNUI7O0VBQ0EsSUFBTUMsc0JBQXNCLEdBQUcsR0FBL0I7O0VBQ0EsSUFBTUMsZUFBZSxHQUFHLEVBQXhCO0VBRUEsSUFBTUMsbUJBQW1CLEdBQUcsVUFBNUI7RUFDQSxJQUFNNUMsbUJBQWlCLEdBQUcsUUFBMUI7RUFDQSxJQUFNNkMsZ0JBQWdCLEdBQUcsT0FBekI7RUFDQSxJQUFNQyxnQkFBZ0IsR0FBRyxxQkFBekI7RUFDQSxJQUFNQyxlQUFlLEdBQUcsb0JBQXhCO0VBQ0EsSUFBTUMsZUFBZSxHQUFHLG9CQUF4QjtFQUNBLElBQU1DLGVBQWUsR0FBRyxvQkFBeEI7RUFDQSxJQUFNQyx3QkFBd0IsR0FBRyxlQUFqQztFQUVBLElBQU1DLGNBQWMsR0FBRyxNQUF2QjtFQUNBLElBQU1DLGNBQWMsR0FBRyxNQUF2QjtFQUNBLElBQU1DLGNBQWMsR0FBRyxNQUF2QjtFQUNBLElBQU1DLGVBQWUsR0FBRyxPQUF4QjtFQUVBLElBQU1DLFdBQVcsYUFBVy9GLFdBQTVCO0VBQ0EsSUFBTWdHLFVBQVUsWUFBVWhHLFdBQTFCO0VBQ0EsSUFBTWlHLGFBQWEsZUFBYWpHLFdBQWhDO0VBQ0EsSUFBTWtHLGdCQUFnQixrQkFBZ0JsRyxXQUF0QztFQUNBLElBQU1tRyxnQkFBZ0Isa0JBQWdCbkcsV0FBdEM7RUFDQSxJQUFNb0csZ0JBQWdCLGtCQUFnQnBHLFdBQXRDO0VBQ0EsSUFBTXFHLGVBQWUsaUJBQWVyRyxXQUFwQztFQUNBLElBQU1zRyxjQUFjLGdCQUFjdEcsV0FBbEM7RUFDQSxJQUFNdUcsaUJBQWlCLG1CQUFpQnZHLFdBQXhDO0VBQ0EsSUFBTXdHLGVBQWUsaUJBQWV4RyxXQUFwQztFQUNBLElBQU15RyxnQkFBZ0IsaUJBQWV6RyxXQUFyQztFQUNBLElBQU00QyxxQkFBbUIsWUFBVTVDLFdBQVYsR0FBc0JDLGNBQS9DO0VBQ0EsSUFBTU8sc0JBQW9CLGFBQVdSLFdBQVgsR0FBdUJDLGNBQWpEO0VBRUEsSUFBTWlELGlCQUFlLEdBQUcsU0FBeEI7RUFDQSxJQUFNd0Qsb0JBQW9CLEdBQUcsdUJBQTdCO0VBQ0EsSUFBTUMsYUFBYSxHQUFHLGdCQUF0QjtFQUNBLElBQU1DLGlCQUFpQixHQUFHLG9CQUExQjtFQUNBLElBQU1DLGtCQUFrQixHQUFHLDBDQUEzQjtFQUNBLElBQU1DLG1CQUFtQixHQUFHLHNCQUE1QjtFQUNBLElBQU1DLG1CQUFtQixHQUFHLCtCQUE1QjtFQUNBLElBQU1DLGtCQUFrQixHQUFHLHdCQUEzQjtFQUVBLElBQU1DLFNBQU8sR0FBRztJQUNkQyxRQUFRLEVBQUUsSUFESTtJQUVkQyxRQUFRLEVBQUUsSUFGSTtJQUdkQyxLQUFLLEVBQUUsS0FITztJQUlkQyxLQUFLLEVBQUUsT0FKTztJQUtkQyxJQUFJLEVBQUUsSUFMUTtJQU1kQyxLQUFLLEVBQUU7RUFOTyxDQUFoQjtFQVNBLElBQU1DLGFBQVcsR0FBRztJQUNsQk4sUUFBUSxFQUFFLGtCQURRO0lBRWxCQyxRQUFRLEVBQUUsU0FGUTtJQUdsQkMsS0FBSyxFQUFFLGtCQUhXO0lBSWxCQyxLQUFLLEVBQUUsa0JBSlc7SUFLbEJDLElBQUksRUFBRSxTQUxZO0lBTWxCQyxLQUFLLEVBQUU7RUFOVyxDQUFwQjtFQVNBLElBQU1FLFdBQVcsR0FBRztJQUNsQkMsS0FBSyxFQUFFLE9BRFc7SUFFbEJDLEdBQUcsRUFBRTtFQUZhLENBQXBCO0VBS0E7Ozs7TUFJTUM7SUFDSixrQkFBWXBMLE9BQVosRUFBcUJ3QixNQUFyQixFQUE2QjtNQUMzQixLQUFLNkosTUFBTCxHQUFjLElBQWQ7TUFDQSxLQUFLQyxTQUFMLEdBQWlCLElBQWpCO01BQ0EsS0FBS0MsY0FBTCxHQUFzQixJQUF0QjtNQUNBLEtBQUtDLFNBQUwsR0FBaUIsS0FBakI7TUFDQSxLQUFLQyxVQUFMLEdBQWtCLEtBQWxCO01BQ0EsS0FBS0MsWUFBTCxHQUFvQixJQUFwQjtNQUNBLEtBQUtDLFdBQUwsR0FBbUIsQ0FBbkI7TUFDQSxLQUFLQyxXQUFMLEdBQW1CLENBQW5CO01BRUEsS0FBS0MsT0FBTCxHQUFlLEtBQUtDLFVBQUwsQ0FBZ0J0SyxNQUFoQixDQUFmO01BQ0EsS0FBSzJDLFFBQUwsR0FBZ0JuRSxPQUFoQjtNQUNBLEtBQUsrTCxrQkFBTCxHQUEwQixLQUFLNUgsUUFBTCxDQUFjOUQsYUFBZCxDQUE0QmlLLG1CQUE1QixDQUExQjtNQUNBLEtBQUswQixlQUFMLEdBQXVCLGtCQUFrQm5NLFFBQVEsQ0FBQ3lDLGVBQTNCLElBQThDMkosU0FBUyxDQUFDQyxjQUFWLEdBQTJCLENBQWhHO01BQ0EsS0FBS0MsYUFBTCxHQUFxQmhMLE9BQU8sQ0FBQzZHLE1BQU0sQ0FBQ29FLFlBQVAsSUFBdUJwRSxNQUFNLENBQUNxRSxjQUEvQixDQUE1QjtNQUVBLEtBQUtDLGtCQUFMO0lBQ0Q7Ozs7SUFXRDtXQUNBQyx1QkFBTztNQUNMLElBQUksQ0FBQyxLQUFLZCxVQUFWLEVBQXNCO1FBQ3BCLEtBQUtlLE1BQUwsQ0FBWXJELGNBQVo7TUFDRDtJQUNGO1dBRURzRCw2Q0FBa0I7TUFDaEIsSUFBTWpILFFBQVEsR0FBR25ILHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBbEIsQ0FEZ0I7TUFHaEI7O01BQ0EsSUFBSSxDQUFDdEUsUUFBUSxDQUFDNk0sTUFBVixJQUNEbEgsUUFBUSxDQUFDakgsRUFBVCxDQUFZLFVBQVosS0FBMkJpSCxRQUFRLENBQUMvRSxHQUFULENBQWEsWUFBYixNQUErQixRQUQ3RCxFQUN3RTtRQUN0RSxLQUFLOEwsSUFBTDtNQUNEO0lBQ0Y7V0FFREksdUJBQU87TUFDTCxJQUFJLENBQUMsS0FBS2xCLFVBQVYsRUFBc0I7UUFDcEIsS0FBS2UsTUFBTCxDQUFZcEQsY0FBWjtNQUNEO0lBQ0Y7V0FFRHlCLHVCQUFNek0sS0FBTixFQUFhO01BQ1gsSUFBSSxDQUFDQSxLQUFMLEVBQVk7UUFDVixLQUFLb04sU0FBTCxHQUFpQixJQUFqQjtNQUNEO01BRUQsSUFBSSxLQUFLckgsUUFBTCxDQUFjOUQsYUFBZCxDQUE0QmdLLGtCQUE1QixDQUFKLEVBQXFEO1FBQ25EcEwsSUFBSSxDQUFDRSxvQkFBTCxDQUEwQixLQUFLZ0YsUUFBL0I7UUFDQSxLQUFLeUksS0FBTCxDQUFXLElBQVg7TUFDRDtNQUVEQyxhQUFhLENBQUMsS0FBS3ZCLFNBQU4sQ0FBYjtNQUNBLEtBQUtBLFNBQUwsR0FBaUIsSUFBakI7SUFDRDtXQUVEc0IsdUJBQU14TyxLQUFOLEVBQWE7TUFDWCxJQUFJLENBQUNBLEtBQUwsRUFBWTtRQUNWLEtBQUtvTixTQUFMLEdBQWlCLEtBQWpCO01BQ0Q7TUFFRCxJQUFJLEtBQUtGLFNBQVQsRUFBb0I7UUFDbEJ1QixhQUFhLENBQUMsS0FBS3ZCLFNBQU4sQ0FBYjtRQUNBLEtBQUtBLFNBQUwsR0FBaUIsSUFBakI7TUFDRDtNQUVELElBQUksS0FBS08sT0FBTCxDQUFhbkIsUUFBYixJQUF5QixDQUFDLEtBQUtjLFNBQW5DLEVBQThDO1FBQzVDLEtBQUtzQixlQUFMO1FBRUEsS0FBS3hCLFNBQUwsR0FBaUJ5QixXQUFXLENBQzFCLENBQUNsTixRQUFRLENBQUNtTixlQUFULEdBQTJCLEtBQUtQLGVBQWhDLEdBQWtELEtBQUtGLElBQXhELEVBQThEVSxJQUE5RCxDQUFtRSxJQUFuRSxDQUQwQixFQUUxQixLQUFLcEIsT0FBTCxDQUFhbkIsUUFGYSxDQUE1QjtNQUlEO0lBQ0Y7V0FFRHdDLGlCQUFHQyxLQUFILEVBQVU7TUFBQTtNQUNSLEtBQUs1QixjQUFMLEdBQXNCLEtBQUtwSCxRQUFMLENBQWM5RCxhQUFkLENBQTRCNkosb0JBQTVCLENBQXRCO01BRUEsSUFBTWtELFdBQVcsR0FBRyxLQUFLQyxhQUFMLENBQW1CLEtBQUs5QixjQUF4QixDQUFwQjtNQUVBLElBQUk0QixLQUFLLEdBQUcsS0FBSzlCLE1BQUwsQ0FBWS9DLE1BQVosR0FBcUIsQ0FBN0IsSUFBa0M2RSxLQUFLLEdBQUcsQ0FBOUMsRUFBaUQ7UUFDL0M7TUFDRDtNQUVELElBQUksS0FBSzFCLFVBQVQsRUFBcUI7UUFDbkJwTixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJuRixHQUFqQixDQUFxQndLLFVBQXJCLEVBQWlDO1VBQUEsT0FBTXBLLEtBQUksQ0FBQzhOLEVBQUwsQ0FBUUMsS0FBUixDQUFOO1FBQUEsQ0FBakM7UUFDQTtNQUNEO01BRUQsSUFBSUMsV0FBVyxLQUFLRCxLQUFwQixFQUEyQjtRQUN6QixLQUFLdEMsS0FBTDtRQUNBLEtBQUsrQixLQUFMO1FBQ0E7TUFDRDtNQUVELElBQU1VLFNBQVMsR0FBR0gsS0FBSyxHQUFHQyxXQUFSLEdBQ2hCakUsY0FEZ0IsR0FFaEJDLGNBRkY7TUFJQSxLQUFLb0QsTUFBTCxDQUFZYyxTQUFaLEVBQXVCLEtBQUtqQyxNQUFMLENBQVk4QixLQUFaLENBQXZCO0lBQ0Q7V0FFRHhJLDZCQUFVO01BQ1J0RyxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJvSixHQUFqQixDQUFxQi9KLFdBQXJCO01BQ0FuRixxQkFBQyxDQUFDdUcsVUFBRixDQUFhLEtBQUtULFFBQWxCLEVBQTRCWixVQUE1QjtNQUVBLEtBQUs4SCxNQUFMLEdBQWMsSUFBZDtNQUNBLEtBQUtRLE9BQUwsR0FBZSxJQUFmO01BQ0EsS0FBSzFILFFBQUwsR0FBZ0IsSUFBaEI7TUFDQSxLQUFLbUgsU0FBTCxHQUFpQixJQUFqQjtNQUNBLEtBQUtFLFNBQUwsR0FBaUIsSUFBakI7TUFDQSxLQUFLQyxVQUFMLEdBQWtCLElBQWxCO01BQ0EsS0FBS0YsY0FBTCxHQUFzQixJQUF0QjtNQUNBLEtBQUtRLGtCQUFMLEdBQTBCLElBQTFCO0lBQ0Q7SUFBQTs7V0FHREQsaUNBQVd0SyxNQUFYLEVBQW1CO01BQ2pCQSxNQUFNLGtCQUNEaUosU0FEQyxFQUVEakosTUFGQyxDQUFOO01BSUF2QyxJQUFJLENBQUNxQyxlQUFMLENBQXFCK0IsTUFBckIsRUFBMkI3QixNQUEzQixFQUFtQ3dKLGFBQW5DO01BQ0EsT0FBT3hKLE1BQVA7SUFDRDtXQUVEZ00sdUNBQWU7TUFDYixJQUFNQyxTQUFTLEdBQUc5TixJQUFJLENBQUMrTixHQUFMLENBQVMsS0FBSzlCLFdBQWQsQ0FBbEI7TUFFQSxJQUFJNkIsU0FBUyxJQUFJOUUsZUFBakIsRUFBa0M7UUFDaEM7TUFDRDtNQUVELElBQU0yRSxTQUFTLEdBQUdHLFNBQVMsR0FBRyxLQUFLN0IsV0FBbkM7TUFFQSxLQUFLQSxXQUFMLEdBQW1CLENBQW5CLENBVGE7O01BWWIsSUFBSTBCLFNBQVMsR0FBRyxDQUFoQixFQUFtQjtRQUNqQixLQUFLWCxJQUFMO01BQ0QsQ0FkWTs7TUFpQmIsSUFBSVcsU0FBUyxHQUFHLENBQWhCLEVBQW1CO1FBQ2pCLEtBQUtmLElBQUw7TUFDRDtJQUNGO1dBRURELG1EQUFxQjtNQUFBO01BQ25CLElBQUksS0FBS1QsT0FBTCxDQUFhbEIsUUFBakIsRUFBMkI7UUFDekJ0TSxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUIwQixFQUFqQixDQUFvQjRELGFBQXBCLEVBQW1DLGVBQUs7VUFBQSxPQUFJa0UsTUFBSSxDQUFDQyxRQUFMLENBQWN4UCxLQUFkLENBQUo7UUFBQSxDQUF4QztNQUNEO01BRUQsSUFBSSxLQUFLeU4sT0FBTCxDQUFhaEIsS0FBYixLQUF1QixPQUEzQixFQUFvQztRQUNsQ3hNLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUNHMEIsRUFESCxDQUNNNkQsZ0JBRE4sRUFDd0IsZUFBSztVQUFBLE9BQUlpRSxNQUFJLENBQUM5QyxLQUFMLENBQVd6TSxLQUFYLENBQUo7UUFBQSxDQUQ3QixFQUVHeUgsRUFGSCxDQUVNOEQsZ0JBRk4sRUFFd0IsZUFBSztVQUFBLE9BQUlnRSxNQUFJLENBQUNmLEtBQUwsQ0FBV3hPLEtBQVgsQ0FBSjtRQUFBLENBRjdCO01BR0Q7TUFFRCxJQUFJLEtBQUt5TixPQUFMLENBQWFkLEtBQWpCLEVBQXdCO1FBQ3RCLEtBQUs4Qyx1QkFBTDtNQUNEO0lBQ0Y7V0FFREEsNkRBQTBCO01BQUE7TUFDeEIsSUFBSSxDQUFDLEtBQUs3QixlQUFWLEVBQTJCO1FBQ3pCO01BQ0Q7TUFFRCxJQUFNOEIsS0FBSyxHQUFHLFNBQVJBLEtBQVEsTUFBSyxFQUFJO1FBQ3JCLElBQUlDLE1BQUksQ0FBQzVCLGFBQUwsSUFBc0JsQixXQUFXLENBQUM3TSxLQUFLLENBQUM0UCxhQUFOLENBQW9CQyxXQUFwQixDQUFnQzdMLFdBQWhDLEVBQUQsQ0FBckMsRUFBc0Y7VUFDcEYyTCxNQUFJLENBQUNwQyxXQUFMLEdBQW1Cdk4sS0FBSyxDQUFDNFAsYUFBTixDQUFvQkUsT0FBdkM7UUFDRCxDQUZELE1BRU8sSUFBSSxDQUFDSCxNQUFJLENBQUM1QixhQUFWLEVBQXlCO1VBQzlCNEIsTUFBSSxDQUFDcEMsV0FBTCxHQUFtQnZOLEtBQUssQ0FBQzRQLGFBQU4sQ0FBb0JHLE9BQXBCLENBQTRCLENBQTVCLEVBQStCRCxPQUFsRDtRQUNEO01BQ0YsQ0FORDtNQVFBLElBQU1FLElBQUksR0FBRyxTQUFQQSxJQUFPLE1BQUssRUFBSTtRQUNwQjtRQUNBTCxNQUFJLENBQUNuQyxXQUFMLEdBQW1CeE4sS0FBSyxDQUFDNFAsYUFBTixDQUFvQkcsT0FBcEIsSUFBK0IvUCxLQUFLLENBQUM0UCxhQUFOLENBQW9CRyxPQUFwQixDQUE0QjdGLE1BQTVCLEdBQXFDLENBQXBFLEdBQ2pCLENBRGlCLEdBRWpCbEssS0FBSyxDQUFDNFAsYUFBTixDQUFvQkcsT0FBcEIsQ0FBNEIsQ0FBNUIsRUFBK0JELE9BQS9CLEdBQXlDSCxNQUFJLENBQUNwQyxXQUZoRDtNQUdELENBTEQ7TUFPQSxJQUFNMEMsR0FBRyxHQUFHLFNBQU5BLEdBQU0sTUFBSyxFQUFJO1FBQ25CLElBQUlOLE1BQUksQ0FBQzVCLGFBQUwsSUFBc0JsQixXQUFXLENBQUM3TSxLQUFLLENBQUM0UCxhQUFOLENBQW9CQyxXQUFwQixDQUFnQzdMLFdBQWhDLEVBQUQsQ0FBckMsRUFBc0Y7VUFDcEYyTCxNQUFJLENBQUNuQyxXQUFMLEdBQW1CeE4sS0FBSyxDQUFDNFAsYUFBTixDQUFvQkUsT0FBcEIsR0FBOEJILE1BQUksQ0FBQ3BDLFdBQXREO1FBQ0Q7UUFFRG9DLE1BQUksQ0FBQ1AsWUFBTDtRQUNBLElBQUlPLE1BQUksQ0FBQ2xDLE9BQUwsQ0FBYWhCLEtBQWIsS0FBdUIsT0FBM0IsRUFBb0M7VUFDbEM7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFFQWtELE1BQUksQ0FBQ2xELEtBQUw7VUFDQSxJQUFJa0QsTUFBSSxDQUFDckMsWUFBVCxFQUF1QjtZQUNyQjRDLFlBQVksQ0FBQ1AsTUFBSSxDQUFDckMsWUFBTixDQUFaO1VBQ0Q7VUFFRHFDLE1BQUksQ0FBQ3JDLFlBQUwsR0FBb0J4TSxVQUFVLENBQUMsZUFBSztZQUFBLE9BQUk2TyxNQUFJLENBQUNuQixLQUFMLENBQVd4TyxLQUFYLENBQUo7VUFBQSxDQUFOLEVBQTZCc0ssc0JBQXNCLEdBQUdxRixNQUFJLENBQUNsQyxPQUFMLENBQWFuQixRQUFuRSxDQUE5QjtRQUNEO01BQ0YsQ0F0QkQ7TUF3QkFyTSxxQkFBQyxDQUFDLEtBQUs4RixRQUFMLENBQWNnRSxnQkFBZCxDQUErQmlDLGlCQUEvQixDQUFELENBQUQsQ0FDR3ZFLEVBREgsQ0FDTW9FLGdCQUROLEVBQ3dCLFdBQUM7UUFBQSxPQUFJc0UsQ0FBQyxDQUFDM0ksY0FBRixFQUFKO01BQUEsQ0FEekI7TUFHQSxJQUFJLEtBQUt1RyxhQUFULEVBQXdCO1FBQ3RCOU4scUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCMEIsRUFBakIsQ0FBb0JrRSxpQkFBcEIsRUFBdUMsZUFBSztVQUFBLE9BQUkrRCxLQUFLLENBQUMxUCxLQUFELENBQVQ7UUFBQSxDQUE1QztRQUNBQyxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUIwQixFQUFqQixDQUFvQm1FLGVBQXBCLEVBQXFDLGVBQUs7VUFBQSxPQUFJcUUsR0FBRyxDQUFDalEsS0FBRCxDQUFQO1FBQUEsQ0FBMUM7UUFFQSxLQUFLK0YsUUFBTCxDQUFjaUQsU0FBZCxDQUF3Qm1CLEdBQXhCLENBQTRCVyx3QkFBNUI7TUFDRCxDQUxELE1BS087UUFDTDdLLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQjBCLEVBQWpCLENBQW9CK0QsZ0JBQXBCLEVBQXNDLGVBQUs7VUFBQSxPQUFJa0UsS0FBSyxDQUFDMVAsS0FBRCxDQUFUO1FBQUEsQ0FBM0M7UUFDQUMscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCMEIsRUFBakIsQ0FBb0JnRSxlQUFwQixFQUFxQyxlQUFLO1VBQUEsT0FBSXVFLElBQUksQ0FBQ2hRLEtBQUQsQ0FBUjtRQUFBLENBQTFDO1FBQ0FDLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQjBCLEVBQWpCLENBQW9CaUUsY0FBcEIsRUFBb0MsZUFBSztVQUFBLE9BQUl1RSxHQUFHLENBQUNqUSxLQUFELENBQVA7UUFBQSxDQUF6QztNQUNEO0lBQ0Y7V0FFRHdQLDZCQUFTeFAsS0FBVCxFQUFnQjtNQUNkLElBQUksa0JBQWtCOEQsSUFBbEIsQ0FBdUI5RCxLQUFLLENBQUNFLE1BQU4sQ0FBYXlKLE9BQXBDLENBQUosRUFBa0Q7UUFDaEQ7TUFDRDtNQUVELFFBQVEzSixLQUFLLENBQUNvUSxLQUFkO1FBQ0UsS0FBS2hHLGtCQUFMO1VBQ0VwSyxLQUFLLENBQUN3SCxjQUFOO1VBQ0EsS0FBSytHLElBQUw7VUFDQTtRQUNGLEtBQUtsRSxtQkFBTDtVQUNFckssS0FBSyxDQUFDd0gsY0FBTjtVQUNBLEtBQUsyRyxJQUFMO1VBQ0E7TUFBQTtJQUdMO1dBRURjLHVDQUFjck4sT0FBZCxFQUF1QjtNQUNyQixLQUFLcUwsTUFBTCxHQUFjckwsT0FBTyxJQUFJQSxPQUFPLENBQUMyQyxVQUFuQixHQUNaLEdBQUd1RixLQUFILENBQVNySyxJQUFULENBQWNtQyxPQUFPLENBQUMyQyxVQUFSLENBQW1Cd0YsZ0JBQW5CLENBQW9DZ0MsYUFBcEMsQ0FBZCxDQURZLEdBRVosRUFGRjtNQUdBLE9BQU8sS0FBS2tCLE1BQUwsQ0FBWW9ELE9BQVosQ0FBb0J6TyxPQUFwQixDQUFQO0lBQ0Q7V0FFRDBPLG1EQUFvQnBCLFNBQXBCLEVBQStCaEcsYUFBL0IsRUFBOEM7TUFDNUMsSUFBTXFILGVBQWUsR0FBR3JCLFNBQVMsS0FBS25FLGNBQXRDO01BQ0EsSUFBTXlGLGVBQWUsR0FBR3RCLFNBQVMsS0FBS2xFLGNBQXRDO01BQ0EsSUFBTWdFLFdBQVcsR0FBRyxLQUFLQyxhQUFMLENBQW1CL0YsYUFBbkIsQ0FBcEI7TUFDQSxJQUFNdUgsYUFBYSxHQUFHLEtBQUt4RCxNQUFMLENBQVkvQyxNQUFaLEdBQXFCLENBQTNDO01BQ0EsSUFBTXdHLGFBQWEsR0FBR0YsZUFBZSxJQUFJeEIsV0FBVyxLQUFLLENBQW5DLElBQ0V1QixlQUFlLElBQUl2QixXQUFXLEtBQUt5QixhQUQzRDtNQUdBLElBQUlDLGFBQWEsSUFBSSxDQUFDLEtBQUtqRCxPQUFMLENBQWFmLElBQW5DLEVBQXlDO1FBQ3ZDLE9BQU94RCxhQUFQO01BQ0Q7TUFFRCxJQUFNeUgsS0FBSyxHQUFHekIsU0FBUyxLQUFLbEUsY0FBZCxHQUErQixDQUFDLENBQWhDLEdBQW9DLENBQWxEO01BQ0EsSUFBTTRGLFNBQVMsR0FBRyxDQUFDNUIsV0FBVyxHQUFHMkIsS0FBZixJQUF3QixLQUFLMUQsTUFBTCxDQUFZL0MsTUFBdEQ7TUFFQSxPQUFPMEcsU0FBUyxLQUFLLENBQUMsQ0FBZixHQUNMLEtBQUszRCxNQUFMLENBQVksS0FBS0EsTUFBTCxDQUFZL0MsTUFBWixHQUFxQixDQUFqQyxDQURLLEdBQ2lDLEtBQUsrQyxNQUFMLENBQVkyRCxTQUFaLENBRHhDO0lBRUQ7V0FFREMsaURBQW1CQyxhQUFuQixFQUFrQ0Msa0JBQWxDLEVBQXNEO01BQ3BELElBQU1DLFdBQVcsR0FBRyxLQUFLL0IsYUFBTCxDQUFtQjZCLGFBQW5CLENBQXBCO01BQ0EsSUFBTUcsU0FBUyxHQUFHLEtBQUtoQyxhQUFMLENBQW1CLEtBQUtsSixRQUFMLENBQWM5RCxhQUFkLENBQTRCNkosb0JBQTVCLENBQW5CLENBQWxCO01BQ0EsSUFBTW9GLFVBQVUsR0FBR2pSLHFCQUFDLENBQUMyRyxLQUFGLENBQVF1RSxXQUFSLEVBQXFCO1FBQ3RDMkYsYUFBYSxFQUFiQSxhQURzQztRQUV0QzVCLFNBQVMsRUFBRTZCLGtCQUYyQjtRQUd0Q0ksSUFBSSxFQUFFRixTQUhnQztRQUl0Q25DLEVBQUUsRUFBRWtDO01BSmtDLENBQXJCLENBQW5CO01BT0EvUSxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJsRCxPQUFqQixDQUF5QnFPLFVBQXpCO01BRUEsT0FBT0EsVUFBUDtJQUNEO1dBRURFLGlFQUEyQnhQLE9BQTNCLEVBQW9DO01BQ2xDLElBQUksS0FBSytMLGtCQUFULEVBQTZCO1FBQzNCLElBQU0wRCxVQUFVLEdBQUcsR0FBR3ZILEtBQUgsQ0FBU3JLLElBQVQsQ0FBYyxLQUFLa08sa0JBQUwsQ0FBd0I1RCxnQkFBeEIsQ0FBeUN6QixpQkFBekMsQ0FBZCxDQUFuQjtRQUNBckkscUJBQUMsQ0FBQ29SLFVBQUQsQ0FBRCxDQUFjeEssV0FBZCxDQUEwQmUsbUJBQTFCO1FBRUEsSUFBTTBKLGFBQWEsR0FBRyxLQUFLM0Qsa0JBQUwsQ0FBd0I0RCxRQUF4QixDQUNwQixLQUFLdEMsYUFBTCxDQUFtQnJOLE9BQW5CLENBRG9CLENBQXRCO1FBSUEsSUFBSTBQLGFBQUosRUFBbUI7VUFDakJyUixxQkFBQyxDQUFDcVIsYUFBRCxDQUFELENBQWlCRSxRQUFqQixDQUEwQjVKLG1CQUExQjtRQUNEO01BQ0Y7SUFDRjtXQUVEOEcsNkNBQWtCO01BQ2hCLElBQU05TSxPQUFPLEdBQUcsS0FBS3VMLGNBQUwsSUFBdUIsS0FBS3BILFFBQUwsQ0FBYzlELGFBQWQsQ0FBNEI2SixvQkFBNUIsQ0FBdkM7TUFFQSxJQUFJLENBQUNsSyxPQUFMLEVBQWM7UUFDWjtNQUNEO01BRUQsSUFBTTZQLGVBQWUsR0FBR0MsUUFBUSxDQUFDOVAsT0FBTyxDQUFDRSxZQUFSLENBQXFCLGVBQXJCLENBQUQsRUFBd0MsRUFBeEMsQ0FBaEM7TUFFQSxJQUFJMlAsZUFBSixFQUFxQjtRQUNuQixLQUFLaEUsT0FBTCxDQUFha0UsZUFBYixHQUErQixLQUFLbEUsT0FBTCxDQUFha0UsZUFBYixJQUFnQyxLQUFLbEUsT0FBTCxDQUFhbkIsUUFBNUU7UUFDQSxLQUFLbUIsT0FBTCxDQUFhbkIsUUFBYixHQUF3Qm1GLGVBQXhCO01BQ0QsQ0FIRCxNQUdPO1FBQ0wsS0FBS2hFLE9BQUwsQ0FBYW5CLFFBQWIsR0FBd0IsS0FBS21CLE9BQUwsQ0FBYWtFLGVBQWIsSUFBZ0MsS0FBS2xFLE9BQUwsQ0FBYW5CLFFBQXJFO01BQ0Q7SUFDRjtXQUVEOEIseUJBQU9jLFNBQVAsRUFBa0J0TixPQUFsQixFQUEyQjtNQUFBO01BQ3pCLElBQU1zSCxhQUFhLEdBQUcsS0FBS25ELFFBQUwsQ0FBYzlELGFBQWQsQ0FBNEI2SixvQkFBNUIsQ0FBdEI7TUFDQSxJQUFNOEYsa0JBQWtCLEdBQUcsS0FBSzNDLGFBQUwsQ0FBbUIvRixhQUFuQixDQUEzQjtNQUNBLElBQU0ySSxXQUFXLEdBQUdqUSxPQUFPLElBQUlzSCxhQUFhLElBQzFDLEtBQUtvSCxtQkFBTCxDQUF5QnBCLFNBQXpCLEVBQW9DaEcsYUFBcEMsQ0FERjtNQUVBLElBQU00SSxnQkFBZ0IsR0FBRyxLQUFLN0MsYUFBTCxDQUFtQjRDLFdBQW5CLENBQXpCO01BQ0EsSUFBTUUsU0FBUyxHQUFHaFAsT0FBTyxDQUFDLEtBQUttSyxTQUFOLENBQXpCO01BRUEsSUFBSThFLG9CQUFKO01BQ0EsSUFBSUMsY0FBSjtNQUNBLElBQUlsQixrQkFBSjtNQUVBLElBQUk3QixTQUFTLEtBQUtuRSxjQUFsQixFQUFrQztRQUNoQ2lILG9CQUFvQixHQUFHckgsZUFBdkI7UUFDQXNILGNBQWMsR0FBR3JILGVBQWpCO1FBQ0FtRyxrQkFBa0IsR0FBRzlGLGNBQXJCO01BQ0QsQ0FKRCxNQUlPO1FBQ0wrRyxvQkFBb0IsR0FBR3RILGdCQUF2QjtRQUNBdUgsY0FBYyxHQUFHcEgsZUFBakI7UUFDQWtHLGtCQUFrQixHQUFHN0YsZUFBckI7TUFDRDtNQUVELElBQUkyRyxXQUFXLElBQUk1UixxQkFBQyxDQUFDNFIsV0FBRCxDQUFELENBQWUvSyxRQUFmLENBQXdCYyxtQkFBeEIsQ0FBbkIsRUFBK0Q7UUFDN0QsS0FBS3lGLFVBQUwsR0FBa0IsS0FBbEI7UUFDQTtNQUNEO01BRUQsSUFBTTZELFVBQVUsR0FBRyxLQUFLTCxrQkFBTCxDQUF3QmdCLFdBQXhCLEVBQXFDZCxrQkFBckMsQ0FBbkI7TUFDQSxJQUFJRyxVQUFVLENBQUM3SyxrQkFBWCxFQUFKLEVBQXFDO1FBQ25DO01BQ0Q7TUFFRCxJQUFJLENBQUM2QyxhQUFELElBQWtCLENBQUMySSxXQUF2QixFQUFvQztRQUNsQztRQUNBO01BQ0Q7TUFFRCxLQUFLeEUsVUFBTCxHQUFrQixJQUFsQjtNQUVBLElBQUkwRSxTQUFKLEVBQWU7UUFDYixLQUFLdEYsS0FBTDtNQUNEO01BRUQsS0FBSzJFLDBCQUFMLENBQWdDUyxXQUFoQztNQUNBLEtBQUsxRSxjQUFMLEdBQXNCMEUsV0FBdEI7TUFFQSxJQUFNSyxTQUFTLEdBQUdqUyxxQkFBQyxDQUFDMkcsS0FBRixDQUFRd0UsVUFBUixFQUFvQjtRQUNwQzBGLGFBQWEsRUFBRWUsV0FEcUI7UUFFcEMzQyxTQUFTLEVBQUU2QixrQkFGeUI7UUFHcENJLElBQUksRUFBRVMsa0JBSDhCO1FBSXBDOUMsRUFBRSxFQUFFZ0Q7TUFKZ0MsQ0FBcEIsQ0FBbEI7TUFPQSxJQUFJN1IscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQjJELGdCQUExQixDQUFKLEVBQWlEO1FBQy9DeEsscUJBQUMsQ0FBQzRSLFdBQUQsQ0FBRCxDQUFlTCxRQUFmLENBQXdCUyxjQUF4QjtRQUVBcFIsSUFBSSxDQUFDOEIsTUFBTCxDQUFZa1AsV0FBWjtRQUVBNVIscUJBQUMsQ0FBQ2lKLGFBQUQsQ0FBRCxDQUFpQnNJLFFBQWpCLENBQTBCUSxvQkFBMUI7UUFDQS9SLHFCQUFDLENBQUM0UixXQUFELENBQUQsQ0FBZUwsUUFBZixDQUF3QlEsb0JBQXhCO1FBRUEsSUFBTTVQLGtCQUFrQixHQUFHdkIsSUFBSSxDQUFDc0IsZ0NBQUwsQ0FBc0MrRyxhQUF0QyxDQUEzQjtRQUVBakoscUJBQUMsQ0FBQ2lKLGFBQUQsQ0FBRCxDQUNHdEksR0FESCxDQUNPQyxJQUFJLENBQUMxQixjQURaLEVBQzRCLFlBQU07VUFDOUJjLHFCQUFDLENBQUM0UixXQUFELENBQUQsQ0FDR2hMLFdBREgsQ0FDa0JtTCxvQkFEbEIsU0FDMENDLGNBRDFDLEVBRUdULFFBRkgsQ0FFWTVKLG1CQUZaO1VBSUEzSCxxQkFBQyxDQUFDaUosYUFBRCxDQUFELENBQWlCckMsV0FBakIsQ0FBZ0NlLG1CQUFoQyxTQUFxRHFLLGNBQXJELFNBQXVFRCxvQkFBdkU7VUFFQUcsTUFBSSxDQUFDOUUsVUFBTCxHQUFrQixLQUFsQjtVQUVBdk0sVUFBVSxDQUFDO1lBQUEsT0FBTWIscUJBQUMsQ0FBQ2tTLE1BQUksQ0FBQ3BNLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCcVAsU0FBekIsQ0FBTjtVQUFBLENBQUQsRUFBNEMsQ0FBNUMsQ0FBVjtRQUNELENBWEgsRUFZRy9RLG9CQVpILENBWXdCaUIsa0JBWnhCO01BYUQsQ0F2QkQsTUF1Qk87UUFDTG5DLHFCQUFDLENBQUNpSixhQUFELENBQUQsQ0FBaUJyQyxXQUFqQixDQUE2QmUsbUJBQTdCO1FBQ0EzSCxxQkFBQyxDQUFDNFIsV0FBRCxDQUFELENBQWVMLFFBQWYsQ0FBd0I1SixtQkFBeEI7UUFFQSxLQUFLeUYsVUFBTCxHQUFrQixLQUFsQjtRQUNBcE4scUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJxUCxTQUF6QjtNQUNEO01BRUQsSUFBSUgsU0FBSixFQUFlO1FBQ2IsS0FBS3ZELEtBQUw7TUFDRDtJQUNGO0lBQUE7O2FBR010SCxtQkFBUCwwQkFBd0I5RCxNQUF4QixFQUFnQztNQUM5QixPQUFPLEtBQUsrRCxJQUFMLENBQVUsWUFBWTtRQUMzQixJQUFJRSxJQUFJLEdBQUdwSCxxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRb0gsSUFBUixDQUFhbEMsVUFBYixDQUFYO1FBQ0EsSUFBSXNJLE9BQU8sa0JBQ05wQixTQURNLEVBRU5wTSxxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRb0gsSUFBUixFQUZNLENBQVg7UUFLQSxJQUFJLFFBQU9qRSxNQUFQLE1BQWtCLFFBQXRCLEVBQWdDO1VBQzlCcUssT0FBTyxrQkFDRkEsT0FERSxFQUVGckssTUFGRSxDQUFQO1FBSUQ7UUFFRCxJQUFNZ1AsTUFBTSxHQUFHLE9BQU9oUCxNQUFQLEtBQWtCLFFBQWxCLEdBQTZCQSxNQUE3QixHQUFzQ3FLLE9BQU8sQ0FBQ2pCLEtBQTdEO1FBRUEsSUFBSSxDQUFDbkYsSUFBTCxFQUFXO1VBQ1RBLElBQUksR0FBRyxJQUFJMkYsUUFBSixDQUFhLElBQWIsRUFBbUJTLE9BQW5CLENBQVA7VUFDQXhOLHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLENBQWFsQyxVQUFiLEVBQXVCa0MsSUFBdkI7UUFDRDtRQUVELElBQUksT0FBT2pFLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDOUJpRSxJQUFJLENBQUN5SCxFQUFMLENBQVExTCxNQUFSO1FBQ0QsQ0FGRCxNQUVPLElBQUksT0FBT2dQLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDckMsSUFBSSxPQUFPL0ssSUFBSSxDQUFDK0ssTUFBRCxDQUFYLEtBQXdCLFdBQTVCLEVBQXlDO1lBQ3ZDLE1BQU0sSUFBSTNOLFNBQUosd0JBQWtDMk4sTUFBbEMsUUFBTjtVQUNEO1VBRUQvSyxJQUFJLENBQUMrSyxNQUFELENBQUo7UUFDRCxDQU5NLE1BTUEsSUFBSTNFLE9BQU8sQ0FBQ25CLFFBQVIsSUFBb0JtQixPQUFPLENBQUM0RSxJQUFoQyxFQUFzQztVQUMzQ2hMLElBQUksQ0FBQ29GLEtBQUw7VUFDQXBGLElBQUksQ0FBQ21ILEtBQUw7UUFDRDtNQUNGLENBakNNLENBQVA7SUFrQ0Q7YUFFTThELHVCQUFQLDhCQUE0QnRTLEtBQTVCLEVBQW1DO01BQ2pDLElBQU02QixRQUFRLEdBQUdoQixJQUFJLENBQUNjLHNCQUFMLENBQTRCLElBQTVCLENBQWpCO01BRUEsSUFBSSxDQUFDRSxRQUFMLEVBQWU7UUFDYjtNQUNEO01BRUQsSUFBTTNCLE1BQU0sR0FBR0QscUJBQUMsQ0FBQzRCLFFBQUQsQ0FBRCxDQUFZLENBQVosQ0FBZjtNQUVBLElBQUksQ0FBQzNCLE1BQUQsSUFBVyxDQUFDRCxxQkFBQyxDQUFDQyxNQUFELENBQUQsQ0FBVTRHLFFBQVYsQ0FBbUIwRCxtQkFBbkIsQ0FBaEIsRUFBeUQ7UUFDdkQ7TUFDRDtNQUVELElBQU1wSCxNQUFNLGtCQUNQbkQscUJBQUMsQ0FBQ0MsTUFBRCxDQUFELENBQVVtSCxJQUFWLEVBRE8sRUFFUHBILHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLEVBRk8sQ0FBWjtNQUlBLElBQU1rTCxVQUFVLEdBQUcsS0FBS3pRLFlBQUwsQ0FBa0IsZUFBbEIsQ0FBbkI7TUFFQSxJQUFJeVEsVUFBSixFQUFnQjtRQUNkblAsTUFBTSxDQUFDa0osUUFBUCxHQUFrQixLQUFsQjtNQUNEO01BRURVLFFBQVEsQ0FBQzlGLGdCQUFULENBQTBCekgsSUFBMUIsQ0FBK0JRLHFCQUFDLENBQUNDLE1BQUQsQ0FBaEMsRUFBMENrRCxNQUExQztNQUVBLElBQUltUCxVQUFKLEVBQWdCO1FBQ2R0UyxxQkFBQyxDQUFDQyxNQUFELENBQUQsQ0FBVW1ILElBQVYsQ0FBZWxDLFVBQWYsRUFBeUIySixFQUF6QixDQUE0QnlELFVBQTVCO01BQ0Q7TUFFRHZTLEtBQUssQ0FBQ3dILGNBQU47SUFDRDs7O1dBN2NELGVBQXFCO1FBQ25CLE9BQU90QyxTQUFQO01BQ0Q7OztXQUVELGVBQXFCO1FBQ25CLE9BQU9tSCxTQUFQO01BQ0Q7Ozs7RUEwY0g7Ozs7RUFJQXBNLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWWdHLEVBQVosQ0FBZTdCLHNCQUFmLEVBQXFDdUcsbUJBQXJDLEVBQTBEYSxRQUFRLENBQUNzRixvQkFBbkU7RUFFQXJTLHFCQUFDLENBQUMySixNQUFELENBQUQsQ0FBVW5DLEVBQVYsQ0FBYU8scUJBQWIsRUFBa0MsWUFBTTtJQUN0QyxJQUFNd0ssU0FBUyxHQUFHLEdBQUcxSSxLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQnFDLGtCQUExQixDQUFkLENBQWxCO0lBQ0EsS0FBSyxJQUFJcEMsQ0FBQyxHQUFHLENBQVIsRUFBV0MsR0FBRyxHQUFHdUksU0FBUyxDQUFDdEksTUFBaEMsRUFBd0NGLENBQUMsR0FBR0MsR0FBNUMsRUFBaURELENBQUMsRUFBbEQsRUFBc0Q7TUFDcEQsSUFBTXlJLFNBQVMsR0FBR3hTLHFCQUFDLENBQUN1UyxTQUFTLENBQUN4SSxDQUFELENBQVYsQ0FBbkI7TUFDQWdELFFBQVEsQ0FBQzlGLGdCQUFULENBQTBCekgsSUFBMUIsQ0FBK0JnVCxTQUEvQixFQUEwQ0EsU0FBUyxDQUFDcEwsSUFBVixFQUExQztJQUNEO0VBQ0YsQ0FORDtFQVFBOzs7O0VBSUFwSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhK0gsUUFBUSxDQUFDOUYsZ0JBQXRCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5QnNGLFFBQXpCO0VBQ0EvTSxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXMEMsVUFBWCxHQUF3QixZQUFNO0lBQzVCMUgscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYUssb0JBQWI7SUFDQSxPQUFPMEgsUUFBUSxDQUFDOUYsZ0JBQWhCO0VBQ0QsQ0FIRDs7RUN4a0JBOzs7O0VBSUEsSUFBTWpDLE1BQUksR0FBRyxVQUFiO0VBQ0EsSUFBTUMsU0FBTyxHQUFHLE9BQWhCO0VBQ0EsSUFBTUMsVUFBUSxHQUFHLGFBQWpCO0VBQ0EsSUFBTUMsV0FBUyxTQUFPRCxVQUF0QjtFQUNBLElBQU1FLGNBQVksR0FBRyxXQUFyQjtFQUNBLElBQU1DLG9CQUFrQixHQUFHckYscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsQ0FBM0I7RUFFQSxJQUFNUSxpQkFBZSxHQUFHLE1BQXhCO0VBQ0EsSUFBTWlOLG1CQUFtQixHQUFHLFVBQTVCO0VBQ0EsSUFBTUMscUJBQXFCLEdBQUcsWUFBOUI7RUFDQSxJQUFNQyxvQkFBb0IsR0FBRyxXQUE3QjtFQUVBLElBQU1DLGVBQWUsR0FBRyxPQUF4QjtFQUNBLElBQU1DLGdCQUFnQixHQUFHLFFBQXpCO0VBRUEsSUFBTUMsWUFBVSxZQUFVM04sV0FBMUI7RUFDQSxJQUFNNE4sYUFBVyxhQUFXNU4sV0FBNUI7RUFDQSxJQUFNNk4sWUFBVSxZQUFVN04sV0FBMUI7RUFDQSxJQUFNOE4sY0FBWSxjQUFZOU4sV0FBOUI7RUFDQSxJQUFNUSxzQkFBb0IsYUFBV1IsV0FBWCxHQUF1QkMsY0FBakQ7RUFFQSxJQUFNOE4sZ0JBQWdCLEdBQUcsb0JBQXpCO0VBQ0EsSUFBTWhMLHNCQUFvQixHQUFHLDBCQUE3QjtFQUVBLElBQU1rRSxTQUFPLEdBQUc7SUFDZDNELE1BQU0sRUFBRSxJQURNO0lBRWRqQyxNQUFNLEVBQUU7RUFGTSxDQUFoQjtFQUtBLElBQU1tRyxhQUFXLEdBQUc7SUFDbEJsRSxNQUFNLEVBQUUsU0FEVTtJQUVsQmpDLE1BQU0sRUFBRTtFQUZVLENBQXBCO0VBS0E7Ozs7TUFJTTJNO0lBQ0osa0JBQVl4UixPQUFaLEVBQXFCd0IsTUFBckIsRUFBNkI7TUFDM0IsS0FBS2lRLGdCQUFMLEdBQXdCLEtBQXhCO01BQ0EsS0FBS3ROLFFBQUwsR0FBZ0JuRSxPQUFoQjtNQUNBLEtBQUs2TCxPQUFMLEdBQWUsS0FBS0MsVUFBTCxDQUFnQnRLLE1BQWhCLENBQWY7TUFDQSxLQUFLa1EsYUFBTCxHQUFxQixHQUFHeEosS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FDakMsd0NBQW1DbkksT0FBTyxDQUFDMlIsRUFBM0MsNERBQzBDM1IsT0FBTyxDQUFDMlIsRUFEbEQsU0FEaUMsQ0FBZCxDQUFyQjtNQUtBLElBQU1DLFVBQVUsR0FBRyxHQUFHMUosS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FBMEI1QixzQkFBMUIsQ0FBZCxDQUFuQjtNQUNBLEtBQUssSUFBSTZCLENBQUMsR0FBRyxDQUFSLEVBQVdDLEdBQUcsR0FBR3VKLFVBQVUsQ0FBQ3RKLE1BQWpDLEVBQXlDRixDQUFDLEdBQUdDLEdBQTdDLEVBQWtERCxDQUFDLEVBQW5ELEVBQXVEO1FBQ3JELElBQU15SixJQUFJLEdBQUdELFVBQVUsQ0FBQ3hKLENBQUQsQ0FBdkI7UUFDQSxJQUFNbkksUUFBUSxHQUFHaEIsSUFBSSxDQUFDYyxzQkFBTCxDQUE0QjhSLElBQTVCLENBQWpCO1FBQ0EsSUFBTUMsYUFBYSxHQUFHLEdBQUc1SixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQmxJLFFBQTFCLENBQWQsRUFDbkI4UixNQURtQixDQUNaLG1CQUFTO1VBQUEsT0FBSUMsU0FBUyxLQUFLaFMsT0FBbEI7UUFBQSxDQURHLENBQXRCO1FBR0EsSUFBSUMsUUFBUSxLQUFLLElBQWIsSUFBcUI2UixhQUFhLENBQUN4SixNQUFkLEdBQXVCLENBQWhELEVBQW1EO1VBQ2pELEtBQUsySixTQUFMLEdBQWlCaFMsUUFBakI7VUFDQSxLQUFLeVIsYUFBTCxDQUFtQlEsSUFBbkIsQ0FBd0JMLElBQXhCO1FBQ0Q7TUFDRjtNQUVELEtBQUtNLE9BQUwsR0FBZSxLQUFLdEcsT0FBTCxDQUFhaEgsTUFBYixHQUFzQixLQUFLdU4sVUFBTCxFQUF0QixHQUEwQyxJQUF6RDtNQUVBLElBQUksQ0FBQyxLQUFLdkcsT0FBTCxDQUFhaEgsTUFBbEIsRUFBMEI7UUFDeEIsS0FBS3dOLHlCQUFMLENBQStCLEtBQUtsTyxRQUFwQyxFQUE4QyxLQUFLdU4sYUFBbkQ7TUFDRDtNQUVELElBQUksS0FBSzdGLE9BQUwsQ0FBYS9FLE1BQWpCLEVBQXlCO1FBQ3ZCLEtBQUtBLE1BQUw7TUFDRDtJQUNGOzs7O0lBV0Q7V0FDQUEsMkJBQVM7TUFDUCxJQUFJekkscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQnJCLGlCQUExQixDQUFKLEVBQWdEO1FBQzlDLEtBQUt5TyxJQUFMO01BQ0QsQ0FGRCxNQUVPO1FBQ0wsS0FBS0MsSUFBTDtNQUNEO0lBQ0Y7V0FFREEsdUJBQU87TUFBQTtNQUNMLElBQUksS0FBS2QsZ0JBQUwsSUFDRnBULHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmUsUUFBakIsQ0FBMEJyQixpQkFBMUIsQ0FERixFQUM4QztRQUM1QztNQUNEO01BRUQsSUFBSTJPLE9BQUo7TUFDQSxJQUFJQyxXQUFKO01BRUEsSUFBSSxLQUFLTixPQUFULEVBQWtCO1FBQ2hCSyxPQUFPLEdBQUcsR0FBR3RLLEtBQUgsQ0FBU3JLLElBQVQsQ0FBYyxLQUFLc1UsT0FBTCxDQUFhaEssZ0JBQWIsQ0FBOEJvSixnQkFBOUIsQ0FBZCxFQUNQUSxNQURPLENBQ0EsY0FBSSxFQUFJO1VBQ2QsSUFBSSxPQUFPM1MsS0FBSSxDQUFDeU0sT0FBTCxDQUFhaEgsTUFBcEIsS0FBK0IsUUFBbkMsRUFBNkM7WUFDM0MsT0FBT2dOLElBQUksQ0FBQzNSLFlBQUwsQ0FBa0IsYUFBbEIsTUFBcUNkLEtBQUksQ0FBQ3lNLE9BQUwsQ0FBYWhILE1BQXpEO1VBQ0Q7VUFFRCxPQUFPZ04sSUFBSSxDQUFDekssU0FBTCxDQUFlQyxRQUFmLENBQXdCeUosbUJBQXhCLENBQVA7UUFDRCxDQVBPLENBQVY7UUFTQSxJQUFJMEIsT0FBTyxDQUFDbEssTUFBUixLQUFtQixDQUF2QixFQUEwQjtVQUN4QmtLLE9BQU8sR0FBRyxJQUFWO1FBQ0Q7TUFDRjtNQUVELElBQUlBLE9BQUosRUFBYTtRQUNYQyxXQUFXLEdBQUdwVSxxQkFBQyxDQUFDbVUsT0FBRCxDQUFELENBQVdFLEdBQVgsQ0FBZSxLQUFLVCxTQUFwQixFQUErQnhNLElBQS9CLENBQW9DbEMsVUFBcEMsQ0FBZDtRQUNBLElBQUlrUCxXQUFXLElBQUlBLFdBQVcsQ0FBQ2hCLGdCQUEvQixFQUFpRDtVQUMvQztRQUNEO01BQ0Y7TUFFRCxJQUFNa0IsVUFBVSxHQUFHdFUscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUW1NLFlBQVIsQ0FBbkI7TUFDQTlTLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCMFIsVUFBekI7TUFDQSxJQUFJQSxVQUFVLENBQUNsTyxrQkFBWCxFQUFKLEVBQXFDO1FBQ25DO01BQ0Q7TUFFRCxJQUFJK04sT0FBSixFQUFhO1FBQ1hoQixRQUFRLENBQUNsTSxnQkFBVCxDQUEwQnpILElBQTFCLENBQStCUSxxQkFBQyxDQUFDbVUsT0FBRCxDQUFELENBQVdFLEdBQVgsQ0FBZSxLQUFLVCxTQUFwQixDQUEvQixFQUErRCxNQUEvRDtRQUNBLElBQUksQ0FBQ1EsV0FBTCxFQUFrQjtVQUNoQnBVLHFCQUFDLENBQUNtVSxPQUFELENBQUQsQ0FBVy9NLElBQVgsQ0FBZ0JsQyxVQUFoQixFQUEwQixJQUExQjtRQUNEO01BQ0Y7TUFFRCxJQUFNcVAsU0FBUyxHQUFHLEtBQUtDLGFBQUwsRUFBbEI7TUFFQXhVLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUNHYyxXQURILENBQ2U2TCxtQkFEZixFQUVHbEIsUUFGSCxDQUVZbUIscUJBRlo7TUFJQSxLQUFLNU0sUUFBTCxDQUFjMk8sS0FBZCxDQUFvQkYsU0FBcEIsSUFBaUMsQ0FBakM7TUFFQSxJQUFJLEtBQUtsQixhQUFMLENBQW1CcEosTUFBdkIsRUFBK0I7UUFDN0JqSyxxQkFBQyxDQUFDLEtBQUtxVCxhQUFOLENBQUQsQ0FDR3pNLFdBREgsQ0FDZStMLG9CQURmLEVBRUcrQixJQUZILENBRVEsZUFGUixFQUV5QixJQUZ6QjtNQUdEO01BRUQsS0FBS0MsZ0JBQUwsQ0FBc0IsSUFBdEI7TUFFQSxJQUFNQyxRQUFRLEdBQUcsU0FBWEEsUUFBVyxHQUFNO1FBQ3JCNVUscUJBQUMsQ0FBQ2UsS0FBSSxDQUFDK0UsUUFBTixDQUFELENBQ0djLFdBREgsQ0FDZThMLHFCQURmLEVBRUduQixRQUZILENBRWVrQixtQkFGZixTQUVzQ2pOLGlCQUZ0QztRQUlBekUsS0FBSSxDQUFDK0UsUUFBTCxDQUFjMk8sS0FBZCxDQUFvQkYsU0FBcEIsSUFBaUMsRUFBakM7UUFFQXhULEtBQUksQ0FBQzRULGdCQUFMLENBQXNCLEtBQXRCO1FBRUEzVSxxQkFBQyxDQUFDZSxLQUFJLENBQUMrRSxRQUFOLENBQUQsQ0FBaUJsRCxPQUFqQixDQUF5Qm1RLGFBQXpCO01BQ0QsQ0FWRDtNQVlBLElBQU04QixvQkFBb0IsR0FBR04sU0FBUyxDQUFDLENBQUQsQ0FBVCxDQUFheFEsV0FBYixLQUE2QndRLFNBQVMsQ0FBQzFLLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBMUQ7TUFDQSxJQUFNaUwsVUFBVSxjQUFZRCxvQkFBNUI7TUFDQSxJQUFNMVMsa0JBQWtCLEdBQUd2QixJQUFJLENBQUNzQixnQ0FBTCxDQUFzQyxLQUFLNEQsUUFBM0MsQ0FBM0I7TUFFQTlGLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUNHbkYsR0FESCxDQUNPQyxJQUFJLENBQUMxQixjQURaLEVBQzRCMFYsUUFENUIsRUFFRzFULG9CQUZILENBRXdCaUIsa0JBRnhCO01BSUEsS0FBSzJELFFBQUwsQ0FBYzJPLEtBQWQsQ0FBb0JGLFNBQXBCLElBQW9DLEtBQUt6TyxRQUFMLENBQWNnUCxVQUFkLENBQXBDO0lBQ0Q7V0FFRGIsdUJBQU87TUFBQTtNQUNMLElBQUksS0FBS2IsZ0JBQUwsSUFDRixDQUFDcFQscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQnJCLGlCQUExQixDQURILEVBQytDO1FBQzdDO01BQ0Q7TUFFRCxJQUFNOE8sVUFBVSxHQUFHdFUscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUXFNLFlBQVIsQ0FBbkI7TUFDQWhULHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCMFIsVUFBekI7TUFDQSxJQUFJQSxVQUFVLENBQUNsTyxrQkFBWCxFQUFKLEVBQXFDO1FBQ25DO01BQ0Q7TUFFRCxJQUFNbU8sU0FBUyxHQUFHLEtBQUtDLGFBQUwsRUFBbEI7TUFFQSxLQUFLMU8sUUFBTCxDQUFjMk8sS0FBZCxDQUFvQkYsU0FBcEIsSUFBb0MsS0FBS3pPLFFBQUwsQ0FBY2lQLHFCQUFkLEdBQXNDUixTQUF0QyxDQUFwQztNQUVBM1QsSUFBSSxDQUFDOEIsTUFBTCxDQUFZLEtBQUtvRCxRQUFqQjtNQUVBOUYscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQ0d5TCxRQURILENBQ1ltQixxQkFEWixFQUVHOUwsV0FGSCxDQUVrQjZMLG1CQUZsQixTQUV5Q2pOLGlCQUZ6QztNQUlBLElBQU13UCxrQkFBa0IsR0FBRyxLQUFLM0IsYUFBTCxDQUFtQnBKLE1BQTlDO01BQ0EsSUFBSStLLGtCQUFrQixHQUFHLENBQXpCLEVBQTRCO1FBQzFCLEtBQUssSUFBSWpMLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdpTCxrQkFBcEIsRUFBd0NqTCxDQUFDLEVBQXpDLEVBQTZDO1VBQzNDLElBQU1uSCxPQUFPLEdBQUcsS0FBS3lRLGFBQUwsQ0FBbUJ0SixDQUFuQixDQUFoQjtVQUNBLElBQU1uSSxRQUFRLEdBQUdoQixJQUFJLENBQUNjLHNCQUFMLENBQTRCa0IsT0FBNUIsQ0FBakI7VUFFQSxJQUFJaEIsUUFBUSxLQUFLLElBQWpCLEVBQXVCO1lBQ3JCLElBQU1xVCxLQUFLLEdBQUdqVixxQkFBQyxDQUFDLEdBQUc2SixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQmxJLFFBQTFCLENBQWQsQ0FBRCxDQUFmO1lBQ0EsSUFBSSxDQUFDcVQsS0FBSyxDQUFDcE8sUUFBTixDQUFlckIsaUJBQWYsQ0FBTCxFQUFzQztjQUNwQ3hGLHFCQUFDLENBQUM0QyxPQUFELENBQUQsQ0FBVzJPLFFBQVgsQ0FBb0JvQixvQkFBcEIsRUFDRytCLElBREgsQ0FDUSxlQURSLEVBQ3lCLEtBRHpCO1lBRUQ7VUFDRjtRQUNGO01BQ0Y7TUFFRCxLQUFLQyxnQkFBTCxDQUFzQixJQUF0QjtNQUVBLElBQU1DLFFBQVEsR0FBRyxTQUFYQSxRQUFXLEdBQU07UUFDckJ0RixNQUFJLENBQUNxRixnQkFBTCxDQUFzQixLQUF0QjtRQUNBM1UscUJBQUMsQ0FBQ3NQLE1BQUksQ0FBQ3hKLFFBQU4sQ0FBRCxDQUNHYyxXQURILENBQ2U4TCxxQkFEZixFQUVHbkIsUUFGSCxDQUVZa0IsbUJBRlosRUFHRzdQLE9BSEgsQ0FHV3FRLGNBSFg7TUFJRCxDQU5EO01BUUEsS0FBS25OLFFBQUwsQ0FBYzJPLEtBQWQsQ0FBb0JGLFNBQXBCLElBQWlDLEVBQWpDO01BQ0EsSUFBTXBTLGtCQUFrQixHQUFHdkIsSUFBSSxDQUFDc0IsZ0NBQUwsQ0FBc0MsS0FBSzRELFFBQTNDLENBQTNCO01BRUE5RixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FDR25GLEdBREgsQ0FDT0MsSUFBSSxDQUFDMUIsY0FEWixFQUM0QjBWLFFBRDVCLEVBRUcxVCxvQkFGSCxDQUV3QmlCLGtCQUZ4QjtJQUdEO1dBRUR3Uyw2Q0FBaUJPLGVBQWpCLEVBQWtDO01BQ2hDLEtBQUs5QixnQkFBTCxHQUF3QjhCLGVBQXhCO0lBQ0Q7V0FFRDVPLDZCQUFVO01BQ1J0RyxxQkFBQyxDQUFDdUcsVUFBRixDQUFhLEtBQUtULFFBQWxCLEVBQTRCWixVQUE1QjtNQUVBLEtBQUtzSSxPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUtzRyxPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUtoTyxRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBS3VOLGFBQUwsR0FBcUIsSUFBckI7TUFDQSxLQUFLRCxnQkFBTCxHQUF3QixJQUF4QjtJQUNEO0lBQUE7O1dBR0QzRixpQ0FBV3RLLE1BQVgsRUFBbUI7TUFDakJBLE1BQU0sa0JBQ0RpSixTQURDLEVBRURqSixNQUZDLENBQU47TUFJQUEsTUFBTSxDQUFDc0YsTUFBUCxHQUFnQjNGLE9BQU8sQ0FBQ0ssTUFBTSxDQUFDc0YsTUFBUixDQUF2QixDQUxpQjs7TUFNakI3SCxJQUFJLENBQUNxQyxlQUFMLENBQXFCK0IsTUFBckIsRUFBMkI3QixNQUEzQixFQUFtQ3dKLGFBQW5DO01BQ0EsT0FBT3hKLE1BQVA7SUFDRDtXQUVEcVIseUNBQWdCO01BQ2QsSUFBTVcsUUFBUSxHQUFHblYscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQitMLGVBQTFCLENBQWpCO01BQ0EsT0FBT3VDLFFBQVEsR0FBR3ZDLGVBQUgsR0FBcUJDLGdCQUFwQztJQUNEO1dBRURrQixtQ0FBYTtNQUFBO01BQ1gsSUFBSXZOLE1BQUo7TUFFQSxJQUFJNUYsSUFBSSxDQUFDbUMsU0FBTCxDQUFlLEtBQUt5SyxPQUFMLENBQWFoSCxNQUE1QixDQUFKLEVBQXlDO1FBQ3ZDQSxNQUFNLEdBQUcsS0FBS2dILE9BQUwsQ0FBYWhILE1BQXRCLENBRHVDOztRQUl2QyxJQUFJLE9BQU8sS0FBS2dILE9BQUwsQ0FBYWhILE1BQWIsQ0FBb0I5QixNQUEzQixLQUFzQyxXQUExQyxFQUF1RDtVQUNyRDhCLE1BQU0sR0FBRyxLQUFLZ0gsT0FBTCxDQUFhaEgsTUFBYixDQUFvQixDQUFwQixDQUFUO1FBQ0Q7TUFDRixDQVBELE1BT087UUFDTEEsTUFBTSxHQUFHaEYsUUFBUSxDQUFDUSxhQUFULENBQXVCLEtBQUt3TCxPQUFMLENBQWFoSCxNQUFwQyxDQUFUO01BQ0Q7TUFFRCxJQUFNNUUsUUFBUSxpREFBNEMsS0FBSzRMLE9BQUwsQ0FBYWhILE1BQXpELFFBQWQ7TUFDQSxJQUFNOEssUUFBUSxHQUFHLEdBQUd6SCxLQUFILENBQVNySyxJQUFULENBQWNnSCxNQUFNLENBQUNzRCxnQkFBUCxDQUF3QmxJLFFBQXhCLENBQWQsQ0FBakI7TUFFQTVCLHFCQUFDLENBQUNzUixRQUFELENBQUQsQ0FBWXBLLElBQVosQ0FBaUIsVUFBQzZDLENBQUQsRUFBSXBJLE9BQUosRUFBZ0I7UUFDL0IrTixNQUFJLENBQUNzRSx5QkFBTCxDQUNFYixRQUFRLENBQUNpQyxxQkFBVCxDQUErQnpULE9BQS9CLENBREYsRUFFRSxDQUFDQSxPQUFELENBRkY7TUFJRCxDQUxEO01BT0EsT0FBTzZFLE1BQVA7SUFDRDtXQUVEd04sK0RBQTBCclMsT0FBMUIsRUFBbUMwVCxZQUFuQyxFQUFpRDtNQUMvQyxJQUFNQyxNQUFNLEdBQUd0VixxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVdrRixRQUFYLENBQW9CckIsaUJBQXBCLENBQWY7TUFFQSxJQUFJNlAsWUFBWSxDQUFDcEwsTUFBakIsRUFBeUI7UUFDdkJqSyxxQkFBQyxDQUFDcVYsWUFBRCxDQUFELENBQ0doTSxXQURILENBQ2VzSixvQkFEZixFQUNxQyxDQUFDMkMsTUFEdEMsRUFFR1osSUFGSCxDQUVRLGVBRlIsRUFFeUJZLE1BRnpCO01BR0Q7SUFDRjtJQUFBOzthQUdNRix3QkFBUCwrQkFBNkJ6VCxPQUE3QixFQUFzQztNQUNwQyxJQUFNQyxRQUFRLEdBQUdoQixJQUFJLENBQUNjLHNCQUFMLENBQTRCQyxPQUE1QixDQUFqQjtNQUNBLE9BQU9DLFFBQVEsR0FBR0osUUFBUSxDQUFDUSxhQUFULENBQXVCSixRQUF2QixDQUFILEdBQXNDLElBQXJEO0lBQ0Q7YUFFTXFGLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDO01BQzlCLE9BQU8sS0FBSytELElBQUwsQ0FBVSxZQUFZO1FBQzNCLElBQU1DLFFBQVEsR0FBR25ILHFCQUFDLENBQUMsSUFBRCxDQUFsQjtRQUNBLElBQUlvSCxJQUFJLEdBQUdELFFBQVEsQ0FBQ0MsSUFBVCxDQUFjbEMsVUFBZCxDQUFYO1FBQ0EsSUFBTXNJLE9BQU8sa0JBQ1JwQixTQURRLEVBRVJqRixRQUFRLENBQUNDLElBQVQsRUFGUSxFQUdQLFFBQU9qRSxNQUFQLE1BQWtCLFFBQWxCLElBQThCQSxNQUE5QixHQUF1Q0EsTUFBdkMsR0FBZ0QsRUFIekMsQ0FBYjtRQU1BLElBQUksQ0FBQ2lFLElBQUQsSUFBU29HLE9BQU8sQ0FBQy9FLE1BQWpCLElBQTJCLE9BQU90RixNQUFQLEtBQWtCLFFBQTdDLElBQXlELFlBQVlVLElBQVosQ0FBaUJWLE1BQWpCLENBQTdELEVBQXVGO1VBQ3JGcUssT0FBTyxDQUFDL0UsTUFBUixHQUFpQixLQUFqQjtRQUNEO1FBRUQsSUFBSSxDQUFDckIsSUFBTCxFQUFXO1VBQ1RBLElBQUksR0FBRyxJQUFJK0wsUUFBSixDQUFhLElBQWIsRUFBbUIzRixPQUFuQixDQUFQO1VBQ0FyRyxRQUFRLENBQUNDLElBQVQsQ0FBY2xDLFVBQWQsRUFBd0JrQyxJQUF4QjtRQUNEO1FBRUQsSUFBSSxPQUFPakUsTUFBUCxLQUFrQixRQUF0QixFQUFnQztVQUM5QixJQUFJLE9BQU9pRSxJQUFJLENBQUNqRSxNQUFELENBQVgsS0FBd0IsV0FBNUIsRUFBeUM7WUFDdkMsTUFBTSxJQUFJcUIsU0FBSix3QkFBa0NyQixNQUFsQyxRQUFOO1VBQ0Q7VUFFRGlFLElBQUksQ0FBQ2pFLE1BQUQsQ0FBSjtRQUNEO01BQ0YsQ0F6Qk0sQ0FBUDtJQTBCRDs7O1dBaFFELGVBQXFCO1FBQ25CLE9BQU84QixTQUFQO01BQ0Q7OztXQUVELGVBQXFCO1FBQ25CLE9BQU9tSCxTQUFQO01BQ0Q7Ozs7RUE2UEg7Ozs7RUFJQXBNLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWWdHLEVBQVosQ0FBZTdCLHNCQUFmLEVBQXFDdUMsc0JBQXJDLEVBQTJELFVBQVVuSSxLQUFWLEVBQWlCO0lBQzFFO0lBQ0EsSUFBSUEsS0FBSyxDQUFDd1YsYUFBTixDQUFvQjdMLE9BQXBCLEtBQWdDLEdBQXBDLEVBQXlDO01BQ3ZDM0osS0FBSyxDQUFDd0gsY0FBTjtJQUNEO0lBRUQsSUFBTWlPLFFBQVEsR0FBR3hWLHFCQUFDLENBQUMsSUFBRCxDQUFsQjtJQUNBLElBQU00QixRQUFRLEdBQUdoQixJQUFJLENBQUNjLHNCQUFMLENBQTRCLElBQTVCLENBQWpCO0lBQ0EsSUFBTStULFNBQVMsR0FBRyxHQUFHNUwsS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FBMEJsSSxRQUExQixDQUFkLENBQWxCO0lBRUE1QixxQkFBQyxDQUFDeVYsU0FBRCxDQUFELENBQWF2TyxJQUFiLENBQWtCLFlBQVk7TUFDNUIsSUFBTXdPLE9BQU8sR0FBRzFWLHFCQUFDLENBQUMsSUFBRCxDQUFqQjtNQUNBLElBQU1vSCxJQUFJLEdBQUdzTyxPQUFPLENBQUN0TyxJQUFSLENBQWFsQyxVQUFiLENBQWI7TUFDQSxJQUFNL0IsTUFBTSxHQUFHaUUsSUFBSSxHQUFHLFFBQUgsR0FBY29PLFFBQVEsQ0FBQ3BPLElBQVQsRUFBakM7TUFDQStMLFFBQVEsQ0FBQ2xNLGdCQUFULENBQTBCekgsSUFBMUIsQ0FBK0JrVyxPQUEvQixFQUF3Q3ZTLE1BQXhDO0lBQ0QsQ0FMRDtFQU1ELENBaEJEO0VBa0JBOzs7O0VBSUFuRCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhbU8sUUFBUSxDQUFDbE0sZ0JBQXRCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5QjBMLFFBQXpCO0VBQ0FuVCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXMEMsVUFBWCxHQUF3QixZQUFNO0lBQzVCMUgscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYUssb0JBQWI7SUFDQSxPQUFPOE4sUUFBUSxDQUFDbE0sZ0JBQWhCO0VBQ0QsQ0FIRDs7RUN0WEE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQXdCQSxJQUFJME8sU0FBUyxHQUFHLE9BQU9oTSxNQUFNLEtBQUssV0FBVyxJQUFJLE9BQU9uSSxRQUFRLEtBQUssV0FBVyxJQUFJLE9BQU9vTSxTQUFTLEtBQUssV0FBVztFQUVwSCxJQUFJZ0ksZUFBZSxHQUFHLFlBQVk7SUFDaEMsSUFBSUMscUJBQXFCLEdBQUcsQ0FBQyxNQUFNLEVBQUUsU0FBUyxFQUFFLFNBQVMsQ0FBQztJQUMxRCxLQUFLLElBQUk5TCxDQUFDLEdBQUcsQ0FBQyxFQUFFQSxDQUFDLEdBQUc4TCxxQkFBcUIsQ0FBQzVMLE1BQU0sRUFBRUYsQ0FBQyxJQUFJLENBQUMsRUFBRTtNQUN4RCxJQUFJNEwsU0FBUyxJQUFJL0gsU0FBUyxDQUFDa0ksU0FBUyxDQUFDMUYsT0FBTyxDQUFDeUYscUJBQXFCLENBQUM5TCxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRTtRQUMzRSxPQUFPLENBQUM7TUFDZDtJQUNBO0lBQ0UsT0FBTyxDQUFDO0VBQ1YsQ0FBQyxFQUFFO0VBRUgsU0FBU2dNLGlCQUFpQixDQUFDOVUsRUFBRSxFQUFFO0lBQzdCLElBQUlQLE1BQU0sR0FBRyxLQUFLO0lBQ2xCLE9BQU8sWUFBWTtNQUNqQixJQUFJQSxNQUFNLEVBQUU7UUFDVjtNQUNOO01BQ0lBLE1BQU0sR0FBRyxJQUFJO01BQ2JpSixNQUFNLENBQUNxTSxPQUFPLENBQUNDLE9BQU8sRUFBRSxDQUFDQyxJQUFJLENBQUMsWUFBWTtRQUN4Q3hWLE1BQU0sR0FBRyxLQUFLO1FBQ2RPLEVBQUUsRUFBRTtNQUNWLENBQUssQ0FBQztJQUNOLENBQUc7RUFDSDtFQUVBLFNBQVNrVixZQUFZLENBQUNsVixFQUFFLEVBQUU7SUFDeEIsSUFBSW1WLFNBQVMsR0FBRyxLQUFLO0lBQ3JCLE9BQU8sWUFBWTtNQUNqQixJQUFJLENBQUNBLFNBQVMsRUFBRTtRQUNkQSxTQUFTLEdBQUcsSUFBSTtRQUNoQnZWLFVBQVUsQ0FBQyxZQUFZO1VBQ3JCdVYsU0FBUyxHQUFHLEtBQUs7VUFDakJuVixFQUFFLEVBQUU7UUFDWixDQUFPLEVBQUUyVSxlQUFlLENBQUM7TUFDekI7SUFDQSxDQUFHO0VBQ0g7RUFFQSxJQUFJUyxrQkFBa0IsR0FBR1YsU0FBUyxJQUFJaE0sTUFBTSxDQUFDcU0sT0FBTzs7RUFFcEQ7Ozs7Ozs7OztFQVNBLElBQUlNLFFBQVEsR0FBR0Qsa0JBQWtCLEdBQUdOLGlCQUFpQixHQUFHSSxZQUFZOztFQUVwRTs7Ozs7OztFQU9BLFNBQVNJLFVBQVUsQ0FBQ0MsZUFBZSxFQUFFO0lBQ25DLElBQUlDLE9BQU8sR0FBRyxFQUFFO0lBQ2hCLE9BQU9ELGVBQWUsSUFBSUMsT0FBTyxDQUFDbFgsUUFBUSxDQUFDQyxJQUFJLENBQUNnWCxlQUFlLENBQUMsS0FBSyxtQkFBbUI7RUFDMUY7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTRSx3QkFBd0IsQ0FBQy9VLE9BQU8sRUFBRTBCLFFBQVEsRUFBRTtJQUNuRCxJQUFJMUIsT0FBTyxDQUFDcUIsUUFBUSxLQUFLLENBQUMsRUFBRTtNQUMxQixPQUFPLEVBQUU7SUFDYjtJQUNBO0lBQ0UsSUFBSTJHLE1BQU0sR0FBR2hJLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQ0MsV0FBVztJQUM5QyxJQUFJeFUsR0FBRyxHQUFHdUgsTUFBTSxDQUFDa04sZ0JBQWdCLENBQUNsVixPQUFPLEVBQUUsSUFBSSxDQUFDO0lBQ2hELE9BQU8wQixRQUFRLEdBQUdqQixHQUFHLENBQUNpQixRQUFRLENBQUMsR0FBR2pCLEdBQUc7RUFDdkM7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTMFUsYUFBYSxDQUFDblYsT0FBTyxFQUFFO0lBQzlCLElBQUlBLE9BQU8sQ0FBQ29WLFFBQVEsS0FBSyxNQUFNLEVBQUU7TUFDL0IsT0FBT3BWLE9BQU87SUFDbEI7SUFDRSxPQUFPQSxPQUFPLENBQUMyQyxVQUFVLElBQUkzQyxPQUFPLENBQUNxVixJQUFJO0VBQzNDOztFQUVBOzs7Ozs7O0VBT0EsU0FBU0MsZUFBZSxDQUFDdFYsT0FBTyxFQUFFO0lBQ2xDO0lBQ0UsSUFBSSxDQUFDQSxPQUFPLEVBQUU7TUFDWixPQUFPSCxRQUFRLENBQUMwVixJQUFJO0lBQ3hCO0lBRUUsUUFBUXZWLE9BQU8sQ0FBQ29WLFFBQVE7TUFDdEIsS0FBSyxNQUFNO01BQ1gsS0FBSyxNQUFNO1FBQ1QsT0FBT3BWLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQ08sSUFBSTtNQUNuQyxLQUFLLFdBQVc7UUFDZCxPQUFPdlYsT0FBTyxDQUFDdVYsSUFBSTtJQUFDOztJQUcxQjs7SUFFRSxJQUFJQyxxQkFBcUIsR0FBR1Qsd0JBQXdCLENBQUMvVSxPQUFPLENBQUM7TUFDekR5VixRQUFRLEdBQUdELHFCQUFxQixDQUFDQyxRQUFRO01BQ3pDQyxTQUFTLEdBQUdGLHFCQUFxQixDQUFDRSxTQUFTO01BQzNDQyxTQUFTLEdBQUdILHFCQUFxQixDQUFDRyxTQUFTO0lBRS9DLElBQUksdUJBQXVCLENBQUN6VCxJQUFJLENBQUN1VCxRQUFRLEdBQUdFLFNBQVMsR0FBR0QsU0FBUyxDQUFDLEVBQUU7TUFDbEUsT0FBTzFWLE9BQU87SUFDbEI7SUFFRSxPQUFPc1YsZUFBZSxDQUFDSCxhQUFhLENBQUNuVixPQUFPLENBQUMsQ0FBQztFQUNoRDs7RUFFQTs7Ozs7OztFQU9BLFNBQVM0VixnQkFBZ0IsQ0FBQ0MsU0FBUyxFQUFFO0lBQ25DLE9BQU9BLFNBQVMsSUFBSUEsU0FBUyxDQUFDQyxhQUFhLEdBQUdELFNBQVMsQ0FBQ0MsYUFBYSxHQUFHRCxTQUFTO0VBQ25GO0VBRUEsSUFBSUUsTUFBTSxHQUFHL0IsU0FBUyxJQUFJLENBQUMsRUFBRWhNLE1BQU0sQ0FBQ2dPLG9CQUFvQixJQUFJblcsUUFBUSxDQUFDb1csWUFBWSxDQUFDO0VBQ2xGLElBQUlDLE1BQU0sR0FBR2xDLFNBQVMsSUFBSSxTQUFTLENBQUM5UixJQUFJLENBQUMrSixTQUFTLENBQUNrSSxTQUFTLENBQUM7O0VBRTdEOzs7Ozs7O0VBT0EsU0FBU2dDLElBQUksQ0FBQ3JULE9BQU8sRUFBRTtJQUNyQixJQUFJQSxPQUFPLEtBQUssRUFBRSxFQUFFO01BQ2xCLE9BQU9pVCxNQUFNO0lBQ2pCO0lBQ0UsSUFBSWpULE9BQU8sS0FBSyxFQUFFLEVBQUU7TUFDbEIsT0FBT29ULE1BQU07SUFDakI7SUFDRSxPQUFPSCxNQUFNLElBQUlHLE1BQU07RUFDekI7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTRSxlQUFlLENBQUNwVyxPQUFPLEVBQUU7SUFDaEMsSUFBSSxDQUFDQSxPQUFPLEVBQUU7TUFDWixPQUFPSCxRQUFRLENBQUN5QyxlQUFlO0lBQ25DO0lBRUUsSUFBSStULGNBQWMsR0FBR0YsSUFBSSxDQUFDLEVBQUUsQ0FBQyxHQUFHdFcsUUFBUSxDQUFDMFYsSUFBSSxHQUFHLElBQUk7O0lBRXREO0lBQ0UsSUFBSWUsWUFBWSxHQUFHdFcsT0FBTyxDQUFDc1csWUFBWSxJQUFJLElBQUk7SUFDakQ7SUFDRSxPQUFPQSxZQUFZLEtBQUtELGNBQWMsSUFBSXJXLE9BQU8sQ0FBQ3VXLGtCQUFrQixFQUFFO01BQ3BFRCxZQUFZLEdBQUcsQ0FBQ3RXLE9BQU8sR0FBR0EsT0FBTyxDQUFDdVcsa0JBQWtCLEVBQUVELFlBQVk7SUFDdEU7SUFFRSxJQUFJbEIsUUFBUSxHQUFHa0IsWUFBWSxJQUFJQSxZQUFZLENBQUNsQixRQUFRO0lBRXBELElBQUksQ0FBQ0EsUUFBUSxJQUFJQSxRQUFRLEtBQUssTUFBTSxJQUFJQSxRQUFRLEtBQUssTUFBTSxFQUFFO01BQzNELE9BQU9wVixPQUFPLEdBQUdBLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQzFTLGVBQWUsR0FBR3pDLFFBQVEsQ0FBQ3lDLGVBQWU7SUFDckY7O0lBRUE7SUFDQTtJQUNFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLE9BQU8sQ0FBQyxDQUFDbU0sT0FBTyxDQUFDNkgsWUFBWSxDQUFDbEIsUUFBUSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUlMLHdCQUF3QixDQUFDdUIsWUFBWSxFQUFFLFVBQVUsQ0FBQyxLQUFLLFFBQVEsRUFBRTtNQUNsSSxPQUFPRixlQUFlLENBQUNFLFlBQVksQ0FBQztJQUN4QztJQUVFLE9BQU9BLFlBQVk7RUFDckI7RUFFQSxTQUFTRSxpQkFBaUIsQ0FBQ3hXLE9BQU8sRUFBRTtJQUNsQyxJQUFJb1YsUUFBUSxHQUFHcFYsT0FBTyxDQUFDb1YsUUFBUTtJQUUvQixJQUFJQSxRQUFRLEtBQUssTUFBTSxFQUFFO01BQ3ZCLE9BQU8sS0FBSztJQUNoQjtJQUNFLE9BQU9BLFFBQVEsS0FBSyxNQUFNLElBQUlnQixlQUFlLENBQUNwVyxPQUFPLENBQUN5VyxpQkFBaUIsQ0FBQyxLQUFLelcsT0FBTztFQUN0Rjs7RUFFQTs7Ozs7OztFQU9BLFNBQVMwVyxPQUFPLENBQUNDLElBQUksRUFBRTtJQUNyQixJQUFJQSxJQUFJLENBQUNoVSxVQUFVLEtBQUssSUFBSSxFQUFFO01BQzVCLE9BQU8rVCxPQUFPLENBQUNDLElBQUksQ0FBQ2hVLFVBQVUsQ0FBQztJQUNuQztJQUVFLE9BQU9nVSxJQUFJO0VBQ2I7O0VBRUE7Ozs7Ozs7O0VBUUEsU0FBU0Msc0JBQXNCLENBQUNDLFFBQVEsRUFBRUMsUUFBUSxFQUFFO0lBQ3BEO0lBQ0UsSUFBSSxDQUFDRCxRQUFRLElBQUksQ0FBQ0EsUUFBUSxDQUFDeFYsUUFBUSxJQUFJLENBQUN5VixRQUFRLElBQUksQ0FBQ0EsUUFBUSxDQUFDelYsUUFBUSxFQUFFO01BQ3RFLE9BQU94QixRQUFRLENBQUN5QyxlQUFlO0lBQ25DOztJQUVBO0lBQ0UsSUFBSXlVLEtBQUssR0FBR0YsUUFBUSxDQUFDRyx1QkFBdUIsQ0FBQ0YsUUFBUSxDQUFDLEdBQUdHLElBQUksQ0FBQ0MsMkJBQTJCO0lBQ3pGLElBQUlwSixLQUFLLEdBQUdpSixLQUFLLEdBQUdGLFFBQVEsR0FBR0MsUUFBUTtJQUN2QyxJQUFJekksR0FBRyxHQUFHMEksS0FBSyxHQUFHRCxRQUFRLEdBQUdELFFBQVE7O0lBRXZDO0lBQ0UsSUFBSU0sS0FBSyxHQUFHdFgsUUFBUSxDQUFDdVgsV0FBVyxFQUFFO0lBQ2xDRCxLQUFLLENBQUNFLFFBQVEsQ0FBQ3ZKLEtBQUssRUFBRSxDQUFDLENBQUM7SUFDeEJxSixLQUFLLENBQUNHLE1BQU0sQ0FBQ2pKLEdBQUcsRUFBRSxDQUFDLENBQUM7SUFDcEIsSUFBSWtKLHVCQUF1QixHQUFHSixLQUFLLENBQUNJLHVCQUF1Qjs7SUFFN0Q7O0lBRUUsSUFBSVYsUUFBUSxLQUFLVSx1QkFBdUIsSUFBSVQsUUFBUSxLQUFLUyx1QkFBdUIsSUFBSXpKLEtBQUssQ0FBQ3pHLFFBQVEsQ0FBQ2dILEdBQUcsQ0FBQyxFQUFFO01BQ3ZHLElBQUltSSxpQkFBaUIsQ0FBQ2UsdUJBQXVCLENBQUMsRUFBRTtRQUM5QyxPQUFPQSx1QkFBdUI7TUFDcEM7TUFFSSxPQUFPbkIsZUFBZSxDQUFDbUIsdUJBQXVCLENBQUM7SUFDbkQ7O0lBRUE7SUFDRSxJQUFJQyxZQUFZLEdBQUdkLE9BQU8sQ0FBQ0csUUFBUSxDQUFDO0lBQ3BDLElBQUlXLFlBQVksQ0FBQ25DLElBQUksRUFBRTtNQUNyQixPQUFPdUIsc0JBQXNCLENBQUNZLFlBQVksQ0FBQ25DLElBQUksRUFBRXlCLFFBQVEsQ0FBQztJQUM5RCxDQUFHLE1BQU07TUFDTCxPQUFPRixzQkFBc0IsQ0FBQ0MsUUFBUSxFQUFFSCxPQUFPLENBQUNJLFFBQVEsQ0FBQyxDQUFDekIsSUFBSSxDQUFDO0lBQ25FO0VBQ0E7O0VBRUE7Ozs7Ozs7O0VBUUEsU0FBU29DLFNBQVMsQ0FBQ3pYLE9BQU8sRUFBRTtJQUMxQixJQUFJMFgsSUFBSSxHQUFHL1ksU0FBUyxDQUFDMkosTUFBTSxHQUFHLENBQUMsSUFBSTNKLFNBQVMsQ0FBQyxDQUFDLENBQUMsS0FBS0MsU0FBUyxHQUFHRCxTQUFTLENBQUMsQ0FBQyxDQUFDLEdBQUcsS0FBSztJQUVwRixJQUFJZ1osU0FBUyxHQUFHRCxJQUFJLEtBQUssS0FBSyxHQUFHLFdBQVcsR0FBRyxZQUFZO0lBQzNELElBQUl0QyxRQUFRLEdBQUdwVixPQUFPLENBQUNvVixRQUFRO0lBRS9CLElBQUlBLFFBQVEsS0FBSyxNQUFNLElBQUlBLFFBQVEsS0FBSyxNQUFNLEVBQUU7TUFDOUMsSUFBSXdDLElBQUksR0FBRzVYLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQzFTLGVBQWU7TUFDaEQsSUFBSXVWLGdCQUFnQixHQUFHN1gsT0FBTyxDQUFDZ1YsYUFBYSxDQUFDNkMsZ0JBQWdCLElBQUlELElBQUk7TUFDckUsT0FBT0MsZ0JBQWdCLENBQUNGLFNBQVMsQ0FBQztJQUN0QztJQUVFLE9BQU8zWCxPQUFPLENBQUMyWCxTQUFTLENBQUM7RUFDM0I7O0VBRUE7Ozs7Ozs7OztFQVNBLFNBQVNHLGFBQWEsQ0FBQ0MsSUFBSSxFQUFFL1gsT0FBTyxFQUFFO0lBQ3BDLElBQUlnWSxRQUFRLEdBQUdyWixTQUFTLENBQUMySixNQUFNLEdBQUcsQ0FBQyxJQUFJM0osU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLQyxTQUFTLEdBQUdELFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLO0lBRXhGLElBQUlzWixTQUFTLEdBQUdSLFNBQVMsQ0FBQ3pYLE9BQU8sRUFBRSxLQUFLLENBQUM7SUFDekMsSUFBSWtZLFVBQVUsR0FBR1QsU0FBUyxDQUFDelgsT0FBTyxFQUFFLE1BQU0sQ0FBQztJQUMzQyxJQUFJbVksUUFBUSxHQUFHSCxRQUFRLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztJQUNoQ0QsSUFBSSxDQUFDSyxHQUFHLElBQUlILFNBQVMsR0FBR0UsUUFBUTtJQUNoQ0osSUFBSSxDQUFDTSxNQUFNLElBQUlKLFNBQVMsR0FBR0UsUUFBUTtJQUNuQ0osSUFBSSxDQUFDTyxJQUFJLElBQUlKLFVBQVUsR0FBR0MsUUFBUTtJQUNsQ0osSUFBSSxDQUFDUSxLQUFLLElBQUlMLFVBQVUsR0FBR0MsUUFBUTtJQUNuQyxPQUFPSixJQUFJO0VBQ2I7O0VBRUE7Ozs7Ozs7Ozs7RUFVQSxTQUFTUyxjQUFjLENBQUNDLE1BQU0sRUFBRUMsSUFBSSxFQUFFO0lBQ3BDLElBQUlDLEtBQUssR0FBR0QsSUFBSSxLQUFLLEdBQUcsR0FBRyxNQUFNLEdBQUcsS0FBSztJQUN6QyxJQUFJRSxLQUFLLEdBQUdELEtBQUssS0FBSyxNQUFNLEdBQUcsT0FBTyxHQUFHLFFBQVE7SUFFakQsT0FBTy9YLFVBQVUsQ0FBQzZYLE1BQU0sQ0FBQyxRQUFRLEdBQUdFLEtBQUssR0FBRyxPQUFPLENBQUMsQ0FBQyxHQUFHL1gsVUFBVSxDQUFDNlgsTUFBTSxDQUFDLFFBQVEsR0FBR0csS0FBSyxHQUFHLE9BQU8sQ0FBQyxDQUFDO0VBQ3hHO0VBRUEsU0FBU0MsT0FBTyxDQUFDSCxJQUFJLEVBQUVuRCxJQUFJLEVBQUVxQyxJQUFJLEVBQUVrQixhQUFhLEVBQUU7SUFDaEQsT0FBT25aLElBQUksQ0FBQ29aLEdBQUcsQ0FBQ3hELElBQUksQ0FBQyxRQUFRLEdBQUdtRCxJQUFJLENBQUMsRUFBRW5ELElBQUksQ0FBQyxRQUFRLEdBQUdtRCxJQUFJLENBQUMsRUFBRWQsSUFBSSxDQUFDLFFBQVEsR0FBR2MsSUFBSSxDQUFDLEVBQUVkLElBQUksQ0FBQyxRQUFRLEdBQUdjLElBQUksQ0FBQyxFQUFFZCxJQUFJLENBQUMsUUFBUSxHQUFHYyxJQUFJLENBQUMsRUFBRXZDLElBQUksQ0FBQyxFQUFFLENBQUMsR0FBR3JHLFFBQVEsQ0FBQzhILElBQUksQ0FBQyxRQUFRLEdBQUdjLElBQUksQ0FBQyxDQUFDLEdBQUc1SSxRQUFRLENBQUNnSixhQUFhLENBQUMsUUFBUSxJQUFJSixJQUFJLEtBQUssUUFBUSxHQUFHLEtBQUssR0FBRyxNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUc1SSxRQUFRLENBQUNnSixhQUFhLENBQUMsUUFBUSxJQUFJSixJQUFJLEtBQUssUUFBUSxHQUFHLFFBQVEsR0FBRyxPQUFPLENBQUMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO0VBQzlVO0VBRUEsU0FBU00sY0FBYyxDQUFDblosUUFBUSxFQUFFO0lBQ2hDLElBQUkwVixJQUFJLEdBQUcxVixRQUFRLENBQUMwVixJQUFJO0lBQ3hCLElBQUlxQyxJQUFJLEdBQUcvWCxRQUFRLENBQUN5QyxlQUFlO0lBQ25DLElBQUl3VyxhQUFhLEdBQUczQyxJQUFJLENBQUMsRUFBRSxDQUFDLElBQUlqQixnQkFBZ0IsQ0FBQzBDLElBQUksQ0FBQztJQUV0RCxPQUFPO01BQ0xxQixNQUFNLEVBQUVKLE9BQU8sQ0FBQyxRQUFRLEVBQUV0RCxJQUFJLEVBQUVxQyxJQUFJLEVBQUVrQixhQUFhLENBQUM7TUFDcERJLEtBQUssRUFBRUwsT0FBTyxDQUFDLE9BQU8sRUFBRXRELElBQUksRUFBRXFDLElBQUksRUFBRWtCLGFBQWE7SUFDckQsQ0FBRztFQUNIO0VBRUEsSUFBSUssY0FBYyxHQUFHLFNBQWpCQSxjQUFjLENBQWFDLFFBQVEsRUFBRXRULFdBQVcsRUFBRTtJQUNwRCxJQUFJLEVBQUVzVCxRQUFRLFlBQVl0VCxXQUFXLENBQUMsRUFBRTtNQUN0QyxNQUFNLElBQUlqRCxTQUFTLENBQUMsbUNBQW1DLENBQUM7SUFDNUQ7RUFDQSxDQUFDO0VBRUQsSUFBSXdXLFdBQVcsR0FBRyxZQUFZO0lBQzVCLFNBQVNDLGdCQUFnQixDQUFDaGIsTUFBTSxFQUFFaWIsS0FBSyxFQUFFO01BQ3ZDLEtBQUssSUFBSW5SLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBR21SLEtBQUssQ0FBQ2pSLE1BQU0sRUFBRUYsQ0FBQyxFQUFFLEVBQUU7UUFDckMsSUFBSW9SLFVBQVUsR0FBR0QsS0FBSyxDQUFDblIsQ0FBQyxDQUFDO1FBQ3pCb1IsVUFBVSxDQUFDQyxVQUFVLEdBQUdELFVBQVUsQ0FBQ0MsVUFBVSxJQUFJLEtBQUs7UUFDdERELFVBQVUsQ0FBQ0UsWUFBWSxHQUFHLElBQUk7UUFDOUIsSUFBSSxPQUFPLElBQUlGLFVBQVUsRUFBRUEsVUFBVSxDQUFDRyxRQUFRLEdBQUcsSUFBSTtRQUNyRGhZLE1BQU0sQ0FBQ2lZLGNBQWMsQ0FBQ3RiLE1BQU0sRUFBRWtiLFVBQVUsQ0FBQ0ssR0FBRyxFQUFFTCxVQUFVLENBQUM7TUFDL0Q7SUFDQTtJQUVFLE9BQU8sVUFBVTFULFdBQVcsRUFBRWdVLFVBQVUsRUFBRUMsV0FBVyxFQUFFO01BQ3JELElBQUlELFVBQVUsRUFBRVIsZ0JBQWdCLENBQUN4VCxXQUFXLENBQUNsRSxTQUFTLEVBQUVrWSxVQUFVLENBQUM7TUFDbkUsSUFBSUMsV0FBVyxFQUFFVCxnQkFBZ0IsQ0FBQ3hULFdBQVcsRUFBRWlVLFdBQVcsQ0FBQztNQUMzRCxPQUFPalUsV0FBVztJQUN0QixDQUFHO0VBQ0gsQ0FBQyxFQUFFO0VBTUgsSUFBSThULGNBQWMsR0FBRyxTQUFqQkEsY0FBYyxDQUFhamMsR0FBRyxFQUFFa2MsR0FBRyxFQUFFOVgsS0FBSyxFQUFFO0lBQzlDLElBQUk4WCxHQUFHLElBQUlsYyxHQUFHLEVBQUU7TUFDZGdFLE1BQU0sQ0FBQ2lZLGNBQWMsQ0FBQ2pjLEdBQUcsRUFBRWtjLEdBQUcsRUFBRTtRQUM5QjlYLEtBQUssRUFBRUEsS0FBSztRQUNaMFgsVUFBVSxFQUFFLElBQUk7UUFDaEJDLFlBQVksRUFBRSxJQUFJO1FBQ2xCQyxRQUFRLEVBQUU7TUFDaEIsQ0FBSyxDQUFDO0lBQ04sQ0FBRyxNQUFNO01BQ0xoYyxHQUFHLENBQUNrYyxHQUFHLENBQUMsR0FBRzlYLEtBQUs7SUFDcEI7SUFFRSxPQUFPcEUsR0FBRztFQUNaLENBQUM7RUFFRCxJQUFJcWMsUUFBUSxHQUFHclksTUFBTSxDQUFDc1ksTUFBTSxJQUFJLFVBQVUzYixNQUFNLEVBQUU7SUFDaEQsS0FBSyxJQUFJOEosQ0FBQyxHQUFHLENBQUMsRUFBRUEsQ0FBQyxHQUFHekosU0FBUyxDQUFDMkosTUFBTSxFQUFFRixDQUFDLEVBQUUsRUFBRTtNQUN6QyxJQUFJOFIsTUFBTSxHQUFHdmIsU0FBUyxDQUFDeUosQ0FBQyxDQUFDO01BRXpCLEtBQUssSUFBSXlSLEdBQUcsSUFBSUssTUFBTSxFQUFFO1FBQ3RCLElBQUl2WSxNQUFNLENBQUNDLFNBQVMsQ0FBQ0MsY0FBYyxDQUFDaEUsSUFBSSxDQUFDcWMsTUFBTSxFQUFFTCxHQUFHLENBQUMsRUFBRTtVQUNyRHZiLE1BQU0sQ0FBQ3ViLEdBQUcsQ0FBQyxHQUFHSyxNQUFNLENBQUNMLEdBQUcsQ0FBQztRQUNqQztNQUNBO0lBQ0E7SUFFRSxPQUFPdmIsTUFBTTtFQUNmLENBQUM7O0VBRUQ7Ozs7Ozs7RUFPQSxTQUFTNmIsYUFBYSxDQUFDQyxPQUFPLEVBQUU7SUFDOUIsT0FBT0osUUFBUSxDQUFDLEVBQUUsRUFBRUksT0FBTyxFQUFFO01BQzNCN0IsS0FBSyxFQUFFNkIsT0FBTyxDQUFDOUIsSUFBSSxHQUFHOEIsT0FBTyxDQUFDbEIsS0FBSztNQUNuQ2IsTUFBTSxFQUFFK0IsT0FBTyxDQUFDaEMsR0FBRyxHQUFHZ0MsT0FBTyxDQUFDbkI7SUFDbEMsQ0FBRyxDQUFDO0VBQ0o7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTN0YscUJBQXFCLENBQUNwVCxPQUFPLEVBQUU7SUFDdEMsSUFBSStYLElBQUksR0FBRyxFQUFFOztJQUVmO0lBQ0E7SUFDQTtJQUNFLElBQUk7TUFDRixJQUFJNUIsSUFBSSxDQUFDLEVBQUUsQ0FBQyxFQUFFO1FBQ1o0QixJQUFJLEdBQUcvWCxPQUFPLENBQUNvVCxxQkFBcUIsRUFBRTtRQUN0QyxJQUFJNkUsU0FBUyxHQUFHUixTQUFTLENBQUN6WCxPQUFPLEVBQUUsS0FBSyxDQUFDO1FBQ3pDLElBQUlrWSxVQUFVLEdBQUdULFNBQVMsQ0FBQ3pYLE9BQU8sRUFBRSxNQUFNLENBQUM7UUFDM0MrWCxJQUFJLENBQUNLLEdBQUcsSUFBSUgsU0FBUztRQUNyQkYsSUFBSSxDQUFDTyxJQUFJLElBQUlKLFVBQVU7UUFDdkJILElBQUksQ0FBQ00sTUFBTSxJQUFJSixTQUFTO1FBQ3hCRixJQUFJLENBQUNRLEtBQUssSUFBSUwsVUFBVTtNQUM5QixDQUFLLE1BQU07UUFDTEgsSUFBSSxHQUFHL1gsT0FBTyxDQUFDb1QscUJBQXFCLEVBQUU7TUFDNUM7SUFDQSxDQUFHLENBQUMsT0FBTzdFLENBQUMsRUFBRTtJQUVaLElBQUk4TCxNQUFNLEdBQUc7TUFDWC9CLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJO01BQ2ZGLEdBQUcsRUFBRUwsSUFBSSxDQUFDSyxHQUFHO01BQ2JjLEtBQUssRUFBRW5CLElBQUksQ0FBQ1EsS0FBSyxHQUFHUixJQUFJLENBQUNPLElBQUk7TUFDN0JXLE1BQU0sRUFBRWxCLElBQUksQ0FBQ00sTUFBTSxHQUFHTixJQUFJLENBQUNLO0lBQy9CLENBQUc7O0lBRUg7SUFDRSxJQUFJa0MsS0FBSyxHQUFHdGEsT0FBTyxDQUFDb1YsUUFBUSxLQUFLLE1BQU0sR0FBRzRELGNBQWMsQ0FBQ2haLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQyxHQUFHLEVBQUU7SUFDcEYsSUFBSWtFLEtBQUssR0FBR29CLEtBQUssQ0FBQ3BCLEtBQUssSUFBSWxaLE9BQU8sQ0FBQ3VhLFdBQVcsSUFBSUYsTUFBTSxDQUFDbkIsS0FBSztJQUM5RCxJQUFJRCxNQUFNLEdBQUdxQixLQUFLLENBQUNyQixNQUFNLElBQUlqWixPQUFPLENBQUN3YSxZQUFZLElBQUlILE1BQU0sQ0FBQ3BCLE1BQU07SUFFbEUsSUFBSXdCLGNBQWMsR0FBR3phLE9BQU8sQ0FBQzBhLFdBQVcsR0FBR3hCLEtBQUs7SUFDaEQsSUFBSXlCLGFBQWEsR0FBRzNhLE9BQU8sQ0FBQ2dCLFlBQVksR0FBR2lZLE1BQU07O0lBRW5EO0lBQ0E7SUFDRSxJQUFJd0IsY0FBYyxJQUFJRSxhQUFhLEVBQUU7TUFDbkMsSUFBSWxDLE1BQU0sR0FBRzFELHdCQUF3QixDQUFDL1UsT0FBTyxDQUFDO01BQzlDeWEsY0FBYyxJQUFJakMsY0FBYyxDQUFDQyxNQUFNLEVBQUUsR0FBRyxDQUFDO01BQzdDa0MsYUFBYSxJQUFJbkMsY0FBYyxDQUFDQyxNQUFNLEVBQUUsR0FBRyxDQUFDO01BRTVDNEIsTUFBTSxDQUFDbkIsS0FBSyxJQUFJdUIsY0FBYztNQUM5QkosTUFBTSxDQUFDcEIsTUFBTSxJQUFJMEIsYUFBYTtJQUNsQztJQUVFLE9BQU9SLGFBQWEsQ0FBQ0UsTUFBTSxDQUFDO0VBQzlCO0VBRUEsU0FBU08sb0NBQW9DLENBQUNqTCxRQUFRLEVBQUU5SyxNQUFNLEVBQUU7SUFDOUQsSUFBSWdXLGFBQWEsR0FBR2xjLFNBQVMsQ0FBQzJKLE1BQU0sR0FBRyxDQUFDLElBQUkzSixTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUtDLFNBQVMsR0FBR0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUs7SUFFN0YsSUFBSXVYLE1BQU0sR0FBR0MsSUFBSSxDQUFDLEVBQUUsQ0FBQztJQUNyQixJQUFJMkUsTUFBTSxHQUFHalcsTUFBTSxDQUFDdVEsUUFBUSxLQUFLLE1BQU07SUFDdkMsSUFBSTJGLFlBQVksR0FBRzNILHFCQUFxQixDQUFDekQsUUFBUSxDQUFDO0lBQ2xELElBQUlxTCxVQUFVLEdBQUc1SCxxQkFBcUIsQ0FBQ3ZPLE1BQU0sQ0FBQztJQUM5QyxJQUFJb1csWUFBWSxHQUFHM0YsZUFBZSxDQUFDM0YsUUFBUSxDQUFDO0lBRTVDLElBQUk4SSxNQUFNLEdBQUcxRCx3QkFBd0IsQ0FBQ2xRLE1BQU0sQ0FBQztJQUM3QyxJQUFJcVcsY0FBYyxHQUFHdGEsVUFBVSxDQUFDNlgsTUFBTSxDQUFDeUMsY0FBYyxDQUFDO0lBQ3RELElBQUlDLGVBQWUsR0FBR3ZhLFVBQVUsQ0FBQzZYLE1BQU0sQ0FBQzBDLGVBQWUsQ0FBQzs7SUFFMUQ7SUFDRSxJQUFJTixhQUFhLElBQUlDLE1BQU0sRUFBRTtNQUMzQkUsVUFBVSxDQUFDNUMsR0FBRyxHQUFHelksSUFBSSxDQUFDb1osR0FBRyxDQUFDaUMsVUFBVSxDQUFDNUMsR0FBRyxFQUFFLENBQUMsQ0FBQztNQUM1QzRDLFVBQVUsQ0FBQzFDLElBQUksR0FBRzNZLElBQUksQ0FBQ29aLEdBQUcsQ0FBQ2lDLFVBQVUsQ0FBQzFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFDbEQ7SUFDRSxJQUFJOEIsT0FBTyxHQUFHRCxhQUFhLENBQUM7TUFDMUIvQixHQUFHLEVBQUUyQyxZQUFZLENBQUMzQyxHQUFHLEdBQUc0QyxVQUFVLENBQUM1QyxHQUFHLEdBQUc4QyxjQUFjO01BQ3ZENUMsSUFBSSxFQUFFeUMsWUFBWSxDQUFDekMsSUFBSSxHQUFHMEMsVUFBVSxDQUFDMUMsSUFBSSxHQUFHNkMsZUFBZTtNQUMzRGpDLEtBQUssRUFBRTZCLFlBQVksQ0FBQzdCLEtBQUs7TUFDekJELE1BQU0sRUFBRThCLFlBQVksQ0FBQzlCO0lBQ3pCLENBQUcsQ0FBQztJQUNGbUIsT0FBTyxDQUFDZ0IsU0FBUyxHQUFHLENBQUM7SUFDckJoQixPQUFPLENBQUNpQixVQUFVLEdBQUcsQ0FBQzs7SUFFeEI7SUFDQTtJQUNBO0lBQ0E7SUFDRSxJQUFJLENBQUNuRixNQUFNLElBQUk0RSxNQUFNLEVBQUU7TUFDckIsSUFBSU0sU0FBUyxHQUFHeGEsVUFBVSxDQUFDNlgsTUFBTSxDQUFDMkMsU0FBUyxDQUFDO01BQzVDLElBQUlDLFVBQVUsR0FBR3phLFVBQVUsQ0FBQzZYLE1BQU0sQ0FBQzRDLFVBQVUsQ0FBQztNQUU5Q2pCLE9BQU8sQ0FBQ2hDLEdBQUcsSUFBSThDLGNBQWMsR0FBR0UsU0FBUztNQUN6Q2hCLE9BQU8sQ0FBQy9CLE1BQU0sSUFBSTZDLGNBQWMsR0FBR0UsU0FBUztNQUM1Q2hCLE9BQU8sQ0FBQzlCLElBQUksSUFBSTZDLGVBQWUsR0FBR0UsVUFBVTtNQUM1Q2pCLE9BQU8sQ0FBQzdCLEtBQUssSUFBSTRDLGVBQWUsR0FBR0UsVUFBVTs7TUFFakQ7TUFDSWpCLE9BQU8sQ0FBQ2dCLFNBQVMsR0FBR0EsU0FBUztNQUM3QmhCLE9BQU8sQ0FBQ2lCLFVBQVUsR0FBR0EsVUFBVTtJQUNuQztJQUVFLElBQUluRixNQUFNLElBQUksQ0FBQzJFLGFBQWEsR0FBR2hXLE1BQU0sQ0FBQ3dDLFFBQVEsQ0FBQzRULFlBQVksQ0FBQyxHQUFHcFcsTUFBTSxLQUFLb1csWUFBWSxJQUFJQSxZQUFZLENBQUM3RixRQUFRLEtBQUssTUFBTSxFQUFFO01BQzFIZ0YsT0FBTyxHQUFHdEMsYUFBYSxDQUFDc0MsT0FBTyxFQUFFdlYsTUFBTSxDQUFDO0lBQzVDO0lBRUUsT0FBT3VWLE9BQU87RUFDaEI7RUFFQSxTQUFTa0IsNkNBQTZDLENBQUN0YixPQUFPLEVBQUU7SUFDOUQsSUFBSXViLGFBQWEsR0FBRzVjLFNBQVMsQ0FBQzJKLE1BQU0sR0FBRyxDQUFDLElBQUkzSixTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUtDLFNBQVMsR0FBR0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUs7SUFFN0YsSUFBSWlaLElBQUksR0FBRzVYLE9BQU8sQ0FBQ2dWLGFBQWEsQ0FBQzFTLGVBQWU7SUFDaEQsSUFBSWtaLGNBQWMsR0FBR1osb0NBQW9DLENBQUM1YSxPQUFPLEVBQUU0WCxJQUFJLENBQUM7SUFDeEUsSUFBSXNCLEtBQUssR0FBR3ZaLElBQUksQ0FBQ29aLEdBQUcsQ0FBQ25CLElBQUksQ0FBQzJDLFdBQVcsRUFBRXZTLE1BQU0sQ0FBQ3lULFVBQVUsSUFBSSxDQUFDLENBQUM7SUFDOUQsSUFBSXhDLE1BQU0sR0FBR3RaLElBQUksQ0FBQ29aLEdBQUcsQ0FBQ25CLElBQUksQ0FBQzRDLFlBQVksRUFBRXhTLE1BQU0sQ0FBQzBULFdBQVcsSUFBSSxDQUFDLENBQUM7SUFFakUsSUFBSXpELFNBQVMsR0FBRyxDQUFDc0QsYUFBYSxHQUFHOUQsU0FBUyxDQUFDRyxJQUFJLENBQUMsR0FBRyxDQUFDO0lBQ3BELElBQUlNLFVBQVUsR0FBRyxDQUFDcUQsYUFBYSxHQUFHOUQsU0FBUyxDQUFDRyxJQUFJLEVBQUUsTUFBTSxDQUFDLEdBQUcsQ0FBQztJQUU3RCxJQUFJK0QsTUFBTSxHQUFHO01BQ1h2RCxHQUFHLEVBQUVILFNBQVMsR0FBR3VELGNBQWMsQ0FBQ3BELEdBQUcsR0FBR29ELGNBQWMsQ0FBQ0osU0FBUztNQUM5RDlDLElBQUksRUFBRUosVUFBVSxHQUFHc0QsY0FBYyxDQUFDbEQsSUFBSSxHQUFHa0QsY0FBYyxDQUFDSCxVQUFVO01BQ2xFbkMsS0FBSyxFQUFFQSxLQUFLO01BQ1pELE1BQU0sRUFBRUE7SUFDWixDQUFHO0lBRUQsT0FBT2tCLGFBQWEsQ0FBQ3dCLE1BQU0sQ0FBQztFQUM5Qjs7RUFFQTs7Ozs7Ozs7RUFRQSxTQUFTQyxPQUFPLENBQUM1YixPQUFPLEVBQUU7SUFDeEIsSUFBSW9WLFFBQVEsR0FBR3BWLE9BQU8sQ0FBQ29WLFFBQVE7SUFDL0IsSUFBSUEsUUFBUSxLQUFLLE1BQU0sSUFBSUEsUUFBUSxLQUFLLE1BQU0sRUFBRTtNQUM5QyxPQUFPLEtBQUs7SUFDaEI7SUFDRSxJQUFJTCx3QkFBd0IsQ0FBQy9VLE9BQU8sRUFBRSxVQUFVLENBQUMsS0FBSyxPQUFPLEVBQUU7TUFDN0QsT0FBTyxJQUFJO0lBQ2Y7SUFDRSxJQUFJMkMsVUFBVSxHQUFHd1MsYUFBYSxDQUFDblYsT0FBTyxDQUFDO0lBQ3ZDLElBQUksQ0FBQzJDLFVBQVUsRUFBRTtNQUNmLE9BQU8sS0FBSztJQUNoQjtJQUNFLE9BQU9pWixPQUFPLENBQUNqWixVQUFVLENBQUM7RUFDNUI7O0VBRUE7Ozs7Ozs7O0VBUUEsU0FBU2taLDRCQUE0QixDQUFDN2IsT0FBTyxFQUFFO0lBQy9DO0lBQ0UsSUFBSSxDQUFDQSxPQUFPLElBQUksQ0FBQ0EsT0FBTyxDQUFDOGIsYUFBYSxJQUFJM0YsSUFBSSxFQUFFLEVBQUU7TUFDaEQsT0FBT3RXLFFBQVEsQ0FBQ3lDLGVBQWU7SUFDbkM7SUFDRSxJQUFJeVosRUFBRSxHQUFHL2IsT0FBTyxDQUFDOGIsYUFBYTtJQUM5QixPQUFPQyxFQUFFLElBQUloSCx3QkFBd0IsQ0FBQ2dILEVBQUUsRUFBRSxXQUFXLENBQUMsS0FBSyxNQUFNLEVBQUU7TUFDakVBLEVBQUUsR0FBR0EsRUFBRSxDQUFDRCxhQUFhO0lBQ3pCO0lBQ0UsT0FBT0MsRUFBRSxJQUFJbGMsUUFBUSxDQUFDeUMsZUFBZTtFQUN2Qzs7RUFFQTs7Ozs7Ozs7Ozs7RUFXQSxTQUFTMFosYUFBYSxDQUFDQyxNQUFNLEVBQUVwRyxTQUFTLEVBQUVxRyxPQUFPLEVBQUVDLGlCQUFpQixFQUFFO0lBQ3BFLElBQUl0QixhQUFhLEdBQUdsYyxTQUFTLENBQUMySixNQUFNLEdBQUcsQ0FBQyxJQUFJM0osU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLQyxTQUFTLEdBQUdELFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLOztJQUUvRjs7SUFFRSxJQUFJeWQsVUFBVSxHQUFHO01BQUVoRSxHQUFHLEVBQUUsQ0FBQztNQUFFRSxJQUFJLEVBQUU7SUFBQyxDQUFFO0lBQ3BDLElBQUloQyxZQUFZLEdBQUd1RSxhQUFhLEdBQUdnQiw0QkFBNEIsQ0FBQ0ksTUFBTSxDQUFDLEdBQUdyRixzQkFBc0IsQ0FBQ3FGLE1BQU0sRUFBRXJHLGdCQUFnQixDQUFDQyxTQUFTLENBQUMsQ0FBQzs7SUFFdkk7SUFDRSxJQUFJc0csaUJBQWlCLEtBQUssVUFBVSxFQUFFO01BQ3BDQyxVQUFVLEdBQUdkLDZDQUE2QyxDQUFDaEYsWUFBWSxFQUFFdUUsYUFBYSxDQUFDO0lBQzNGLENBQUcsTUFBTTtNQUNUO01BQ0ksSUFBSXdCLGNBQWMsR0FBRyxLQUFLLENBQUM7TUFDM0IsSUFBSUYsaUJBQWlCLEtBQUssY0FBYyxFQUFFO1FBQ3hDRSxjQUFjLEdBQUcvRyxlQUFlLENBQUNILGFBQWEsQ0FBQ1UsU0FBUyxDQUFDLENBQUM7UUFDMUQsSUFBSXdHLGNBQWMsQ0FBQ2pILFFBQVEsS0FBSyxNQUFNLEVBQUU7VUFDdENpSCxjQUFjLEdBQUdKLE1BQU0sQ0FBQ2pILGFBQWEsQ0FBQzFTLGVBQWU7UUFDN0Q7TUFDQSxDQUFLLE1BQU0sSUFBSTZaLGlCQUFpQixLQUFLLFFBQVEsRUFBRTtRQUN6Q0UsY0FBYyxHQUFHSixNQUFNLENBQUNqSCxhQUFhLENBQUMxUyxlQUFlO01BQzNELENBQUssTUFBTTtRQUNMK1osY0FBYyxHQUFHRixpQkFBaUI7TUFDeEM7TUFFSSxJQUFJL0IsT0FBTyxHQUFHUSxvQ0FBb0MsQ0FBQ3lCLGNBQWMsRUFBRS9GLFlBQVksRUFBRXVFLGFBQWEsQ0FBQzs7TUFFbkc7TUFDSSxJQUFJd0IsY0FBYyxDQUFDakgsUUFBUSxLQUFLLE1BQU0sSUFBSSxDQUFDd0csT0FBTyxDQUFDdEYsWUFBWSxDQUFDLEVBQUU7UUFDaEUsSUFBSWdHLGVBQWUsR0FBR3RELGNBQWMsQ0FBQ2lELE1BQU0sQ0FBQ2pILGFBQWEsQ0FBQztVQUN0RGlFLE1BQU0sR0FBR3FELGVBQWUsQ0FBQ3JELE1BQU07VUFDL0JDLEtBQUssR0FBR29ELGVBQWUsQ0FBQ3BELEtBQUs7UUFFakNrRCxVQUFVLENBQUNoRSxHQUFHLElBQUlnQyxPQUFPLENBQUNoQyxHQUFHLEdBQUdnQyxPQUFPLENBQUNnQixTQUFTO1FBQ2pEZ0IsVUFBVSxDQUFDL0QsTUFBTSxHQUFHWSxNQUFNLEdBQUdtQixPQUFPLENBQUNoQyxHQUFHO1FBQ3hDZ0UsVUFBVSxDQUFDOUQsSUFBSSxJQUFJOEIsT0FBTyxDQUFDOUIsSUFBSSxHQUFHOEIsT0FBTyxDQUFDaUIsVUFBVTtRQUNwRGUsVUFBVSxDQUFDN0QsS0FBSyxHQUFHVyxLQUFLLEdBQUdrQixPQUFPLENBQUM5QixJQUFJO01BQzdDLENBQUssTUFBTTtRQUNYO1FBQ004RCxVQUFVLEdBQUdoQyxPQUFPO01BQzFCO0lBQ0E7O0lBRUE7SUFDRThCLE9BQU8sR0FBR0EsT0FBTyxJQUFJLENBQUM7SUFDdEIsSUFBSUssZUFBZSxHQUFHLE9BQU9MLE9BQU8sS0FBSyxRQUFRO0lBQ2pERSxVQUFVLENBQUM5RCxJQUFJLElBQUlpRSxlQUFlLEdBQUdMLE9BQU8sR0FBR0EsT0FBTyxDQUFDNUQsSUFBSSxJQUFJLENBQUM7SUFDaEU4RCxVQUFVLENBQUNoRSxHQUFHLElBQUltRSxlQUFlLEdBQUdMLE9BQU8sR0FBR0EsT0FBTyxDQUFDOUQsR0FBRyxJQUFJLENBQUM7SUFDOURnRSxVQUFVLENBQUM3RCxLQUFLLElBQUlnRSxlQUFlLEdBQUdMLE9BQU8sR0FBR0EsT0FBTyxDQUFDM0QsS0FBSyxJQUFJLENBQUM7SUFDbEU2RCxVQUFVLENBQUMvRCxNQUFNLElBQUlrRSxlQUFlLEdBQUdMLE9BQU8sR0FBR0EsT0FBTyxDQUFDN0QsTUFBTSxJQUFJLENBQUM7SUFFcEUsT0FBTytELFVBQVU7RUFDbkI7RUFFQSxTQUFTSSxPQUFPLENBQUNDLElBQUksRUFBRTtJQUNyQixJQUFJdkQsS0FBSyxHQUFHdUQsSUFBSSxDQUFDdkQsS0FBSztNQUNsQkQsTUFBTSxHQUFHd0QsSUFBSSxDQUFDeEQsTUFBTTtJQUV4QixPQUFPQyxLQUFLLEdBQUdELE1BQU07RUFDdkI7O0VBRUE7Ozs7Ozs7OztFQVNBLFNBQVN5RCxvQkFBb0IsQ0FBQ0MsU0FBUyxFQUFFQyxPQUFPLEVBQUVYLE1BQU0sRUFBRXBHLFNBQVMsRUFBRXNHLGlCQUFpQixFQUFFO0lBQ3RGLElBQUlELE9BQU8sR0FBR3ZkLFNBQVMsQ0FBQzJKLE1BQU0sR0FBRyxDQUFDLElBQUkzSixTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUtDLFNBQVMsR0FBR0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUM7SUFFbkYsSUFBSWdlLFNBQVMsQ0FBQ2xPLE9BQU8sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtNQUNwQyxPQUFPa08sU0FBUztJQUNwQjtJQUVFLElBQUlQLFVBQVUsR0FBR0osYUFBYSxDQUFDQyxNQUFNLEVBQUVwRyxTQUFTLEVBQUVxRyxPQUFPLEVBQUVDLGlCQUFpQixDQUFDO0lBRTdFLElBQUlVLEtBQUssR0FBRztNQUNWekUsR0FBRyxFQUFFO1FBQ0hjLEtBQUssRUFBRWtELFVBQVUsQ0FBQ2xELEtBQUs7UUFDdkJELE1BQU0sRUFBRTJELE9BQU8sQ0FBQ3hFLEdBQUcsR0FBR2dFLFVBQVUsQ0FBQ2hFO01BQ3ZDLENBQUs7TUFDREcsS0FBSyxFQUFFO1FBQ0xXLEtBQUssRUFBRWtELFVBQVUsQ0FBQzdELEtBQUssR0FBR3FFLE9BQU8sQ0FBQ3JFLEtBQUs7UUFDdkNVLE1BQU0sRUFBRW1ELFVBQVUsQ0FBQ25EO01BQ3pCLENBQUs7TUFDRFosTUFBTSxFQUFFO1FBQ05hLEtBQUssRUFBRWtELFVBQVUsQ0FBQ2xELEtBQUs7UUFDdkJELE1BQU0sRUFBRW1ELFVBQVUsQ0FBQy9ELE1BQU0sR0FBR3VFLE9BQU8sQ0FBQ3ZFO01BQzFDLENBQUs7TUFDREMsSUFBSSxFQUFFO1FBQ0pZLEtBQUssRUFBRTBELE9BQU8sQ0FBQ3RFLElBQUksR0FBRzhELFVBQVUsQ0FBQzlELElBQUk7UUFDckNXLE1BQU0sRUFBRW1ELFVBQVUsQ0FBQ25EO01BQ3pCO0lBQ0EsQ0FBRztJQUVELElBQUk2RCxXQUFXLEdBQUduYixNQUFNLENBQUNvYixJQUFJLENBQUNGLEtBQUssQ0FBQyxDQUFDRyxHQUFHLENBQUMsVUFBVW5ELEdBQUcsRUFBRTtNQUN0RCxPQUFPRyxRQUFRLENBQUM7UUFDZEgsR0FBRyxFQUFFQTtNQUNYLENBQUssRUFBRWdELEtBQUssQ0FBQ2hELEdBQUcsQ0FBQyxFQUFFO1FBQ2JvRCxJQUFJLEVBQUVULE9BQU8sQ0FBQ0ssS0FBSyxDQUFDaEQsR0FBRyxDQUFDO01BQzlCLENBQUssQ0FBQztJQUNOLENBQUcsQ0FBQyxDQUFDcUQsSUFBSSxDQUFDLFVBQVVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO01BQ3RCLE9BQU9BLENBQUMsQ0FBQ0gsSUFBSSxHQUFHRSxDQUFDLENBQUNGLElBQUk7SUFDMUIsQ0FBRyxDQUFDO0lBRUYsSUFBSUksYUFBYSxHQUFHUCxXQUFXLENBQUMvSyxNQUFNLENBQUMsVUFBVXVMLEtBQUssRUFBRTtNQUN0RCxJQUFJcEUsS0FBSyxHQUFHb0UsS0FBSyxDQUFDcEUsS0FBSztRQUNuQkQsTUFBTSxHQUFHcUUsS0FBSyxDQUFDckUsTUFBTTtNQUN6QixPQUFPQyxLQUFLLElBQUkrQyxNQUFNLENBQUMxQixXQUFXLElBQUl0QixNQUFNLElBQUlnRCxNQUFNLENBQUN6QixZQUFZO0lBQ3ZFLENBQUcsQ0FBQztJQUVGLElBQUkrQyxpQkFBaUIsR0FBR0YsYUFBYSxDQUFDL1UsTUFBTSxHQUFHLENBQUMsR0FBRytVLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQ3hELEdBQUcsR0FBR2lELFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQ2pELEdBQUc7SUFFNUYsSUFBSTJELFNBQVMsR0FBR2IsU0FBUyxDQUFDN2IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUV2QyxPQUFPeWMsaUJBQWlCLElBQUlDLFNBQVMsR0FBRyxHQUFHLEdBQUdBLFNBQVMsR0FBRyxFQUFFLENBQUM7RUFDL0Q7O0VBRUE7Ozs7Ozs7Ozs7RUFVQSxTQUFTQyxtQkFBbUIsQ0FBQ0MsS0FBSyxFQUFFekIsTUFBTSxFQUFFcEcsU0FBUyxFQUFFO0lBQ3JELElBQUlnRixhQUFhLEdBQUdsYyxTQUFTLENBQUMySixNQUFNLEdBQUcsQ0FBQyxJQUFJM0osU0FBUyxDQUFDLENBQUMsQ0FBQyxLQUFLQyxTQUFTLEdBQUdELFNBQVMsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJO0lBRTVGLElBQUlnZixrQkFBa0IsR0FBRzlDLGFBQWEsR0FBR2dCLDRCQUE0QixDQUFDSSxNQUFNLENBQUMsR0FBR3JGLHNCQUFzQixDQUFDcUYsTUFBTSxFQUFFckcsZ0JBQWdCLENBQUNDLFNBQVMsQ0FBQyxDQUFDO0lBQzNJLE9BQU8rRSxvQ0FBb0MsQ0FBQy9FLFNBQVMsRUFBRThILGtCQUFrQixFQUFFOUMsYUFBYSxDQUFDO0VBQzNGOztFQUVBOzs7Ozs7O0VBT0EsU0FBUytDLGFBQWEsQ0FBQzVkLE9BQU8sRUFBRTtJQUM5QixJQUFJZ0ksTUFBTSxHQUFHaEksT0FBTyxDQUFDZ1YsYUFBYSxDQUFDQyxXQUFXO0lBQzlDLElBQUl3RCxNQUFNLEdBQUd6USxNQUFNLENBQUNrTixnQkFBZ0IsQ0FBQ2xWLE9BQU8sQ0FBQztJQUM3QyxJQUFJNmQsQ0FBQyxHQUFHamQsVUFBVSxDQUFDNlgsTUFBTSxDQUFDMkMsU0FBUyxJQUFJLENBQUMsQ0FBQyxHQUFHeGEsVUFBVSxDQUFDNlgsTUFBTSxDQUFDcUYsWUFBWSxJQUFJLENBQUMsQ0FBQztJQUNoRixJQUFJQyxDQUFDLEdBQUduZCxVQUFVLENBQUM2WCxNQUFNLENBQUM0QyxVQUFVLElBQUksQ0FBQyxDQUFDLEdBQUd6YSxVQUFVLENBQUM2WCxNQUFNLENBQUN1RixXQUFXLElBQUksQ0FBQyxDQUFDO0lBQ2hGLElBQUkzRCxNQUFNLEdBQUc7TUFDWG5CLEtBQUssRUFBRWxaLE9BQU8sQ0FBQzBhLFdBQVcsR0FBR3FELENBQUM7TUFDOUI5RSxNQUFNLEVBQUVqWixPQUFPLENBQUNnQixZQUFZLEdBQUc2YztJQUNuQyxDQUFHO0lBQ0QsT0FBT3hELE1BQU07RUFDZjs7RUFFQTs7Ozs7OztFQU9BLFNBQVM0RCxvQkFBb0IsQ0FBQ3RCLFNBQVMsRUFBRTtJQUN2QyxJQUFJdUIsSUFBSSxHQUFHO01BQUU1RixJQUFJLEVBQUUsT0FBTztNQUFFQyxLQUFLLEVBQUUsTUFBTTtNQUFFRixNQUFNLEVBQUUsS0FBSztNQUFFRCxHQUFHLEVBQUU7SUFBUSxDQUFFO0lBQ3pFLE9BQU91RSxTQUFTLENBQUN3QixPQUFPLENBQUMsd0JBQXdCLEVBQUUsVUFBVUMsT0FBTyxFQUFFO01BQ3BFLE9BQU9GLElBQUksQ0FBQ0UsT0FBTyxDQUFDO0lBQ3hCLENBQUcsQ0FBQztFQUNKOztFQUVBOzs7Ozs7Ozs7O0VBVUEsU0FBU0MsZ0JBQWdCLENBQUNwQyxNQUFNLEVBQUVxQyxnQkFBZ0IsRUFBRTNCLFNBQVMsRUFBRTtJQUM3REEsU0FBUyxHQUFHQSxTQUFTLENBQUM3YixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDOztJQUVyQztJQUNFLElBQUl5ZCxVQUFVLEdBQUdYLGFBQWEsQ0FBQzNCLE1BQU0sQ0FBQzs7SUFFeEM7SUFDRSxJQUFJdUMsYUFBYSxHQUFHO01BQ2xCdEYsS0FBSyxFQUFFcUYsVUFBVSxDQUFDckYsS0FBSztNQUN2QkQsTUFBTSxFQUFFc0YsVUFBVSxDQUFDdEY7SUFDdkIsQ0FBRzs7SUFFSDtJQUNFLElBQUl3RixPQUFPLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUNoUSxPQUFPLENBQUNrTyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDekQsSUFBSStCLFFBQVEsR0FBR0QsT0FBTyxHQUFHLEtBQUssR0FBRyxNQUFNO0lBQ3ZDLElBQUlFLGFBQWEsR0FBR0YsT0FBTyxHQUFHLE1BQU0sR0FBRyxLQUFLO0lBQzVDLElBQUlHLFdBQVcsR0FBR0gsT0FBTyxHQUFHLFFBQVEsR0FBRyxPQUFPO0lBQzlDLElBQUlJLG9CQUFvQixHQUFHLENBQUNKLE9BQU8sR0FBRyxRQUFRLEdBQUcsT0FBTztJQUV4REQsYUFBYSxDQUFDRSxRQUFRLENBQUMsR0FBR0osZ0JBQWdCLENBQUNJLFFBQVEsQ0FBQyxHQUFHSixnQkFBZ0IsQ0FBQ00sV0FBVyxDQUFDLEdBQUcsQ0FBQyxHQUFHTCxVQUFVLENBQUNLLFdBQVcsQ0FBQyxHQUFHLENBQUM7SUFDdEgsSUFBSWpDLFNBQVMsS0FBS2dDLGFBQWEsRUFBRTtNQUMvQkgsYUFBYSxDQUFDRyxhQUFhLENBQUMsR0FBR0wsZ0JBQWdCLENBQUNLLGFBQWEsQ0FBQyxHQUFHSixVQUFVLENBQUNNLG9CQUFvQixDQUFDO0lBQ3JHLENBQUcsTUFBTTtNQUNMTCxhQUFhLENBQUNHLGFBQWEsQ0FBQyxHQUFHTCxnQkFBZ0IsQ0FBQ0wsb0JBQW9CLENBQUNVLGFBQWEsQ0FBQyxDQUFDO0lBQ3hGO0lBRUUsT0FBT0gsYUFBYTtFQUN0Qjs7RUFFQTs7Ozs7Ozs7O0VBU0EsU0FBU00sSUFBSSxDQUFDQyxHQUFHLEVBQUVDLEtBQUssRUFBRTtJQUMxQjtJQUNFLElBQUlDLEtBQUssQ0FBQ3JkLFNBQVMsQ0FBQ2tkLElBQUksRUFBRTtNQUN4QixPQUFPQyxHQUFHLENBQUNELElBQUksQ0FBQ0UsS0FBSyxDQUFDO0lBQzFCOztJQUVBO0lBQ0UsT0FBT0QsR0FBRyxDQUFDaE4sTUFBTSxDQUFDaU4sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0VBQzdCOztFQUVBOzs7Ozs7Ozs7RUFTQSxTQUFTRSxTQUFTLENBQUNILEdBQUcsRUFBRUksSUFBSSxFQUFFcGQsS0FBSyxFQUFFO0lBQ3JDO0lBQ0UsSUFBSWtkLEtBQUssQ0FBQ3JkLFNBQVMsQ0FBQ3NkLFNBQVMsRUFBRTtNQUM3QixPQUFPSCxHQUFHLENBQUNHLFNBQVMsQ0FBQyxVQUFVRSxHQUFHLEVBQUU7UUFDbEMsT0FBT0EsR0FBRyxDQUFDRCxJQUFJLENBQUMsS0FBS3BkLEtBQUs7TUFDaEMsQ0FBSyxDQUFDO0lBQ047O0lBRUE7SUFDRSxJQUFJakUsS0FBSyxHQUFHZ2hCLElBQUksQ0FBQ0MsR0FBRyxFQUFFLFVBQVVwaEIsR0FBRyxFQUFFO01BQ25DLE9BQU9BLEdBQUcsQ0FBQ3doQixJQUFJLENBQUMsS0FBS3BkLEtBQUs7SUFDOUIsQ0FBRyxDQUFDO0lBQ0YsT0FBT2dkLEdBQUcsQ0FBQ3RRLE9BQU8sQ0FBQzNRLEtBQUssQ0FBQztFQUMzQjs7RUFFQTs7Ozs7Ozs7OztFQVVBLFNBQVN1aEIsWUFBWSxDQUFDQyxTQUFTLEVBQUU3WixJQUFJLEVBQUU4WixJQUFJLEVBQUU7SUFDM0MsSUFBSUMsY0FBYyxHQUFHRCxJQUFJLEtBQUszZ0IsU0FBUyxHQUFHMGdCLFNBQVMsR0FBR0EsU0FBUyxDQUFDcFgsS0FBSyxDQUFDLENBQUMsRUFBRWdYLFNBQVMsQ0FBQ0ksU0FBUyxFQUFFLE1BQU0sRUFBRUMsSUFBSSxDQUFDLENBQUM7SUFFNUdDLGNBQWMsQ0FBQ0MsT0FBTyxDQUFDLFVBQVV0SCxRQUFRLEVBQUU7TUFDekMsSUFBSUEsUUFBUSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQzlCO1FBQ011SCxPQUFPLENBQUNDLElBQUksQ0FBQyx1REFBdUQsQ0FBQztNQUMzRTtNQUNJLElBQUlyZ0IsRUFBRSxHQUFHNlksUUFBUSxDQUFDLFVBQVUsQ0FBQyxJQUFJQSxRQUFRLENBQUM3WSxFQUFFLENBQUM7TUFDN0MsSUFBSTZZLFFBQVEsQ0FBQ3lILE9BQU8sSUFBSWhMLFVBQVUsQ0FBQ3RWLEVBQUUsQ0FBQyxFQUFFO1FBQzVDO1FBQ0E7UUFDQTtRQUNNbUcsSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTSxHQUFHOUIsYUFBYSxDQUFDMVUsSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTSxDQUFDO1FBQ3hEeFcsSUFBSSxDQUFDMlUsT0FBTyxDQUFDdkUsU0FBUyxHQUFHc0UsYUFBYSxDQUFDMVUsSUFBSSxDQUFDMlUsT0FBTyxDQUFDdkUsU0FBUyxDQUFDO1FBRTlEcFEsSUFBSSxHQUFHbkcsRUFBRSxDQUFDbUcsSUFBSSxFQUFFMFMsUUFBUSxDQUFDO01BQy9CO0lBQ0EsQ0FBRyxDQUFDO0lBRUYsT0FBTzFTLElBQUk7RUFDYjs7RUFFQTs7Ozs7OztFQU9BLFNBQVNvYSxNQUFNLEdBQUc7SUFDbEI7SUFDRSxJQUFJLElBQUksQ0FBQ25DLEtBQUssQ0FBQ29DLFdBQVcsRUFBRTtNQUMxQjtJQUNKO0lBRUUsSUFBSXJhLElBQUksR0FBRztNQUNUMlQsUUFBUSxFQUFFLElBQUk7TUFDZFgsTUFBTSxFQUFFLEVBQUU7TUFDVnNILFdBQVcsRUFBRSxFQUFFO01BQ2ZDLFVBQVUsRUFBRSxFQUFFO01BQ2RDLE9BQU8sRUFBRSxLQUFLO01BQ2Q3RixPQUFPLEVBQUU7SUFDYixDQUFHOztJQUVIO0lBQ0UzVSxJQUFJLENBQUMyVSxPQUFPLENBQUN2RSxTQUFTLEdBQUc0SCxtQkFBbUIsQ0FBQyxJQUFJLENBQUNDLEtBQUssRUFBRSxJQUFJLENBQUN6QixNQUFNLEVBQUUsSUFBSSxDQUFDcEcsU0FBUyxFQUFFLElBQUksQ0FBQ3FLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDOztJQUVuSDtJQUNBO0lBQ0E7SUFDRTFhLElBQUksQ0FBQ2tYLFNBQVMsR0FBR0Qsb0JBQW9CLENBQUMsSUFBSSxDQUFDd0QsT0FBTyxDQUFDdkQsU0FBUyxFQUFFbFgsSUFBSSxDQUFDMlUsT0FBTyxDQUFDdkUsU0FBUyxFQUFFLElBQUksQ0FBQ29HLE1BQU0sRUFBRSxJQUFJLENBQUNwRyxTQUFTLEVBQUUsSUFBSSxDQUFDcUssT0FBTyxDQUFDWixTQUFTLENBQUNjLElBQUksQ0FBQ2pFLGlCQUFpQixFQUFFLElBQUksQ0FBQytELE9BQU8sQ0FBQ1osU0FBUyxDQUFDYyxJQUFJLENBQUNsRSxPQUFPLENBQUM7O0lBRXhNO0lBQ0V6VyxJQUFJLENBQUM0YSxpQkFBaUIsR0FBRzVhLElBQUksQ0FBQ2tYLFNBQVM7SUFFdkNsWCxJQUFJLENBQUMwYSxhQUFhLEdBQUcsSUFBSSxDQUFDRCxPQUFPLENBQUNDLGFBQWE7O0lBRWpEO0lBQ0UxYSxJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLEdBQUdvQyxnQkFBZ0IsQ0FBQyxJQUFJLENBQUNwQyxNQUFNLEVBQUV4VyxJQUFJLENBQUMyVSxPQUFPLENBQUN2RSxTQUFTLEVBQUVwUSxJQUFJLENBQUNrWCxTQUFTLENBQUM7SUFFM0ZsWCxJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLENBQUNxRSxRQUFRLEdBQUcsSUFBSSxDQUFDSixPQUFPLENBQUNDLGFBQWEsR0FBRyxPQUFPLEdBQUcsVUFBVTs7SUFFbEY7SUFDRTFhLElBQUksR0FBRzRaLFlBQVksQ0FBQyxJQUFJLENBQUNDLFNBQVMsRUFBRTdaLElBQUksQ0FBQzs7SUFFM0M7SUFDQTtJQUNFLElBQUksQ0FBQyxJQUFJLENBQUNpWSxLQUFLLENBQUM2QyxTQUFTLEVBQUU7TUFDekIsSUFBSSxDQUFDN0MsS0FBSyxDQUFDNkMsU0FBUyxHQUFHLElBQUk7TUFDM0IsSUFBSSxDQUFDTCxPQUFPLENBQUNNLFFBQVEsQ0FBQy9hLElBQUksQ0FBQztJQUMvQixDQUFHLE1BQU07TUFDTCxJQUFJLENBQUN5YSxPQUFPLENBQUNPLFFBQVEsQ0FBQ2hiLElBQUksQ0FBQztJQUMvQjtFQUNBOztFQUVBOzs7Ozs7RUFNQSxTQUFTaWIsaUJBQWlCLENBQUNwQixTQUFTLEVBQUVxQixZQUFZLEVBQUU7SUFDbEQsT0FBT3JCLFNBQVMsQ0FBQ3NCLElBQUksQ0FBQyxVQUFVbkUsSUFBSSxFQUFFO01BQ3BDLElBQUlvRSxJQUFJLEdBQUdwRSxJQUFJLENBQUNvRSxJQUFJO1FBQ2hCakIsT0FBTyxHQUFHbkQsSUFBSSxDQUFDbUQsT0FBTztNQUMxQixPQUFPQSxPQUFPLElBQUlpQixJQUFJLEtBQUtGLFlBQVk7SUFDM0MsQ0FBRyxDQUFDO0VBQ0o7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTRyx3QkFBd0IsQ0FBQ3BmLFFBQVEsRUFBRTtJQUMxQyxJQUFJcWYsUUFBUSxHQUFHLENBQUMsS0FBSyxFQUFFLElBQUksRUFBRSxRQUFRLEVBQUUsS0FBSyxFQUFFLEdBQUcsQ0FBQztJQUNsRCxJQUFJQyxTQUFTLEdBQUd0ZixRQUFRLENBQUN1ZixNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUM3ZSxXQUFXLEVBQUUsR0FBR1YsUUFBUSxDQUFDd0csS0FBSyxDQUFDLENBQUMsQ0FBQztJQUVwRSxLQUFLLElBQUlFLENBQUMsR0FBRyxDQUFDLEVBQUVBLENBQUMsR0FBRzJZLFFBQVEsQ0FBQ3pZLE1BQU0sRUFBRUYsQ0FBQyxFQUFFLEVBQUU7TUFDeEMsSUFBSTFJLE1BQU0sR0FBR3FoQixRQUFRLENBQUMzWSxDQUFDLENBQUM7TUFDeEIsSUFBSThZLE9BQU8sR0FBR3hoQixNQUFNLEdBQUcsRUFBRSxHQUFHQSxNQUFNLEdBQUdzaEIsU0FBUyxHQUFHdGYsUUFBUTtNQUN6RCxJQUFJLE9BQU83QixRQUFRLENBQUMwVixJQUFJLENBQUN6QyxLQUFLLENBQUNvTyxPQUFPLENBQUMsS0FBSyxXQUFXLEVBQUU7UUFDdkQsT0FBT0EsT0FBTztNQUNwQjtJQUNBO0lBQ0UsT0FBTyxJQUFJO0VBQ2I7O0VBRUE7Ozs7O0VBS0EsU0FBU0MsT0FBTyxHQUFHO0lBQ2pCLElBQUksQ0FBQ3pELEtBQUssQ0FBQ29DLFdBQVcsR0FBRyxJQUFJOztJQUUvQjtJQUNFLElBQUlZLGlCQUFpQixDQUFDLElBQUksQ0FBQ3BCLFNBQVMsRUFBRSxZQUFZLENBQUMsRUFBRTtNQUNuRCxJQUFJLENBQUNyRCxNQUFNLENBQUNtRixlQUFlLENBQUMsYUFBYSxDQUFDO01BQzFDLElBQUksQ0FBQ25GLE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3dOLFFBQVEsR0FBRyxFQUFFO01BQy9CLElBQUksQ0FBQ3JFLE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3NGLEdBQUcsR0FBRyxFQUFFO01BQzFCLElBQUksQ0FBQzZELE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3dGLElBQUksR0FBRyxFQUFFO01BQzNCLElBQUksQ0FBQzJELE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3lGLEtBQUssR0FBRyxFQUFFO01BQzVCLElBQUksQ0FBQzBELE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3VGLE1BQU0sR0FBRyxFQUFFO01BQzdCLElBQUksQ0FBQzRELE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ3VPLFVBQVUsR0FBRyxFQUFFO01BQ2pDLElBQUksQ0FBQ3BGLE1BQU0sQ0FBQ25KLEtBQUssQ0FBQ2dPLHdCQUF3QixDQUFDLFdBQVcsQ0FBQyxDQUFDLEdBQUcsRUFBRTtJQUNqRTtJQUVFLElBQUksQ0FBQ1EscUJBQXFCLEVBQUU7O0lBRTlCO0lBQ0E7SUFDRSxJQUFJLElBQUksQ0FBQ3BCLE9BQU8sQ0FBQ3FCLGVBQWUsRUFBRTtNQUNoQyxJQUFJLENBQUN0RixNQUFNLENBQUN0WixVQUFVLENBQUM2ZSxXQUFXLENBQUMsSUFBSSxDQUFDdkYsTUFBTSxDQUFDO0lBQ25EO0lBQ0UsT0FBTyxJQUFJO0VBQ2I7O0VBRUE7Ozs7O0VBS0EsU0FBU3dGLFNBQVMsQ0FBQ3poQixPQUFPLEVBQUU7SUFDMUIsSUFBSWdWLGFBQWEsR0FBR2hWLE9BQU8sQ0FBQ2dWLGFBQWE7SUFDekMsT0FBT0EsYUFBYSxHQUFHQSxhQUFhLENBQUNDLFdBQVcsR0FBR2pOLE1BQU07RUFDM0Q7RUFFQSxTQUFTMFoscUJBQXFCLENBQUN6RyxZQUFZLEVBQUU3YyxLQUFLLEVBQUV1akIsUUFBUSxFQUFFQyxhQUFhLEVBQUU7SUFDM0UsSUFBSUMsTUFBTSxHQUFHNUcsWUFBWSxDQUFDN0YsUUFBUSxLQUFLLE1BQU07SUFDN0MsSUFBSTlXLE1BQU0sR0FBR3VqQixNQUFNLEdBQUc1RyxZQUFZLENBQUNqRyxhQUFhLENBQUNDLFdBQVcsR0FBR2dHLFlBQVk7SUFDM0UzYyxNQUFNLENBQUN3akIsZ0JBQWdCLENBQUMxakIsS0FBSyxFQUFFdWpCLFFBQVEsRUFBRTtNQUFFSSxPQUFPLEVBQUU7SUFBSSxDQUFFLENBQUM7SUFFM0QsSUFBSSxDQUFDRixNQUFNLEVBQUU7TUFDWEgscUJBQXFCLENBQUNwTSxlQUFlLENBQUNoWCxNQUFNLENBQUNxRSxVQUFVLENBQUMsRUFBRXZFLEtBQUssRUFBRXVqQixRQUFRLEVBQUVDLGFBQWEsQ0FBQztJQUM3RjtJQUNFQSxhQUFhLENBQUMxUCxJQUFJLENBQUM1VCxNQUFNLENBQUM7RUFDNUI7O0VBRUE7Ozs7OztFQU1BLFNBQVMwakIsbUJBQW1CLENBQUNuTSxTQUFTLEVBQUVxSyxPQUFPLEVBQUV4QyxLQUFLLEVBQUV1RSxXQUFXLEVBQUU7SUFDckU7SUFDRXZFLEtBQUssQ0FBQ3VFLFdBQVcsR0FBR0EsV0FBVztJQUMvQlIsU0FBUyxDQUFDNUwsU0FBUyxDQUFDLENBQUNpTSxnQkFBZ0IsQ0FBQyxRQUFRLEVBQUVwRSxLQUFLLENBQUN1RSxXQUFXLEVBQUU7TUFBRUYsT0FBTyxFQUFFO0lBQUksQ0FBRSxDQUFDOztJQUV2RjtJQUNFLElBQUlHLGFBQWEsR0FBRzVNLGVBQWUsQ0FBQ08sU0FBUyxDQUFDO0lBQzlDNkwscUJBQXFCLENBQUNRLGFBQWEsRUFBRSxRQUFRLEVBQUV4RSxLQUFLLENBQUN1RSxXQUFXLEVBQUV2RSxLQUFLLENBQUNrRSxhQUFhLENBQUM7SUFDdEZsRSxLQUFLLENBQUN3RSxhQUFhLEdBQUdBLGFBQWE7SUFDbkN4RSxLQUFLLENBQUN5RSxhQUFhLEdBQUcsSUFBSTtJQUUxQixPQUFPekUsS0FBSztFQUNkOztFQUVBOzs7Ozs7RUFNQSxTQUFTMEUsb0JBQW9CLEdBQUc7SUFDOUIsSUFBSSxDQUFDLElBQUksQ0FBQzFFLEtBQUssQ0FBQ3lFLGFBQWEsRUFBRTtNQUM3QixJQUFJLENBQUN6RSxLQUFLLEdBQUdzRSxtQkFBbUIsQ0FBQyxJQUFJLENBQUNuTSxTQUFTLEVBQUUsSUFBSSxDQUFDcUssT0FBTyxFQUFFLElBQUksQ0FBQ3hDLEtBQUssRUFBRSxJQUFJLENBQUMyRSxjQUFjLENBQUM7SUFDbkc7RUFDQTs7RUFFQTs7Ozs7O0VBTUEsU0FBU0Msb0JBQW9CLENBQUN6TSxTQUFTLEVBQUU2SCxLQUFLLEVBQUU7SUFDaEQ7SUFDRStELFNBQVMsQ0FBQzVMLFNBQVMsQ0FBQyxDQUFDME0sbUJBQW1CLENBQUMsUUFBUSxFQUFFN0UsS0FBSyxDQUFDdUUsV0FBVyxDQUFDOztJQUV2RTtJQUNFdkUsS0FBSyxDQUFDa0UsYUFBYSxDQUFDbkMsT0FBTyxDQUFDLFVBQVVuaEIsTUFBTSxFQUFFO01BQzVDQSxNQUFNLENBQUNpa0IsbUJBQW1CLENBQUMsUUFBUSxFQUFFN0UsS0FBSyxDQUFDdUUsV0FBVyxDQUFDO0lBQzNELENBQUcsQ0FBQzs7SUFFSjtJQUNFdkUsS0FBSyxDQUFDdUUsV0FBVyxHQUFHLElBQUk7SUFDeEJ2RSxLQUFLLENBQUNrRSxhQUFhLEdBQUcsRUFBRTtJQUN4QmxFLEtBQUssQ0FBQ3dFLGFBQWEsR0FBRyxJQUFJO0lBQzFCeEUsS0FBSyxDQUFDeUUsYUFBYSxHQUFHLEtBQUs7SUFDM0IsT0FBT3pFLEtBQUs7RUFDZDs7RUFFQTs7Ozs7OztFQU9BLFNBQVM0RCxxQkFBcUIsR0FBRztJQUMvQixJQUFJLElBQUksQ0FBQzVELEtBQUssQ0FBQ3lFLGFBQWEsRUFBRTtNQUM1Qkssb0JBQW9CLENBQUMsSUFBSSxDQUFDSCxjQUFjLENBQUM7TUFDekMsSUFBSSxDQUFDM0UsS0FBSyxHQUFHNEUsb0JBQW9CLENBQUMsSUFBSSxDQUFDek0sU0FBUyxFQUFFLElBQUksQ0FBQzZILEtBQUssQ0FBQztJQUNqRTtFQUNBOztFQUVBOzs7Ozs7O0VBT0EsU0FBUytFLFNBQVMsQ0FBQ0MsQ0FBQyxFQUFFO0lBQ3BCLE9BQU9BLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQ0MsS0FBSyxDQUFDL2hCLFVBQVUsQ0FBQzhoQixDQUFDLENBQUMsQ0FBQyxJQUFJRSxRQUFRLENBQUNGLENBQUMsQ0FBQztFQUN6RDs7RUFFQTs7Ozs7Ozs7RUFRQSxTQUFTRyxTQUFTLENBQUM3aUIsT0FBTyxFQUFFeVksTUFBTSxFQUFFO0lBQ2xDOVcsTUFBTSxDQUFDb2IsSUFBSSxDQUFDdEUsTUFBTSxDQUFDLENBQUNnSCxPQUFPLENBQUMsVUFBVU4sSUFBSSxFQUFFO01BQzFDLElBQUkyRCxJQUFJLEdBQUcsRUFBRTtNQUNqQjtNQUNJLElBQUksQ0FBQyxPQUFPLEVBQUUsUUFBUSxFQUFFLEtBQUssRUFBRSxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sQ0FBQyxDQUFDclUsT0FBTyxDQUFDMFEsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLElBQUlzRCxTQUFTLENBQUNoSyxNQUFNLENBQUMwRyxJQUFJLENBQUMsQ0FBQyxFQUFFO1FBQ3pHMkQsSUFBSSxHQUFHLElBQUk7TUFDakI7TUFDSTlpQixPQUFPLENBQUM4UyxLQUFLLENBQUNxTSxJQUFJLENBQUMsR0FBRzFHLE1BQU0sQ0FBQzBHLElBQUksQ0FBQyxHQUFHMkQsSUFBSTtJQUM3QyxDQUFHLENBQUM7RUFDSjs7RUFFQTs7Ozs7Ozs7RUFRQSxTQUFTQyxhQUFhLENBQUMvaUIsT0FBTyxFQUFFZ2dCLFVBQVUsRUFBRTtJQUMxQ3JlLE1BQU0sQ0FBQ29iLElBQUksQ0FBQ2lELFVBQVUsQ0FBQyxDQUFDUCxPQUFPLENBQUMsVUFBVU4sSUFBSSxFQUFFO01BQzlDLElBQUlwZCxLQUFLLEdBQUdpZSxVQUFVLENBQUNiLElBQUksQ0FBQztNQUM1QixJQUFJcGQsS0FBSyxLQUFLLEtBQUssRUFBRTtRQUNuQi9CLE9BQU8sQ0FBQ3lILFlBQVksQ0FBQzBYLElBQUksRUFBRWEsVUFBVSxDQUFDYixJQUFJLENBQUMsQ0FBQztNQUNsRCxDQUFLLE1BQU07UUFDTG5mLE9BQU8sQ0FBQ29oQixlQUFlLENBQUNqQyxJQUFJLENBQUM7TUFDbkM7SUFDQSxDQUFHLENBQUM7RUFDSjs7RUFFQTs7Ozs7Ozs7O0VBU0EsU0FBUzZELFVBQVUsQ0FBQ3ZkLElBQUksRUFBRTtJQUMxQjtJQUNBO0lBQ0E7SUFDQTtJQUNFb2QsU0FBUyxDQUFDcGQsSUFBSSxDQUFDMlQsUUFBUSxDQUFDNkMsTUFBTSxFQUFFeFcsSUFBSSxDQUFDZ1QsTUFBTSxDQUFDOztJQUU5QztJQUNBO0lBQ0VzSyxhQUFhLENBQUN0ZCxJQUFJLENBQUMyVCxRQUFRLENBQUM2QyxNQUFNLEVBQUV4VyxJQUFJLENBQUN1YSxVQUFVLENBQUM7O0lBRXREO0lBQ0UsSUFBSXZhLElBQUksQ0FBQ3dkLFlBQVksSUFBSXRoQixNQUFNLENBQUNvYixJQUFJLENBQUN0WCxJQUFJLENBQUNzYSxXQUFXLENBQUMsQ0FBQ3pYLE1BQU0sRUFBRTtNQUM3RHVhLFNBQVMsQ0FBQ3BkLElBQUksQ0FBQ3dkLFlBQVksRUFBRXhkLElBQUksQ0FBQ3NhLFdBQVcsQ0FBQztJQUNsRDtJQUVFLE9BQU90YSxJQUFJO0VBQ2I7O0VBRUE7Ozs7Ozs7Ozs7RUFVQSxTQUFTeWQsZ0JBQWdCLENBQUNyTixTQUFTLEVBQUVvRyxNQUFNLEVBQUVpRSxPQUFPLEVBQUVpRCxlQUFlLEVBQUV6RixLQUFLLEVBQUU7SUFDOUU7SUFDRSxJQUFJWSxnQkFBZ0IsR0FBR2IsbUJBQW1CLENBQUNDLEtBQUssRUFBRXpCLE1BQU0sRUFBRXBHLFNBQVMsRUFBRXFLLE9BQU8sQ0FBQ0MsYUFBYSxDQUFDOztJQUU3RjtJQUNBO0lBQ0E7SUFDRSxJQUFJeEQsU0FBUyxHQUFHRCxvQkFBb0IsQ0FBQ3dELE9BQU8sQ0FBQ3ZELFNBQVMsRUFBRTJCLGdCQUFnQixFQUFFckMsTUFBTSxFQUFFcEcsU0FBUyxFQUFFcUssT0FBTyxDQUFDWixTQUFTLENBQUNjLElBQUksQ0FBQ2pFLGlCQUFpQixFQUFFK0QsT0FBTyxDQUFDWixTQUFTLENBQUNjLElBQUksQ0FBQ2xFLE9BQU8sQ0FBQztJQUV0S0QsTUFBTSxDQUFDeFUsWUFBWSxDQUFDLGFBQWEsRUFBRWtWLFNBQVMsQ0FBQzs7SUFFL0M7SUFDQTtJQUNFa0csU0FBUyxDQUFDNUcsTUFBTSxFQUFFO01BQUVxRSxRQUFRLEVBQUVKLE9BQU8sQ0FBQ0MsYUFBYSxHQUFHLE9BQU8sR0FBRztJQUFVLENBQUUsQ0FBQztJQUU3RSxPQUFPRCxPQUFPO0VBQ2hCOztFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBbUJBLFNBQVNrRCxpQkFBaUIsQ0FBQzNkLElBQUksRUFBRTRkLFdBQVcsRUFBRTtJQUM1QyxJQUFJQyxhQUFhLEdBQUc3ZCxJQUFJLENBQUMyVSxPQUFPO01BQzVCNkIsTUFBTSxHQUFHcUgsYUFBYSxDQUFDckgsTUFBTTtNQUM3QnBHLFNBQVMsR0FBR3lOLGFBQWEsQ0FBQ3pOLFNBQVM7SUFDdkMsSUFBSTBOLEtBQUssR0FBRzVqQixJQUFJLENBQUM0akIsS0FBSztNQUNsQkMsS0FBSyxHQUFHN2pCLElBQUksQ0FBQzZqQixLQUFLO0lBRXRCLElBQUlDLE9BQU8sR0FBRyxTQUFTQSxPQUFPLENBQUNDLENBQUMsRUFBRTtNQUNoQyxPQUFPQSxDQUFDO0lBQ1osQ0FBRztJQUVELElBQUlDLGNBQWMsR0FBR0osS0FBSyxDQUFDMU4sU0FBUyxDQUFDcUQsS0FBSyxDQUFDO0lBQzNDLElBQUkwSyxXQUFXLEdBQUdMLEtBQUssQ0FBQ3RILE1BQU0sQ0FBQy9DLEtBQUssQ0FBQztJQUVyQyxJQUFJMkssVUFBVSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDcFYsT0FBTyxDQUFDaEosSUFBSSxDQUFDa1gsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2pFLElBQUltSCxXQUFXLEdBQUdyZSxJQUFJLENBQUNrWCxTQUFTLENBQUNsTyxPQUFPLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3BELElBQUlzVixlQUFlLEdBQUdKLGNBQWMsR0FBRyxDQUFDLEtBQUtDLFdBQVcsR0FBRyxDQUFDO0lBQzVELElBQUlJLFlBQVksR0FBR0wsY0FBYyxHQUFHLENBQUMsS0FBSyxDQUFDLElBQUlDLFdBQVcsR0FBRyxDQUFDLEtBQUssQ0FBQztJQUVwRSxJQUFJSyxtQkFBbUIsR0FBRyxDQUFDWixXQUFXLEdBQUdJLE9BQU8sR0FBR0ksVUFBVSxJQUFJQyxXQUFXLElBQUlDLGVBQWUsR0FBR1IsS0FBSyxHQUFHQyxLQUFLO0lBQy9HLElBQUlVLGlCQUFpQixHQUFHLENBQUNiLFdBQVcsR0FBR0ksT0FBTyxHQUFHRixLQUFLO0lBRXRELE9BQU87TUFDTGpMLElBQUksRUFBRTJMLG1CQUFtQixDQUFDRCxZQUFZLElBQUksQ0FBQ0YsV0FBVyxJQUFJVCxXQUFXLEdBQUdwSCxNQUFNLENBQUMzRCxJQUFJLEdBQUcsQ0FBQyxHQUFHMkQsTUFBTSxDQUFDM0QsSUFBSSxDQUFDO01BQ3RHRixHQUFHLEVBQUU4TCxpQkFBaUIsQ0FBQ2pJLE1BQU0sQ0FBQzdELEdBQUcsQ0FBQztNQUNsQ0MsTUFBTSxFQUFFNkwsaUJBQWlCLENBQUNqSSxNQUFNLENBQUM1RCxNQUFNLENBQUM7TUFDeENFLEtBQUssRUFBRTBMLG1CQUFtQixDQUFDaEksTUFBTSxDQUFDMUQsS0FBSztJQUMzQyxDQUFHO0VBQ0g7RUFFQSxJQUFJNEwsU0FBUyxHQUFHblEsU0FBUyxJQUFJLFVBQVUsQ0FBQzlSLElBQUksQ0FBQytKLFNBQVMsQ0FBQ2tJLFNBQVMsQ0FBQzs7RUFFakU7Ozs7Ozs7RUFPQSxTQUFTaVEsWUFBWSxDQUFDM2UsSUFBSSxFQUFFeWEsT0FBTyxFQUFFO0lBQ25DLElBQUlyQyxDQUFDLEdBQUdxQyxPQUFPLENBQUNyQyxDQUFDO01BQ2JFLENBQUMsR0FBR21DLE9BQU8sQ0FBQ25DLENBQUM7SUFDakIsSUFBSTlCLE1BQU0sR0FBR3hXLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU07O0lBRWxDOztJQUVFLElBQUlvSSwyQkFBMkIsR0FBR3ZGLElBQUksQ0FBQ3JaLElBQUksQ0FBQzJULFFBQVEsQ0FBQ2tHLFNBQVMsRUFBRSxVQUFVbkgsUUFBUSxFQUFFO01BQ2xGLE9BQU9BLFFBQVEsQ0FBQzBJLElBQUksS0FBSyxZQUFZO0lBQ3pDLENBQUcsQ0FBQyxDQUFDeUQsZUFBZTtJQUNsQixJQUFJRCwyQkFBMkIsS0FBS3psQixTQUFTLEVBQUU7TUFDN0M4Z0IsT0FBTyxDQUFDQyxJQUFJLENBQUMsK0hBQStILENBQUM7SUFDako7SUFDRSxJQUFJMkUsZUFBZSxHQUFHRCwyQkFBMkIsS0FBS3psQixTQUFTLEdBQUd5bEIsMkJBQTJCLEdBQUduRSxPQUFPLENBQUNvRSxlQUFlO0lBRXZILElBQUloTyxZQUFZLEdBQUdGLGVBQWUsQ0FBQzNRLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sQ0FBQztJQUN4RCxJQUFJc0ksZ0JBQWdCLEdBQUduUixxQkFBcUIsQ0FBQ2tELFlBQVksQ0FBQzs7SUFFNUQ7SUFDRSxJQUFJbUMsTUFBTSxHQUFHO01BQ1g2SCxRQUFRLEVBQUVyRSxNQUFNLENBQUNxRTtJQUNyQixDQUFHO0lBRUQsSUFBSWxHLE9BQU8sR0FBR2dKLGlCQUFpQixDQUFDM2QsSUFBSSxFQUFFdUMsTUFBTSxDQUFDd2MsZ0JBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUNMLFNBQVMsQ0FBQztJQUVoRixJQUFJeEwsS0FBSyxHQUFHa0YsQ0FBQyxLQUFLLFFBQVEsR0FBRyxLQUFLLEdBQUcsUUFBUTtJQUM3QyxJQUFJakYsS0FBSyxHQUFHbUYsQ0FBQyxLQUFLLE9BQU8sR0FBRyxNQUFNLEdBQUcsT0FBTzs7SUFFOUM7SUFDQTtJQUNBO0lBQ0UsSUFBSTBHLGdCQUFnQixHQUFHM0Qsd0JBQXdCLENBQUMsV0FBVyxDQUFDOztJQUU5RDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDRSxJQUFJeEksSUFBSSxHQUFHLEtBQUssQ0FBQztNQUNiRixHQUFHLEdBQUcsS0FBSyxDQUFDO0lBQ2hCLElBQUlPLEtBQUssS0FBSyxRQUFRLEVBQUU7TUFDMUI7TUFDQTtNQUNJLElBQUlyQyxZQUFZLENBQUNsQixRQUFRLEtBQUssTUFBTSxFQUFFO1FBQ3BDZ0QsR0FBRyxHQUFHLENBQUM5QixZQUFZLENBQUNrRSxZQUFZLEdBQUdKLE9BQU8sQ0FBQy9CLE1BQU07TUFDdkQsQ0FBSyxNQUFNO1FBQ0xELEdBQUcsR0FBRyxDQUFDbU0sZ0JBQWdCLENBQUN0TCxNQUFNLEdBQUdtQixPQUFPLENBQUMvQixNQUFNO01BQ3JEO0lBQ0EsQ0FBRyxNQUFNO01BQ0xELEdBQUcsR0FBR2dDLE9BQU8sQ0FBQ2hDLEdBQUc7SUFDckI7SUFDRSxJQUFJUSxLQUFLLEtBQUssT0FBTyxFQUFFO01BQ3JCLElBQUl0QyxZQUFZLENBQUNsQixRQUFRLEtBQUssTUFBTSxFQUFFO1FBQ3BDa0QsSUFBSSxHQUFHLENBQUNoQyxZQUFZLENBQUNpRSxXQUFXLEdBQUdILE9BQU8sQ0FBQzdCLEtBQUs7TUFDdEQsQ0FBSyxNQUFNO1FBQ0xELElBQUksR0FBRyxDQUFDaU0sZ0JBQWdCLENBQUNyTCxLQUFLLEdBQUdrQixPQUFPLENBQUM3QixLQUFLO01BQ3BEO0lBQ0EsQ0FBRyxNQUFNO01BQ0xELElBQUksR0FBRzhCLE9BQU8sQ0FBQzlCLElBQUk7SUFDdkI7SUFDRSxJQUFJZ00sZUFBZSxJQUFJRyxnQkFBZ0IsRUFBRTtNQUN2Q2hNLE1BQU0sQ0FBQ2dNLGdCQUFnQixDQUFDLEdBQUcsY0FBYyxHQUFHbk0sSUFBSSxHQUFHLE1BQU0sR0FBR0YsR0FBRyxHQUFHLFFBQVE7TUFDMUVLLE1BQU0sQ0FBQ0UsS0FBSyxDQUFDLEdBQUcsQ0FBQztNQUNqQkYsTUFBTSxDQUFDRyxLQUFLLENBQUMsR0FBRyxDQUFDO01BQ2pCSCxNQUFNLENBQUM0SSxVQUFVLEdBQUcsV0FBVztJQUNuQyxDQUFHLE1BQU07TUFDVDtNQUNJLElBQUlxRCxTQUFTLEdBQUcvTCxLQUFLLEtBQUssUUFBUSxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUM7TUFDM0MsSUFBSWdNLFVBQVUsR0FBRy9MLEtBQUssS0FBSyxPQUFPLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQztNQUMzQ0gsTUFBTSxDQUFDRSxLQUFLLENBQUMsR0FBR1AsR0FBRyxHQUFHc00sU0FBUztNQUMvQmpNLE1BQU0sQ0FBQ0csS0FBSyxDQUFDLEdBQUdOLElBQUksR0FBR3FNLFVBQVU7TUFDakNsTSxNQUFNLENBQUM0SSxVQUFVLEdBQUcxSSxLQUFLLEdBQUcsSUFBSSxHQUFHQyxLQUFLO0lBQzVDOztJQUVBO0lBQ0UsSUFBSW9ILFVBQVUsR0FBRztNQUNmLGFBQWEsRUFBRXZhLElBQUksQ0FBQ2tYO0lBQ3hCLENBQUc7O0lBRUg7SUFDRWxYLElBQUksQ0FBQ3VhLFVBQVUsR0FBR2hHLFFBQVEsQ0FBQyxFQUFFLEVBQUVnRyxVQUFVLEVBQUV2YSxJQUFJLENBQUN1YSxVQUFVLENBQUM7SUFDM0R2YSxJQUFJLENBQUNnVCxNQUFNLEdBQUd1QixRQUFRLENBQUMsRUFBRSxFQUFFdkIsTUFBTSxFQUFFaFQsSUFBSSxDQUFDZ1QsTUFBTSxDQUFDO0lBQy9DaFQsSUFBSSxDQUFDc2EsV0FBVyxHQUFHL0YsUUFBUSxDQUFDLEVBQUUsRUFBRXZVLElBQUksQ0FBQzJVLE9BQU8sQ0FBQ3dLLEtBQUssRUFBRW5mLElBQUksQ0FBQ3NhLFdBQVcsQ0FBQztJQUVyRSxPQUFPdGEsSUFBSTtFQUNiOztFQUVBOzs7Ozs7Ozs7O0VBVUEsU0FBU29mLGtCQUFrQixDQUFDdkYsU0FBUyxFQUFFd0YsY0FBYyxFQUFFQyxhQUFhLEVBQUU7SUFDcEUsSUFBSUMsVUFBVSxHQUFHbEcsSUFBSSxDQUFDUSxTQUFTLEVBQUUsVUFBVTdDLElBQUksRUFBRTtNQUMvQyxJQUFJb0UsSUFBSSxHQUFHcEUsSUFBSSxDQUFDb0UsSUFBSTtNQUNwQixPQUFPQSxJQUFJLEtBQUtpRSxjQUFjO0lBQ2xDLENBQUcsQ0FBQztJQUVGLElBQUlHLFVBQVUsR0FBRyxDQUFDLENBQUNELFVBQVUsSUFBSTFGLFNBQVMsQ0FBQ3NCLElBQUksQ0FBQyxVQUFVekksUUFBUSxFQUFFO01BQ2xFLE9BQU9BLFFBQVEsQ0FBQzBJLElBQUksS0FBS2tFLGFBQWEsSUFBSTVNLFFBQVEsQ0FBQ3lILE9BQU8sSUFBSXpILFFBQVEsQ0FBQ3BCLEtBQUssR0FBR2lPLFVBQVUsQ0FBQ2pPLEtBQUs7SUFDbkcsQ0FBRyxDQUFDO0lBRUYsSUFBSSxDQUFDa08sVUFBVSxFQUFFO01BQ2YsSUFBSUMsV0FBVyxHQUFHLEdBQUcsR0FBR0osY0FBYyxHQUFHLEdBQUc7TUFDNUMsSUFBSUssU0FBUyxHQUFHLEdBQUcsR0FBR0osYUFBYSxHQUFHLEdBQUc7TUFDekNyRixPQUFPLENBQUNDLElBQUksQ0FBQ3dGLFNBQVMsR0FBRywyQkFBMkIsR0FBR0QsV0FBVyxHQUFHLDJEQUEyRCxHQUFHQSxXQUFXLEdBQUcsR0FBRyxDQUFDO0lBQ3pKO0lBQ0UsT0FBT0QsVUFBVTtFQUNuQjs7RUFFQTs7Ozs7OztFQU9BLFNBQVNMLEtBQUssQ0FBQ25mLElBQUksRUFBRXlhLE9BQU8sRUFBRTtJQUM1QixJQUFJa0YsbUJBQW1COztJQUV6QjtJQUNFLElBQUksQ0FBQ1Asa0JBQWtCLENBQUNwZixJQUFJLENBQUMyVCxRQUFRLENBQUNrRyxTQUFTLEVBQUUsT0FBTyxFQUFFLGNBQWMsQ0FBQyxFQUFFO01BQ3pFLE9BQU83WixJQUFJO0lBQ2Y7SUFFRSxJQUFJd2QsWUFBWSxHQUFHL0MsT0FBTyxDQUFDbGdCLE9BQU87O0lBRXBDO0lBQ0UsSUFBSSxPQUFPaWpCLFlBQVksS0FBSyxRQUFRLEVBQUU7TUFDcENBLFlBQVksR0FBR3hkLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sQ0FBQzViLGFBQWEsQ0FBQzRpQixZQUFZLENBQUM7O01BRW5FO01BQ0ksSUFBSSxDQUFDQSxZQUFZLEVBQUU7UUFDakIsT0FBT3hkLElBQUk7TUFDakI7SUFDQSxDQUFHLE1BQU07TUFDVDtNQUNBO01BQ0ksSUFBSSxDQUFDQSxJQUFJLENBQUMyVCxRQUFRLENBQUM2QyxNQUFNLENBQUM1VSxRQUFRLENBQUM0YixZQUFZLENBQUMsRUFBRTtRQUNoRHZELE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLCtEQUErRCxDQUFDO1FBQzdFLE9BQU9sYSxJQUFJO01BQ2pCO0lBQ0E7SUFFRSxJQUFJa1gsU0FBUyxHQUFHbFgsSUFBSSxDQUFDa1gsU0FBUyxDQUFDN2IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFJd2lCLGFBQWEsR0FBRzdkLElBQUksQ0FBQzJVLE9BQU87TUFDNUI2QixNQUFNLEdBQUdxSCxhQUFhLENBQUNySCxNQUFNO01BQzdCcEcsU0FBUyxHQUFHeU4sYUFBYSxDQUFDek4sU0FBUztJQUV2QyxJQUFJZ08sVUFBVSxHQUFHLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDcFYsT0FBTyxDQUFDa08sU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRTVELElBQUl0VSxHQUFHLEdBQUd3YixVQUFVLEdBQUcsUUFBUSxHQUFHLE9BQU87SUFDekMsSUFBSXdCLGVBQWUsR0FBR3hCLFVBQVUsR0FBRyxLQUFLLEdBQUcsTUFBTTtJQUNqRCxJQUFJbk0sSUFBSSxHQUFHMk4sZUFBZSxDQUFDdG5CLFdBQVcsRUFBRTtJQUN4QyxJQUFJdW5CLE9BQU8sR0FBR3pCLFVBQVUsR0FBRyxNQUFNLEdBQUcsS0FBSztJQUN6QyxJQUFJMEIsTUFBTSxHQUFHMUIsVUFBVSxHQUFHLFFBQVEsR0FBRyxPQUFPO0lBQzVDLElBQUkyQixnQkFBZ0IsR0FBRzVILGFBQWEsQ0FBQ3FGLFlBQVksQ0FBQyxDQUFDNWEsR0FBRyxDQUFDOztJQUV6RDtJQUNBO0lBQ0E7SUFDQTs7SUFFQTtJQUNFLElBQUl3TixTQUFTLENBQUMwUCxNQUFNLENBQUMsR0FBR0MsZ0JBQWdCLEdBQUd2SixNQUFNLENBQUN2RSxJQUFJLENBQUMsRUFBRTtNQUN2RGpTLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU0sQ0FBQ3ZFLElBQUksQ0FBQyxJQUFJdUUsTUFBTSxDQUFDdkUsSUFBSSxDQUFDLElBQUk3QixTQUFTLENBQUMwUCxNQUFNLENBQUMsR0FBR0MsZ0JBQWdCLENBQUM7SUFDdEY7SUFDQTtJQUNFLElBQUkzUCxTQUFTLENBQUM2QixJQUFJLENBQUMsR0FBRzhOLGdCQUFnQixHQUFHdkosTUFBTSxDQUFDc0osTUFBTSxDQUFDLEVBQUU7TUFDdkQ5ZixJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLENBQUN2RSxJQUFJLENBQUMsSUFBSTdCLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxHQUFHOE4sZ0JBQWdCLEdBQUd2SixNQUFNLENBQUNzSixNQUFNLENBQUM7SUFDcEY7SUFDRTlmLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU0sR0FBRzlCLGFBQWEsQ0FBQzFVLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU0sQ0FBQzs7SUFFMUQ7SUFDRSxJQUFJd0osTUFBTSxHQUFHNVAsU0FBUyxDQUFDNkIsSUFBSSxDQUFDLEdBQUc3QixTQUFTLENBQUN4TixHQUFHLENBQUMsR0FBRyxDQUFDLEdBQUdtZCxnQkFBZ0IsR0FBRyxDQUFDOztJQUUxRTtJQUNBO0lBQ0UsSUFBSS9rQixHQUFHLEdBQUdzVSx3QkFBd0IsQ0FBQ3RQLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sQ0FBQztJQUN4RCxJQUFJeUosZ0JBQWdCLEdBQUc5a0IsVUFBVSxDQUFDSCxHQUFHLENBQUMsUUFBUSxHQUFHNGtCLGVBQWUsQ0FBQyxDQUFDO0lBQ2xFLElBQUlNLGdCQUFnQixHQUFHL2tCLFVBQVUsQ0FBQ0gsR0FBRyxDQUFDLFFBQVEsR0FBRzRrQixlQUFlLEdBQUcsT0FBTyxDQUFDLENBQUM7SUFDNUUsSUFBSU8sU0FBUyxHQUFHSCxNQUFNLEdBQUdoZ0IsSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTSxDQUFDdkUsSUFBSSxDQUFDLEdBQUdnTyxnQkFBZ0IsR0FBR0MsZ0JBQWdCOztJQUUxRjtJQUNFQyxTQUFTLEdBQUdqbUIsSUFBSSxDQUFDb1osR0FBRyxDQUFDcFosSUFBSSxDQUFDa21CLEdBQUcsQ0FBQzVKLE1BQU0sQ0FBQzVULEdBQUcsQ0FBQyxHQUFHbWQsZ0JBQWdCLEVBQUVJLFNBQVMsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUU1RW5nQixJQUFJLENBQUN3ZCxZQUFZLEdBQUdBLFlBQVk7SUFDaEN4ZCxJQUFJLENBQUMyVSxPQUFPLENBQUN3SyxLQUFLLElBQUlRLG1CQUFtQixHQUFHLEVBQUUsRUFBRXhMLGNBQWMsQ0FBQ3dMLG1CQUFtQixFQUFFMU4sSUFBSSxFQUFFL1gsSUFBSSxDQUFDNGpCLEtBQUssQ0FBQ3FDLFNBQVMsQ0FBQyxDQUFDLEVBQUVoTSxjQUFjLENBQUN3TCxtQkFBbUIsRUFBRUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxFQUFFRixtQkFBbUIsQ0FBQztJQUV4TCxPQUFPM2YsSUFBSTtFQUNiOztFQUVBOzs7Ozs7O0VBT0EsU0FBU3FnQixvQkFBb0IsQ0FBQ3RJLFNBQVMsRUFBRTtJQUN2QyxJQUFJQSxTQUFTLEtBQUssS0FBSyxFQUFFO01BQ3ZCLE9BQU8sT0FBTztJQUNsQixDQUFHLE1BQU0sSUFBSUEsU0FBUyxLQUFLLE9BQU8sRUFBRTtNQUNoQyxPQUFPLEtBQUs7SUFDaEI7SUFDRSxPQUFPQSxTQUFTO0VBQ2xCOztFQUVBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBK0JBLElBQUl1SSxVQUFVLEdBQUcsQ0FBQyxZQUFZLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxXQUFXLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsT0FBTyxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsUUFBUSxFQUFFLGNBQWMsRUFBRSxVQUFVLEVBQUUsTUFBTSxFQUFFLFlBQVksQ0FBQzs7RUFFak07RUFDQSxJQUFJQyxlQUFlLEdBQUdELFVBQVUsQ0FBQzdkLEtBQUssQ0FBQyxDQUFDLENBQUM7O0VBRXpDOzs7Ozs7Ozs7O0VBVUEsU0FBUytkLFNBQVMsQ0FBQ3RKLFNBQVMsRUFBRTtJQUM1QixJQUFJdUosT0FBTyxHQUFHdm5CLFNBQVMsQ0FBQzJKLE1BQU0sR0FBRyxDQUFDLElBQUkzSixTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUtDLFNBQVMsR0FBR0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEtBQUs7SUFFdkYsSUFBSXdPLEtBQUssR0FBRzZZLGVBQWUsQ0FBQ3ZYLE9BQU8sQ0FBQ2tPLFNBQVMsQ0FBQztJQUM5QyxJQUFJb0MsR0FBRyxHQUFHaUgsZUFBZSxDQUFDOWQsS0FBSyxDQUFDaUYsS0FBSyxHQUFHLENBQUMsQ0FBQyxDQUFDZ1osTUFBTSxDQUFDSCxlQUFlLENBQUM5ZCxLQUFLLENBQUMsQ0FBQyxFQUFFaUYsS0FBSyxDQUFDLENBQUM7SUFDbEYsT0FBTytZLE9BQU8sR0FBR25ILEdBQUcsQ0FBQ3FILE9BQU8sRUFBRSxHQUFHckgsR0FBRztFQUN0QztFQUVBLElBQUlzSCxTQUFTLEdBQUc7SUFDZEMsSUFBSSxFQUFFLE1BQU07SUFDWkMsU0FBUyxFQUFFLFdBQVc7SUFDdEJDLGdCQUFnQixFQUFFO0VBQ3BCLENBQUM7O0VBRUQ7Ozs7Ozs7RUFPQSxTQUFTcEcsSUFBSSxDQUFDM2EsSUFBSSxFQUFFeWEsT0FBTyxFQUFFO0lBQzdCO0lBQ0UsSUFBSVEsaUJBQWlCLENBQUNqYixJQUFJLENBQUMyVCxRQUFRLENBQUNrRyxTQUFTLEVBQUUsT0FBTyxDQUFDLEVBQUU7TUFDdkQsT0FBTzdaLElBQUk7SUFDZjtJQUVFLElBQUlBLElBQUksQ0FBQ3dhLE9BQU8sSUFBSXhhLElBQUksQ0FBQ2tYLFNBQVMsS0FBS2xYLElBQUksQ0FBQzRhLGlCQUFpQixFQUFFO01BQ2pFO01BQ0ksT0FBTzVhLElBQUk7SUFDZjtJQUVFLElBQUkyVyxVQUFVLEdBQUdKLGFBQWEsQ0FBQ3ZXLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sRUFBRXhXLElBQUksQ0FBQzJULFFBQVEsQ0FBQ3ZELFNBQVMsRUFBRXFLLE9BQU8sQ0FBQ2hFLE9BQU8sRUFBRWdFLE9BQU8sQ0FBQy9ELGlCQUFpQixFQUFFMVcsSUFBSSxDQUFDMGEsYUFBYSxDQUFDO0lBRTdJLElBQUl4RCxTQUFTLEdBQUdsWCxJQUFJLENBQUNrWCxTQUFTLENBQUM3YixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQzVDLElBQUkybEIsaUJBQWlCLEdBQUd4SSxvQkFBb0IsQ0FBQ3RCLFNBQVMsQ0FBQztJQUN2RCxJQUFJYSxTQUFTLEdBQUcvWCxJQUFJLENBQUNrWCxTQUFTLENBQUM3YixLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRTtJQUVsRCxJQUFJNGxCLFNBQVMsR0FBRyxFQUFFO0lBRWxCLFFBQVF4RyxPQUFPLENBQUN5RyxRQUFRO01BQ3RCLEtBQUtOLFNBQVMsQ0FBQ0MsSUFBSTtRQUNqQkksU0FBUyxHQUFHLENBQUMvSixTQUFTLEVBQUU4SixpQkFBaUIsQ0FBQztRQUMxQztNQUNGLEtBQUtKLFNBQVMsQ0FBQ0UsU0FBUztRQUN0QkcsU0FBUyxHQUFHVCxTQUFTLENBQUN0SixTQUFTLENBQUM7UUFDaEM7TUFDRixLQUFLMEosU0FBUyxDQUFDRyxnQkFBZ0I7UUFDN0JFLFNBQVMsR0FBR1QsU0FBUyxDQUFDdEosU0FBUyxFQUFFLElBQUksQ0FBQztRQUN0QztNQUNGO1FBQ0UrSixTQUFTLEdBQUd4RyxPQUFPLENBQUN5RyxRQUFRO0lBQUM7SUFHakNELFNBQVMsQ0FBQ2pILE9BQU8sQ0FBQyxVQUFVbUgsSUFBSSxFQUFFelosS0FBSyxFQUFFO01BQ3ZDLElBQUl3UCxTQUFTLEtBQUtpSyxJQUFJLElBQUlGLFNBQVMsQ0FBQ3BlLE1BQU0sS0FBSzZFLEtBQUssR0FBRyxDQUFDLEVBQUU7UUFDeEQsT0FBTzFILElBQUk7TUFDakI7TUFFSWtYLFNBQVMsR0FBR2xYLElBQUksQ0FBQ2tYLFNBQVMsQ0FBQzdiLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7TUFDeEMybEIsaUJBQWlCLEdBQUd4SSxvQkFBb0IsQ0FBQ3RCLFNBQVMsQ0FBQztNQUVuRCxJQUFJNkIsYUFBYSxHQUFHL1ksSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTTtNQUN2QyxJQUFJNEssVUFBVSxHQUFHcGhCLElBQUksQ0FBQzJVLE9BQU8sQ0FBQ3ZFLFNBQVM7O01BRTNDO01BQ0ksSUFBSTJOLEtBQUssR0FBRzdqQixJQUFJLENBQUM2akIsS0FBSztNQUN0QixJQUFJc0QsV0FBVyxHQUFHbkssU0FBUyxLQUFLLE1BQU0sSUFBSTZHLEtBQUssQ0FBQ2hGLGFBQWEsQ0FBQ2pHLEtBQUssQ0FBQyxHQUFHaUwsS0FBSyxDQUFDcUQsVUFBVSxDQUFDdk8sSUFBSSxDQUFDLElBQUlxRSxTQUFTLEtBQUssT0FBTyxJQUFJNkcsS0FBSyxDQUFDaEYsYUFBYSxDQUFDbEcsSUFBSSxDQUFDLEdBQUdrTCxLQUFLLENBQUNxRCxVQUFVLENBQUN0TyxLQUFLLENBQUMsSUFBSW9FLFNBQVMsS0FBSyxLQUFLLElBQUk2RyxLQUFLLENBQUNoRixhQUFhLENBQUNuRyxNQUFNLENBQUMsR0FBR21MLEtBQUssQ0FBQ3FELFVBQVUsQ0FBQ3pPLEdBQUcsQ0FBQyxJQUFJdUUsU0FBUyxLQUFLLFFBQVEsSUFBSTZHLEtBQUssQ0FBQ2hGLGFBQWEsQ0FBQ3BHLEdBQUcsQ0FBQyxHQUFHb0wsS0FBSyxDQUFDcUQsVUFBVSxDQUFDeE8sTUFBTSxDQUFDO01BRTVVLElBQUkwTyxhQUFhLEdBQUd2RCxLQUFLLENBQUNoRixhQUFhLENBQUNsRyxJQUFJLENBQUMsR0FBR2tMLEtBQUssQ0FBQ3BILFVBQVUsQ0FBQzlELElBQUksQ0FBQztNQUN0RSxJQUFJME8sY0FBYyxHQUFHeEQsS0FBSyxDQUFDaEYsYUFBYSxDQUFDakcsS0FBSyxDQUFDLEdBQUdpTCxLQUFLLENBQUNwSCxVQUFVLENBQUM3RCxLQUFLLENBQUM7TUFDekUsSUFBSTBPLFlBQVksR0FBR3pELEtBQUssQ0FBQ2hGLGFBQWEsQ0FBQ3BHLEdBQUcsQ0FBQyxHQUFHb0wsS0FBSyxDQUFDcEgsVUFBVSxDQUFDaEUsR0FBRyxDQUFDO01BQ25FLElBQUk4TyxlQUFlLEdBQUcxRCxLQUFLLENBQUNoRixhQUFhLENBQUNuRyxNQUFNLENBQUMsR0FBR21MLEtBQUssQ0FBQ3BILFVBQVUsQ0FBQy9ELE1BQU0sQ0FBQztNQUU1RSxJQUFJOE8sbUJBQW1CLEdBQUd4SyxTQUFTLEtBQUssTUFBTSxJQUFJb0ssYUFBYSxJQUFJcEssU0FBUyxLQUFLLE9BQU8sSUFBSXFLLGNBQWMsSUFBSXJLLFNBQVMsS0FBSyxLQUFLLElBQUlzSyxZQUFZLElBQUl0SyxTQUFTLEtBQUssUUFBUSxJQUFJdUssZUFBZTs7TUFFbE07TUFDSSxJQUFJckQsVUFBVSxHQUFHLENBQUMsS0FBSyxFQUFFLFFBQVEsQ0FBQyxDQUFDcFYsT0FBTyxDQUFDa08sU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDOztNQUVoRTtNQUNJLElBQUl5SyxxQkFBcUIsR0FBRyxDQUFDLENBQUNsSCxPQUFPLENBQUNtSCxjQUFjLEtBQUt4RCxVQUFVLElBQUlyRyxTQUFTLEtBQUssT0FBTyxJQUFJdUosYUFBYSxJQUFJbEQsVUFBVSxJQUFJckcsU0FBUyxLQUFLLEtBQUssSUFBSXdKLGNBQWMsSUFBSSxDQUFDbkQsVUFBVSxJQUFJckcsU0FBUyxLQUFLLE9BQU8sSUFBSXlKLFlBQVksSUFBSSxDQUFDcEQsVUFBVSxJQUFJckcsU0FBUyxLQUFLLEtBQUssSUFBSTBKLGVBQWUsQ0FBQzs7TUFFMVI7TUFDSSxJQUFJSSx5QkFBeUIsR0FBRyxDQUFDLENBQUNwSCxPQUFPLENBQUNxSCx1QkFBdUIsS0FBSzFELFVBQVUsSUFBSXJHLFNBQVMsS0FBSyxPQUFPLElBQUl3SixjQUFjLElBQUluRCxVQUFVLElBQUlyRyxTQUFTLEtBQUssS0FBSyxJQUFJdUosYUFBYSxJQUFJLENBQUNsRCxVQUFVLElBQUlyRyxTQUFTLEtBQUssT0FBTyxJQUFJMEosZUFBZSxJQUFJLENBQUNyRCxVQUFVLElBQUlyRyxTQUFTLEtBQUssS0FBSyxJQUFJeUosWUFBWSxDQUFDO01BRW5TLElBQUlPLGdCQUFnQixHQUFHSixxQkFBcUIsSUFBSUUseUJBQXlCO01BRXpFLElBQUlSLFdBQVcsSUFBSUssbUJBQW1CLElBQUlLLGdCQUFnQixFQUFFO1FBQ2hFO1FBQ00vaEIsSUFBSSxDQUFDd2EsT0FBTyxHQUFHLElBQUk7UUFFbkIsSUFBSTZHLFdBQVcsSUFBSUssbUJBQW1CLEVBQUU7VUFDdEN4SyxTQUFTLEdBQUcrSixTQUFTLENBQUN2WixLQUFLLEdBQUcsQ0FBQyxDQUFDO1FBQ3hDO1FBRU0sSUFBSXFhLGdCQUFnQixFQUFFO1VBQ3BCaEssU0FBUyxHQUFHc0ksb0JBQW9CLENBQUN0SSxTQUFTLENBQUM7UUFDbkQ7UUFFTS9YLElBQUksQ0FBQ2tYLFNBQVMsR0FBR0EsU0FBUyxJQUFJYSxTQUFTLEdBQUcsR0FBRyxHQUFHQSxTQUFTLEdBQUcsRUFBRSxDQUFDOztRQUVyRTtRQUNBO1FBQ00vWCxJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLEdBQUdqQyxRQUFRLENBQUMsRUFBRSxFQUFFdlUsSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTSxFQUFFb0MsZ0JBQWdCLENBQUM1WSxJQUFJLENBQUMyVCxRQUFRLENBQUM2QyxNQUFNLEVBQUV4VyxJQUFJLENBQUMyVSxPQUFPLENBQUN2RSxTQUFTLEVBQUVwUSxJQUFJLENBQUNrWCxTQUFTLENBQUMsQ0FBQztRQUV2SWxYLElBQUksR0FBRzRaLFlBQVksQ0FBQzVaLElBQUksQ0FBQzJULFFBQVEsQ0FBQ2tHLFNBQVMsRUFBRTdaLElBQUksRUFBRSxNQUFNLENBQUM7TUFDaEU7SUFDQSxDQUFHLENBQUM7SUFDRixPQUFPQSxJQUFJO0VBQ2I7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTZ2lCLFlBQVksQ0FBQ2hpQixJQUFJLEVBQUU7SUFDMUIsSUFBSTZkLGFBQWEsR0FBRzdkLElBQUksQ0FBQzJVLE9BQU87TUFDNUI2QixNQUFNLEdBQUdxSCxhQUFhLENBQUNySCxNQUFNO01BQzdCcEcsU0FBUyxHQUFHeU4sYUFBYSxDQUFDek4sU0FBUztJQUV2QyxJQUFJOEcsU0FBUyxHQUFHbFgsSUFBSSxDQUFDa1gsU0FBUyxDQUFDN2IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUM1QyxJQUFJMGlCLEtBQUssR0FBRzdqQixJQUFJLENBQUM2akIsS0FBSztJQUN0QixJQUFJSyxVQUFVLEdBQUcsQ0FBQyxLQUFLLEVBQUUsUUFBUSxDQUFDLENBQUNwVixPQUFPLENBQUNrTyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDNUQsSUFBSWpGLElBQUksR0FBR21NLFVBQVUsR0FBRyxPQUFPLEdBQUcsUUFBUTtJQUMxQyxJQUFJMEIsTUFBTSxHQUFHMUIsVUFBVSxHQUFHLE1BQU0sR0FBRyxLQUFLO0lBQ3hDLElBQUlqRixXQUFXLEdBQUdpRixVQUFVLEdBQUcsT0FBTyxHQUFHLFFBQVE7SUFFakQsSUFBSTVILE1BQU0sQ0FBQ3ZFLElBQUksQ0FBQyxHQUFHOEwsS0FBSyxDQUFDM04sU0FBUyxDQUFDMFAsTUFBTSxDQUFDLENBQUMsRUFBRTtNQUMzQzlmLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU0sQ0FBQ3NKLE1BQU0sQ0FBQyxHQUFHL0IsS0FBSyxDQUFDM04sU0FBUyxDQUFDMFAsTUFBTSxDQUFDLENBQUMsR0FBR3RKLE1BQU0sQ0FBQzJDLFdBQVcsQ0FBQztJQUNoRjtJQUNFLElBQUkzQyxNQUFNLENBQUNzSixNQUFNLENBQUMsR0FBRy9CLEtBQUssQ0FBQzNOLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxDQUFDLEVBQUU7TUFDM0NqUyxJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLENBQUNzSixNQUFNLENBQUMsR0FBRy9CLEtBQUssQ0FBQzNOLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxDQUFDO0lBQ3hEO0lBRUUsT0FBT2pTLElBQUk7RUFDYjs7RUFFQTs7Ozs7Ozs7Ozs7O0VBWUEsU0FBU2lpQixPQUFPLENBQUNDLEdBQUcsRUFBRS9JLFdBQVcsRUFBRUosYUFBYSxFQUFFRixnQkFBZ0IsRUFBRTtJQUNwRTtJQUNFLElBQUl4ZCxLQUFLLEdBQUc2bUIsR0FBRyxDQUFDN3BCLEtBQUssQ0FBQywyQkFBMkIsQ0FBQztJQUNsRCxJQUFJaUUsS0FBSyxHQUFHLENBQUNqQixLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ3JCLElBQUlnaUIsSUFBSSxHQUFHaGlCLEtBQUssQ0FBQyxDQUFDLENBQUM7O0lBRXJCO0lBQ0UsSUFBSSxDQUFDaUIsS0FBSyxFQUFFO01BQ1YsT0FBTzRsQixHQUFHO0lBQ2Q7SUFFRSxJQUFJN0UsSUFBSSxDQUFDclUsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRTtNQUMzQixJQUFJek8sT0FBTyxHQUFHLEtBQUssQ0FBQztNQUNwQixRQUFROGlCLElBQUk7UUFDVixLQUFLLElBQUk7VUFDUDlpQixPQUFPLEdBQUd3ZSxhQUFhO1VBQ3ZCO1FBQ0YsS0FBSyxHQUFHO1FBQ1IsS0FBSyxJQUFJO1FBQ1Q7VUFDRXhlLE9BQU8sR0FBR3NlLGdCQUFnQjtNQUFDO01BRy9CLElBQUl2RyxJQUFJLEdBQUdvQyxhQUFhLENBQUNuYSxPQUFPLENBQUM7TUFDakMsT0FBTytYLElBQUksQ0FBQzZHLFdBQVcsQ0FBQyxHQUFHLEdBQUcsR0FBRzdjLEtBQUs7SUFDMUMsQ0FBRyxNQUFNLElBQUkrZ0IsSUFBSSxLQUFLLElBQUksSUFBSUEsSUFBSSxLQUFLLElBQUksRUFBRTtNQUM3QztNQUNJLElBQUk4RSxJQUFJLEdBQUcsS0FBSyxDQUFDO01BQ2pCLElBQUk5RSxJQUFJLEtBQUssSUFBSSxFQUFFO1FBQ2pCOEUsSUFBSSxHQUFHam9CLElBQUksQ0FBQ29aLEdBQUcsQ0FBQ2xaLFFBQVEsQ0FBQ3lDLGVBQWUsQ0FBQ2tZLFlBQVksRUFBRXhTLE1BQU0sQ0FBQzBULFdBQVcsSUFBSSxDQUFDLENBQUM7TUFDckYsQ0FBSyxNQUFNO1FBQ0xrTSxJQUFJLEdBQUdqb0IsSUFBSSxDQUFDb1osR0FBRyxDQUFDbFosUUFBUSxDQUFDeUMsZUFBZSxDQUFDaVksV0FBVyxFQUFFdlMsTUFBTSxDQUFDeVQsVUFBVSxJQUFJLENBQUMsQ0FBQztNQUNuRjtNQUNJLE9BQU9tTSxJQUFJLEdBQUcsR0FBRyxHQUFHN2xCLEtBQUs7SUFDN0IsQ0FBRyxNQUFNO01BQ1Q7TUFDQTtNQUNJLE9BQU9BLEtBQUs7SUFDaEI7RUFDQTs7RUFFQTs7Ozs7Ozs7Ozs7RUFXQSxTQUFTOGxCLFdBQVcsQ0FBQ2xNLE1BQU0sRUFBRTZDLGFBQWEsRUFBRUYsZ0JBQWdCLEVBQUV3SixhQUFhLEVBQUU7SUFDM0UsSUFBSTFOLE9BQU8sR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUM7O0lBRXRCO0lBQ0E7SUFDQTtJQUNFLElBQUkyTixTQUFTLEdBQUcsQ0FBQyxPQUFPLEVBQUUsTUFBTSxDQUFDLENBQUN0WixPQUFPLENBQUNxWixhQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7O0lBRWpFO0lBQ0E7SUFDRSxJQUFJRSxTQUFTLEdBQUdyTSxNQUFNLENBQUM3YSxLQUFLLENBQUMsU0FBUyxDQUFDLENBQUNrYyxHQUFHLENBQUMsVUFBVWlMLElBQUksRUFBRTtNQUMxRCxPQUFPQSxJQUFJLENBQUM3bkIsSUFBSSxFQUFFO0lBQ3RCLENBQUcsQ0FBQzs7SUFFSjtJQUNBO0lBQ0UsSUFBSThuQixPQUFPLEdBQUdGLFNBQVMsQ0FBQ3ZaLE9BQU8sQ0FBQ3FRLElBQUksQ0FBQ2tKLFNBQVMsRUFBRSxVQUFVQyxJQUFJLEVBQUU7TUFDOUQsT0FBT0EsSUFBSSxDQUFDRSxNQUFNLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ3JDLENBQUcsQ0FBQyxDQUFDO0lBRUgsSUFBSUgsU0FBUyxDQUFDRSxPQUFPLENBQUMsSUFBSUYsU0FBUyxDQUFDRSxPQUFPLENBQUMsQ0FBQ3paLE9BQU8sQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtNQUNoRWlSLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLDhFQUE4RSxDQUFDO0lBQ2hHOztJQUVBO0lBQ0E7SUFDRSxJQUFJeUksVUFBVSxHQUFHLGFBQWE7SUFDOUIsSUFBSUMsR0FBRyxHQUFHSCxPQUFPLEtBQUssQ0FBQyxDQUFDLEdBQUcsQ0FBQ0YsU0FBUyxDQUFDOWYsS0FBSyxDQUFDLENBQUMsRUFBRWdnQixPQUFPLENBQUMsQ0FBQy9CLE1BQU0sQ0FBQyxDQUFDNkIsU0FBUyxDQUFDRSxPQUFPLENBQUMsQ0FBQ3BuQixLQUFLLENBQUNzbkIsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUNKLFNBQVMsQ0FBQ0UsT0FBTyxDQUFDLENBQUNwbkIsS0FBSyxDQUFDc25CLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUNqQyxNQUFNLENBQUM2QixTQUFTLENBQUM5ZixLQUFLLENBQUNnZ0IsT0FBTyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDRixTQUFTLENBQUM7O0lBRTFNO0lBQ0VLLEdBQUcsR0FBR0EsR0FBRyxDQUFDckwsR0FBRyxDQUFDLFVBQVVzTCxFQUFFLEVBQUVuYixLQUFLLEVBQUU7TUFDckM7TUFDSSxJQUFJeVIsV0FBVyxHQUFHLENBQUN6UixLQUFLLEtBQUssQ0FBQyxHQUFHLENBQUM0YSxTQUFTLEdBQUdBLFNBQVMsSUFBSSxRQUFRLEdBQUcsT0FBTztNQUM3RSxJQUFJUSxpQkFBaUIsR0FBRyxLQUFLO01BQzdCLE9BQU9EO01BQ1g7TUFDQTtNQUFBLENBQ0tFLE1BQU0sQ0FBQyxVQUFVckwsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDdEIsSUFBSUQsQ0FBQyxDQUFDQSxDQUFDLENBQUM3VSxNQUFNLEdBQUcsQ0FBQyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxDQUFDbUcsT0FBTyxDQUFDMk8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7VUFDMURELENBQUMsQ0FBQ0EsQ0FBQyxDQUFDN1UsTUFBTSxHQUFHLENBQUMsQ0FBQyxHQUFHOFUsQ0FBQztVQUNuQm1MLGlCQUFpQixHQUFHLElBQUk7VUFDeEIsT0FBT3BMLENBQUM7UUFDaEIsQ0FBTyxNQUFNLElBQUlvTCxpQkFBaUIsRUFBRTtVQUM1QnBMLENBQUMsQ0FBQ0EsQ0FBQyxDQUFDN1UsTUFBTSxHQUFHLENBQUMsQ0FBQyxJQUFJOFUsQ0FBQztVQUNwQm1MLGlCQUFpQixHQUFHLEtBQUs7VUFDekIsT0FBT3BMLENBQUM7UUFDaEIsQ0FBTyxNQUFNO1VBQ0wsT0FBT0EsQ0FBQyxDQUFDZ0osTUFBTSxDQUFDL0ksQ0FBQyxDQUFDO1FBQzFCO01BQ0EsQ0FBSyxFQUFFLEVBQUU7TUFDVDtNQUFBLENBQ0tKLEdBQUcsQ0FBQyxVQUFVMkssR0FBRyxFQUFFO1FBQ2xCLE9BQU9ELE9BQU8sQ0FBQ0MsR0FBRyxFQUFFL0ksV0FBVyxFQUFFSixhQUFhLEVBQUVGLGdCQUFnQixDQUFDO01BQ3ZFLENBQUssQ0FBQztJQUNOLENBQUcsQ0FBQzs7SUFFSjtJQUNFK0osR0FBRyxDQUFDNUksT0FBTyxDQUFDLFVBQVU2SSxFQUFFLEVBQUVuYixLQUFLLEVBQUU7TUFDL0JtYixFQUFFLENBQUM3SSxPQUFPLENBQUMsVUFBVXdJLElBQUksRUFBRVEsTUFBTSxFQUFFO1FBQ2pDLElBQUloRyxTQUFTLENBQUN3RixJQUFJLENBQUMsRUFBRTtVQUNuQjdOLE9BQU8sQ0FBQ2pOLEtBQUssQ0FBQyxJQUFJOGEsSUFBSSxJQUFJSyxFQUFFLENBQUNHLE1BQU0sR0FBRyxDQUFDLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ2xFO01BQ0EsQ0FBSyxDQUFDO0lBQ04sQ0FBRyxDQUFDO0lBQ0YsT0FBT3JPLE9BQU87RUFDaEI7O0VBRUE7Ozs7Ozs7OztFQVNBLFNBQVN1QixNQUFNLENBQUNsVyxJQUFJLEVBQUVnWCxJQUFJLEVBQUU7SUFDMUIsSUFBSWQsTUFBTSxHQUFHYyxJQUFJLENBQUNkLE1BQU07SUFDeEIsSUFBSWdCLFNBQVMsR0FBR2xYLElBQUksQ0FBQ2tYLFNBQVM7TUFDMUIyRyxhQUFhLEdBQUc3ZCxJQUFJLENBQUMyVSxPQUFPO01BQzVCNkIsTUFBTSxHQUFHcUgsYUFBYSxDQUFDckgsTUFBTTtNQUM3QnBHLFNBQVMsR0FBR3lOLGFBQWEsQ0FBQ3pOLFNBQVM7SUFFdkMsSUFBSWlTLGFBQWEsR0FBR25MLFNBQVMsQ0FBQzdiLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFM0MsSUFBSXNaLE9BQU8sR0FBRyxLQUFLLENBQUM7SUFDcEIsSUFBSXFJLFNBQVMsQ0FBQyxDQUFDOUcsTUFBTSxDQUFDLEVBQUU7TUFDdEJ2QixPQUFPLEdBQUcsQ0FBQyxDQUFDdUIsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUMxQixDQUFHLE1BQU07TUFDTHZCLE9BQU8sR0FBR3lOLFdBQVcsQ0FBQ2xNLE1BQU0sRUFBRU0sTUFBTSxFQUFFcEcsU0FBUyxFQUFFaVMsYUFBYSxDQUFDO0lBQ25FO0lBRUUsSUFBSUEsYUFBYSxLQUFLLE1BQU0sRUFBRTtNQUM1QjdMLE1BQU0sQ0FBQzdELEdBQUcsSUFBSWdDLE9BQU8sQ0FBQyxDQUFDLENBQUM7TUFDeEI2QixNQUFNLENBQUMzRCxJQUFJLElBQUk4QixPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUcsTUFBTSxJQUFJME4sYUFBYSxLQUFLLE9BQU8sRUFBRTtNQUNwQzdMLE1BQU0sQ0FBQzdELEdBQUcsSUFBSWdDLE9BQU8sQ0FBQyxDQUFDLENBQUM7TUFDeEI2QixNQUFNLENBQUMzRCxJQUFJLElBQUk4QixPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzdCLENBQUcsTUFBTSxJQUFJME4sYUFBYSxLQUFLLEtBQUssRUFBRTtNQUNsQzdMLE1BQU0sQ0FBQzNELElBQUksSUFBSThCLE9BQU8sQ0FBQyxDQUFDLENBQUM7TUFDekI2QixNQUFNLENBQUM3RCxHQUFHLElBQUlnQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzVCLENBQUcsTUFBTSxJQUFJME4sYUFBYSxLQUFLLFFBQVEsRUFBRTtNQUNyQzdMLE1BQU0sQ0FBQzNELElBQUksSUFBSThCLE9BQU8sQ0FBQyxDQUFDLENBQUM7TUFDekI2QixNQUFNLENBQUM3RCxHQUFHLElBQUlnQyxPQUFPLENBQUMsQ0FBQyxDQUFDO0lBQzVCO0lBRUUzVSxJQUFJLENBQUN3VyxNQUFNLEdBQUdBLE1BQU07SUFDcEIsT0FBT3hXLElBQUk7RUFDYjs7RUFFQTs7Ozs7OztFQU9BLFNBQVNpakIsZUFBZSxDQUFDampCLElBQUksRUFBRXlhLE9BQU8sRUFBRTtJQUN0QyxJQUFJL0QsaUJBQWlCLEdBQUcrRCxPQUFPLENBQUMvRCxpQkFBaUIsSUFBSS9GLGVBQWUsQ0FBQzNRLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sQ0FBQzs7SUFFNUY7SUFDQTtJQUNBO0lBQ0UsSUFBSXhXLElBQUksQ0FBQzJULFFBQVEsQ0FBQ3ZELFNBQVMsS0FBS3NHLGlCQUFpQixFQUFFO01BQ2pEQSxpQkFBaUIsR0FBRy9GLGVBQWUsQ0FBQytGLGlCQUFpQixDQUFDO0lBQzFEOztJQUVBO0lBQ0E7SUFDQTtJQUNFLElBQUl3TSxhQUFhLEdBQUc3SCx3QkFBd0IsQ0FBQyxXQUFXLENBQUM7SUFDekQsSUFBSThILFlBQVksR0FBR25qQixJQUFJLENBQUMyVCxRQUFRLENBQUM2QyxNQUFNLENBQUNuSixLQUFLLENBQUM7SUFDOUMsSUFBSXNGLEdBQUcsR0FBR3dRLFlBQVksQ0FBQ3hRLEdBQUc7TUFDdEJFLElBQUksR0FBR3NRLFlBQVksQ0FBQ3RRLElBQUk7TUFDeEJ1USxTQUFTLEdBQUdELFlBQVksQ0FBQ0QsYUFBYSxDQUFDO0lBRTNDQyxZQUFZLENBQUN4USxHQUFHLEdBQUcsRUFBRTtJQUNyQndRLFlBQVksQ0FBQ3RRLElBQUksR0FBRyxFQUFFO0lBQ3RCc1EsWUFBWSxDQUFDRCxhQUFhLENBQUMsR0FBRyxFQUFFO0lBRWhDLElBQUl2TSxVQUFVLEdBQUdKLGFBQWEsQ0FBQ3ZXLElBQUksQ0FBQzJULFFBQVEsQ0FBQzZDLE1BQU0sRUFBRXhXLElBQUksQ0FBQzJULFFBQVEsQ0FBQ3ZELFNBQVMsRUFBRXFLLE9BQU8sQ0FBQ2hFLE9BQU8sRUFBRUMsaUJBQWlCLEVBQUUxVyxJQUFJLENBQUMwYSxhQUFhLENBQUM7O0lBRXZJO0lBQ0E7SUFDRXlJLFlBQVksQ0FBQ3hRLEdBQUcsR0FBR0EsR0FBRztJQUN0QndRLFlBQVksQ0FBQ3RRLElBQUksR0FBR0EsSUFBSTtJQUN4QnNRLFlBQVksQ0FBQ0QsYUFBYSxDQUFDLEdBQUdFLFNBQVM7SUFFdkMzSSxPQUFPLENBQUM5RCxVQUFVLEdBQUdBLFVBQVU7SUFFL0IsSUFBSXJGLEtBQUssR0FBR21KLE9BQU8sQ0FBQzRJLFFBQVE7SUFDNUIsSUFBSTdNLE1BQU0sR0FBR3hXLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU07SUFFaEMsSUFBSStDLEtBQUssR0FBRztNQUNWK0osT0FBTyxFQUFFLFNBQVNBLE9BQU8sQ0FBQ3BNLFNBQVMsRUFBRTtRQUNuQyxJQUFJNWEsS0FBSyxHQUFHa2EsTUFBTSxDQUFDVSxTQUFTLENBQUM7UUFDN0IsSUFBSVYsTUFBTSxDQUFDVSxTQUFTLENBQUMsR0FBR1AsVUFBVSxDQUFDTyxTQUFTLENBQUMsSUFBSSxDQUFDdUQsT0FBTyxDQUFDOEksbUJBQW1CLEVBQUU7VUFDN0VqbkIsS0FBSyxHQUFHcEMsSUFBSSxDQUFDb1osR0FBRyxDQUFDa0QsTUFBTSxDQUFDVSxTQUFTLENBQUMsRUFBRVAsVUFBVSxDQUFDTyxTQUFTLENBQUMsQ0FBQztRQUNsRTtRQUNNLE9BQU8vQyxjQUFjLENBQUMsRUFBRSxFQUFFK0MsU0FBUyxFQUFFNWEsS0FBSyxDQUFDO01BQ2pELENBQUs7TUFDRGtuQixTQUFTLEVBQUUsU0FBU0EsU0FBUyxDQUFDdE0sU0FBUyxFQUFFO1FBQ3ZDLElBQUkrQixRQUFRLEdBQUcvQixTQUFTLEtBQUssT0FBTyxHQUFHLE1BQU0sR0FBRyxLQUFLO1FBQ3JELElBQUk1YSxLQUFLLEdBQUdrYSxNQUFNLENBQUN5QyxRQUFRLENBQUM7UUFDNUIsSUFBSXpDLE1BQU0sQ0FBQ1UsU0FBUyxDQUFDLEdBQUdQLFVBQVUsQ0FBQ08sU0FBUyxDQUFDLElBQUksQ0FBQ3VELE9BQU8sQ0FBQzhJLG1CQUFtQixFQUFFO1VBQzdFam5CLEtBQUssR0FBR3BDLElBQUksQ0FBQ2ttQixHQUFHLENBQUM1SixNQUFNLENBQUN5QyxRQUFRLENBQUMsRUFBRXRDLFVBQVUsQ0FBQ08sU0FBUyxDQUFDLElBQUlBLFNBQVMsS0FBSyxPQUFPLEdBQUdWLE1BQU0sQ0FBQy9DLEtBQUssR0FBRytDLE1BQU0sQ0FBQ2hELE1BQU0sQ0FBQyxDQUFDO1FBQzFIO1FBQ00sT0FBT1csY0FBYyxDQUFDLEVBQUUsRUFBRThFLFFBQVEsRUFBRTNjLEtBQUssQ0FBQztNQUNoRDtJQUNBLENBQUc7SUFFRGdWLEtBQUssQ0FBQzBJLE9BQU8sQ0FBQyxVQUFVOUMsU0FBUyxFQUFFO01BQ2pDLElBQUlqRixJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUUsS0FBSyxDQUFDLENBQUNqSixPQUFPLENBQUNrTyxTQUFTLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxTQUFTLEdBQUcsV0FBVztNQUM5RVYsTUFBTSxHQUFHakMsUUFBUSxDQUFDLEVBQUUsRUFBRWlDLE1BQU0sRUFBRStDLEtBQUssQ0FBQ3RILElBQUksQ0FBQyxDQUFDaUYsU0FBUyxDQUFDLENBQUM7SUFDekQsQ0FBRyxDQUFDO0lBRUZsWCxJQUFJLENBQUMyVSxPQUFPLENBQUM2QixNQUFNLEdBQUdBLE1BQU07SUFFNUIsT0FBT3hXLElBQUk7RUFDYjs7RUFFQTs7Ozs7OztFQU9BLFNBQVN5akIsS0FBSyxDQUFDempCLElBQUksRUFBRTtJQUNuQixJQUFJa1gsU0FBUyxHQUFHbFgsSUFBSSxDQUFDa1gsU0FBUztJQUM5QixJQUFJbUwsYUFBYSxHQUFHbkwsU0FBUyxDQUFDN2IsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQztJQUMzQyxJQUFJcW9CLGNBQWMsR0FBR3hNLFNBQVMsQ0FBQzdiLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7O0lBRTlDO0lBQ0UsSUFBSXFvQixjQUFjLEVBQUU7TUFDbEIsSUFBSTdGLGFBQWEsR0FBRzdkLElBQUksQ0FBQzJVLE9BQU87UUFDNUJ2RSxTQUFTLEdBQUd5TixhQUFhLENBQUN6TixTQUFTO1FBQ25Db0csTUFBTSxHQUFHcUgsYUFBYSxDQUFDckgsTUFBTTtNQUVqQyxJQUFJNEgsVUFBVSxHQUFHLENBQUMsUUFBUSxFQUFFLEtBQUssQ0FBQyxDQUFDcFYsT0FBTyxDQUFDcVosYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO01BQ2hFLElBQUlwUSxJQUFJLEdBQUdtTSxVQUFVLEdBQUcsTUFBTSxHQUFHLEtBQUs7TUFDdEMsSUFBSWpGLFdBQVcsR0FBR2lGLFVBQVUsR0FBRyxPQUFPLEdBQUcsUUFBUTtNQUVqRCxJQUFJdUYsWUFBWSxHQUFHO1FBQ2pCdGIsS0FBSyxFQUFFOEwsY0FBYyxDQUFDLEVBQUUsRUFBRWxDLElBQUksRUFBRTdCLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxDQUFDO1FBQ2hEckosR0FBRyxFQUFFdUwsY0FBYyxDQUFDLEVBQUUsRUFBRWxDLElBQUksRUFBRTdCLFNBQVMsQ0FBQzZCLElBQUksQ0FBQyxHQUFHN0IsU0FBUyxDQUFDK0ksV0FBVyxDQUFDLEdBQUczQyxNQUFNLENBQUMyQyxXQUFXLENBQUM7TUFDbEcsQ0FBSztNQUVEblosSUFBSSxDQUFDMlUsT0FBTyxDQUFDNkIsTUFBTSxHQUFHakMsUUFBUSxDQUFDLEVBQUUsRUFBRWlDLE1BQU0sRUFBRW1OLFlBQVksQ0FBQ0QsY0FBYyxDQUFDLENBQUM7SUFDNUU7SUFFRSxPQUFPMWpCLElBQUk7RUFDYjs7RUFFQTs7Ozs7OztFQU9BLFNBQVM2TSxJQUFJLENBQUM3TSxJQUFJLEVBQUU7SUFDbEIsSUFBSSxDQUFDb2Ysa0JBQWtCLENBQUNwZixJQUFJLENBQUMyVCxRQUFRLENBQUNrRyxTQUFTLEVBQUUsTUFBTSxFQUFFLGlCQUFpQixDQUFDLEVBQUU7TUFDM0UsT0FBTzdaLElBQUk7SUFDZjtJQUVFLElBQUltWCxPQUFPLEdBQUduWCxJQUFJLENBQUMyVSxPQUFPLENBQUN2RSxTQUFTO0lBQ3BDLElBQUl3VCxLQUFLLEdBQUd2SyxJQUFJLENBQUNyWixJQUFJLENBQUMyVCxRQUFRLENBQUNrRyxTQUFTLEVBQUUsVUFBVW5ILFFBQVEsRUFBRTtNQUM1RCxPQUFPQSxRQUFRLENBQUMwSSxJQUFJLEtBQUssaUJBQWlCO0lBQzlDLENBQUcsQ0FBQyxDQUFDekUsVUFBVTtJQUViLElBQUlRLE9BQU8sQ0FBQ3ZFLE1BQU0sR0FBR2dSLEtBQUssQ0FBQ2pSLEdBQUcsSUFBSXdFLE9BQU8sQ0FBQ3RFLElBQUksR0FBRytRLEtBQUssQ0FBQzlRLEtBQUssSUFBSXFFLE9BQU8sQ0FBQ3hFLEdBQUcsR0FBR2lSLEtBQUssQ0FBQ2hSLE1BQU0sSUFBSXVFLE9BQU8sQ0FBQ3JFLEtBQUssR0FBRzhRLEtBQUssQ0FBQy9RLElBQUksRUFBRTtNQUM1SDtNQUNJLElBQUk3UyxJQUFJLENBQUM2TSxJQUFJLEtBQUssSUFBSSxFQUFFO1FBQ3RCLE9BQU83TSxJQUFJO01BQ2pCO01BRUlBLElBQUksQ0FBQzZNLElBQUksR0FBRyxJQUFJO01BQ2hCN00sSUFBSSxDQUFDdWEsVUFBVSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsRUFBRTtJQUMvQyxDQUFHLE1BQU07TUFDVDtNQUNJLElBQUl2YSxJQUFJLENBQUM2TSxJQUFJLEtBQUssS0FBSyxFQUFFO1FBQ3ZCLE9BQU83TSxJQUFJO01BQ2pCO01BRUlBLElBQUksQ0FBQzZNLElBQUksR0FBRyxLQUFLO01BQ2pCN00sSUFBSSxDQUFDdWEsVUFBVSxDQUFDLHFCQUFxQixDQUFDLEdBQUcsS0FBSztJQUNsRDtJQUVFLE9BQU92YSxJQUFJO0VBQ2I7O0VBRUE7Ozs7Ozs7RUFPQSxTQUFTNmpCLEtBQUssQ0FBQzdqQixJQUFJLEVBQUU7SUFDbkIsSUFBSWtYLFNBQVMsR0FBR2xYLElBQUksQ0FBQ2tYLFNBQVM7SUFDOUIsSUFBSW1MLGFBQWEsR0FBR25MLFNBQVMsQ0FBQzdiLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDM0MsSUFBSXdpQixhQUFhLEdBQUc3ZCxJQUFJLENBQUMyVSxPQUFPO01BQzVCNkIsTUFBTSxHQUFHcUgsYUFBYSxDQUFDckgsTUFBTTtNQUM3QnBHLFNBQVMsR0FBR3lOLGFBQWEsQ0FBQ3pOLFNBQVM7SUFFdkMsSUFBSTRJLE9BQU8sR0FBRyxDQUFDLE1BQU0sRUFBRSxPQUFPLENBQUMsQ0FBQ2hRLE9BQU8sQ0FBQ3FaLGFBQWEsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUU3RCxJQUFJeUIsY0FBYyxHQUFHLENBQUMsS0FBSyxFQUFFLE1BQU0sQ0FBQyxDQUFDOWEsT0FBTyxDQUFDcVosYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBRWxFN0wsTUFBTSxDQUFDd0MsT0FBTyxHQUFHLE1BQU0sR0FBRyxLQUFLLENBQUMsR0FBRzVJLFNBQVMsQ0FBQ2lTLGFBQWEsQ0FBQyxJQUFJeUIsY0FBYyxHQUFHdE4sTUFBTSxDQUFDd0MsT0FBTyxHQUFHLE9BQU8sR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFekhoWixJQUFJLENBQUNrWCxTQUFTLEdBQUdzQixvQkFBb0IsQ0FBQ3RCLFNBQVMsQ0FBQztJQUNoRGxYLElBQUksQ0FBQzJVLE9BQU8sQ0FBQzZCLE1BQU0sR0FBRzlCLGFBQWEsQ0FBQzhCLE1BQU0sQ0FBQztJQUUzQyxPQUFPeFcsSUFBSTtFQUNiOztFQUVBOzs7Ozs7Ozs7Ozs7RUFZQTs7Ozs7Ozs7O0VBU0EsSUFBSTZaLFNBQVMsR0FBRztJQUNoQjs7Ozs7Ozs7SUFRRTRKLEtBQUssRUFBRTtNQUNUO01BQ0luUyxLQUFLLEVBQUUsR0FBRztNQUNkO01BQ0k2SSxPQUFPLEVBQUUsSUFBSTtNQUNqQjtNQUNJdGdCLEVBQUUsRUFBRTRwQjtJQUNSLENBQUc7SUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFzQ0V2TixNQUFNLEVBQUU7TUFDVjtNQUNJNUUsS0FBSyxFQUFFLEdBQUc7TUFDZDtNQUNJNkksT0FBTyxFQUFFLElBQUk7TUFDakI7TUFDSXRnQixFQUFFLEVBQUVxYyxNQUFNO01BQ2Q7OztNQUdJQSxNQUFNLEVBQUU7SUFDWixDQUFHO0lBRUg7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBaUJFK00sZUFBZSxFQUFFO01BQ25CO01BQ0kzUixLQUFLLEVBQUUsR0FBRztNQUNkO01BQ0k2SSxPQUFPLEVBQUUsSUFBSTtNQUNqQjtNQUNJdGdCLEVBQUUsRUFBRW9wQixlQUFlO01BQ3ZCOzs7OztNQUtJSSxRQUFRLEVBQUUsQ0FBQyxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxRQUFRLENBQUM7TUFDaEQ7Ozs7OztNQU1JNU0sT0FBTyxFQUFFLENBQUM7TUFDZDs7Ozs7TUFLSUMsaUJBQWlCLEVBQUU7SUFDdkIsQ0FBRztJQUVIOzs7Ozs7Ozs7SUFTRXNMLFlBQVksRUFBRTtNQUNoQjtNQUNJMVEsS0FBSyxFQUFFLEdBQUc7TUFDZDtNQUNJNkksT0FBTyxFQUFFLElBQUk7TUFDakI7TUFDSXRnQixFQUFFLEVBQUVtb0I7SUFDUixDQUFHO0lBRUg7Ozs7Ozs7Ozs7SUFVRTdDLEtBQUssRUFBRTtNQUNUO01BQ0k3TixLQUFLLEVBQUUsR0FBRztNQUNkO01BQ0k2SSxPQUFPLEVBQUUsSUFBSTtNQUNqQjtNQUNJdGdCLEVBQUUsRUFBRXNsQixLQUFLO01BQ2I7TUFDSTVrQixPQUFPLEVBQUU7SUFDYixDQUFHO0lBRUg7Ozs7Ozs7Ozs7O0lBV0VvZ0IsSUFBSSxFQUFFO01BQ1I7TUFDSXJKLEtBQUssRUFBRSxHQUFHO01BQ2Q7TUFDSTZJLE9BQU8sRUFBRSxJQUFJO01BQ2pCO01BQ0l0Z0IsRUFBRSxFQUFFOGdCLElBQUk7TUFDWjs7Ozs7O01BTUl1RyxRQUFRLEVBQUUsTUFBTTtNQUNwQjs7OztNQUlJekssT0FBTyxFQUFFLENBQUM7TUFDZDs7Ozs7O01BTUlDLGlCQUFpQixFQUFFLFVBQVU7TUFDakM7Ozs7Ozs7TUFPSWtMLGNBQWMsRUFBRSxLQUFLO01BQ3pCOzs7Ozs7O01BT0lFLHVCQUF1QixFQUFFO0lBQzdCLENBQUc7SUFFSDs7Ozs7OztJQU9FK0IsS0FBSyxFQUFFO01BQ1Q7TUFDSXZTLEtBQUssRUFBRSxHQUFHO01BQ2Q7TUFDSTZJLE9BQU8sRUFBRSxLQUFLO01BQ2xCO01BQ0l0Z0IsRUFBRSxFQUFFZ3FCO0lBQ1IsQ0FBRztJQUVIOzs7Ozs7Ozs7O0lBVUVoWCxJQUFJLEVBQUU7TUFDUjtNQUNJeUUsS0FBSyxFQUFFLEdBQUc7TUFDZDtNQUNJNkksT0FBTyxFQUFFLElBQUk7TUFDakI7TUFDSXRnQixFQUFFLEVBQUVnVDtJQUNSLENBQUc7SUFFSDs7Ozs7Ozs7Ozs7Ozs7O0lBZUU4UixZQUFZLEVBQUU7TUFDaEI7TUFDSXJOLEtBQUssRUFBRSxHQUFHO01BQ2Q7TUFDSTZJLE9BQU8sRUFBRSxJQUFJO01BQ2pCO01BQ0l0Z0IsRUFBRSxFQUFFOGtCLFlBQVk7TUFDcEI7Ozs7O01BS0lFLGVBQWUsRUFBRSxJQUFJO01BQ3pCOzs7OztNQUtJekcsQ0FBQyxFQUFFLFFBQVE7TUFDZjs7Ozs7TUFLSUUsQ0FBQyxFQUFFO0lBQ1AsQ0FBRztJQUVIOzs7Ozs7Ozs7Ozs7Ozs7SUFlRWlGLFVBQVUsRUFBRTtNQUNkO01BQ0lqTSxLQUFLLEVBQUUsR0FBRztNQUNkO01BQ0k2SSxPQUFPLEVBQUUsSUFBSTtNQUNqQjtNQUNJdGdCLEVBQUUsRUFBRTBqQixVQUFVO01BQ2xCO01BQ0l3RyxNQUFNLEVBQUV0RyxnQkFBZ0I7TUFDNUI7Ozs7OztNQU1Jb0IsZUFBZSxFQUFFMWxCO0lBQ3JCO0VBQ0EsQ0FBQzs7RUFFRDs7Ozs7Ozs7Ozs7Ozs7Ozs7OztFQW1CQTs7Ozs7Ozs7Ozs7Ozs7OztFQWdCQSxJQUFJNnFCLFFBQVEsR0FBRztJQUNmOzs7O0lBSUU5TSxTQUFTLEVBQUUsUUFBUTtJQUVyQjs7OztJQUlFd0QsYUFBYSxFQUFFLEtBQUs7SUFFdEI7Ozs7SUFJRWdDLGFBQWEsRUFBRSxJQUFJO0lBRXJCOzs7OztJQUtFWixlQUFlLEVBQUUsS0FBSztJQUV4Qjs7Ozs7O0lBTUVmLFFBQVEsRUFBRSxTQUFTQSxRQUFRLEdBQUcsRUFBRTtJQUVsQzs7Ozs7Ozs7SUFRRUMsUUFBUSxFQUFFLFNBQVNBLFFBQVEsR0FBRyxFQUFFO0lBRWxDOzs7OztJQUtFbkIsU0FBUyxFQUFFQTtFQUNiLENBQUM7O0VBRUQ7Ozs7O0VBS0E7Ozs7O0VBS0E7RUFDQTtFQUNBLElBQUlvSyxNQUFNLEdBQUcsWUFBWTtJQUN6Qjs7Ozs7Ozs7SUFRRSxTQUFTQSxNQUFNLENBQUM3VCxTQUFTLEVBQUVvRyxNQUFNLEVBQUU7TUFDakMsSUFBSTdjLEtBQUssR0FBRyxJQUFJO01BRWhCLElBQUk4Z0IsT0FBTyxHQUFHdmhCLFNBQVMsQ0FBQzJKLE1BQU0sR0FBRyxDQUFDLElBQUkzSixTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUtDLFNBQVMsR0FBR0QsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHLEVBQUU7TUFDcEZ3YSxjQUFjLENBQUMsSUFBSSxFQUFFdVEsTUFBTSxDQUFDO01BRTVCLElBQUksQ0FBQ3JILGNBQWMsR0FBRyxZQUFZO1FBQ2hDLE9BQU9zSCxxQkFBcUIsQ0FBQ3ZxQixLQUFLLENBQUN5Z0IsTUFBTSxDQUFDO01BQ2hELENBQUs7O01BRUw7TUFDSSxJQUFJLENBQUNBLE1BQU0sR0FBR2xMLFFBQVEsQ0FBQyxJQUFJLENBQUNrTCxNQUFNLENBQUM1UyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O01BRWxEO01BQ0ksSUFBSSxDQUFDaVQsT0FBTyxHQUFHbEcsUUFBUSxDQUFDLEVBQUUsRUFBRTBQLE1BQU0sQ0FBQ0QsUUFBUSxFQUFFdkosT0FBTyxDQUFDOztNQUV6RDtNQUNJLElBQUksQ0FBQ3hDLEtBQUssR0FBRztRQUNYb0MsV0FBVyxFQUFFLEtBQUs7UUFDbEJTLFNBQVMsRUFBRSxLQUFLO1FBQ2hCcUIsYUFBYSxFQUFFO01BQ3JCLENBQUs7O01BRUw7TUFDSSxJQUFJLENBQUMvTCxTQUFTLEdBQUdBLFNBQVMsSUFBSUEsU0FBUyxDQUFDOVMsTUFBTSxHQUFHOFMsU0FBUyxDQUFDLENBQUMsQ0FBQyxHQUFHQSxTQUFTO01BQ3pFLElBQUksQ0FBQ29HLE1BQU0sR0FBR0EsTUFBTSxJQUFJQSxNQUFNLENBQUNsWixNQUFNLEdBQUdrWixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUdBLE1BQU07O01BRTlEO01BQ0ksSUFBSSxDQUFDaUUsT0FBTyxDQUFDWixTQUFTLEdBQUcsRUFBRTtNQUMzQjNkLE1BQU0sQ0FBQ29iLElBQUksQ0FBQy9DLFFBQVEsQ0FBQyxFQUFFLEVBQUUwUCxNQUFNLENBQUNELFFBQVEsQ0FBQ25LLFNBQVMsRUFBRVksT0FBTyxDQUFDWixTQUFTLENBQUMsQ0FBQyxDQUFDRyxPQUFPLENBQUMsVUFBVW9CLElBQUksRUFBRTtRQUM5RnpoQixLQUFLLENBQUM4Z0IsT0FBTyxDQUFDWixTQUFTLENBQUN1QixJQUFJLENBQUMsR0FBRzdHLFFBQVEsQ0FBQyxFQUFFLEVBQUUwUCxNQUFNLENBQUNELFFBQVEsQ0FBQ25LLFNBQVMsQ0FBQ3VCLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRVgsT0FBTyxDQUFDWixTQUFTLEdBQUdZLE9BQU8sQ0FBQ1osU0FBUyxDQUFDdUIsSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDO01BQzNJLENBQUssQ0FBQzs7TUFFTjtNQUNJLElBQUksQ0FBQ3ZCLFNBQVMsR0FBRzNkLE1BQU0sQ0FBQ29iLElBQUksQ0FBQyxJQUFJLENBQUNtRCxPQUFPLENBQUNaLFNBQVMsQ0FBQyxDQUFDdEMsR0FBRyxDQUFDLFVBQVU2RCxJQUFJLEVBQUU7UUFDdkUsT0FBTzdHLFFBQVEsQ0FBQztVQUNkNkcsSUFBSSxFQUFFQTtRQUNkLENBQU8sRUFBRXpoQixLQUFLLENBQUM4Z0IsT0FBTyxDQUFDWixTQUFTLENBQUN1QixJQUFJLENBQUMsQ0FBQztNQUN2QyxDQUFLO01BQ0w7TUFBQSxDQUNLM0QsSUFBSSxDQUFDLFVBQVVDLENBQUMsRUFBRUMsQ0FBQyxFQUFFO1FBQ3BCLE9BQU9ELENBQUMsQ0FBQ3BHLEtBQUssR0FBR3FHLENBQUMsQ0FBQ3JHLEtBQUs7TUFDOUIsQ0FBSyxDQUFDOztNQUVOO01BQ0E7TUFDQTtNQUNBO01BQ0ksSUFBSSxDQUFDdUksU0FBUyxDQUFDRyxPQUFPLENBQUMsVUFBVTBELGVBQWUsRUFBRTtRQUNoRCxJQUFJQSxlQUFlLENBQUN2RCxPQUFPLElBQUloTCxVQUFVLENBQUN1TyxlQUFlLENBQUNxRyxNQUFNLENBQUMsRUFBRTtVQUNqRXJHLGVBQWUsQ0FBQ3FHLE1BQU0sQ0FBQ3BxQixLQUFLLENBQUN5VyxTQUFTLEVBQUV6VyxLQUFLLENBQUM2YyxNQUFNLEVBQUU3YyxLQUFLLENBQUM4Z0IsT0FBTyxFQUFFaUQsZUFBZSxFQUFFL2pCLEtBQUssQ0FBQ3NlLEtBQUssQ0FBQztRQUMxRztNQUNBLENBQUssQ0FBQzs7TUFFTjtNQUNJLElBQUksQ0FBQ21DLE1BQU0sRUFBRTtNQUViLElBQUlzQyxhQUFhLEdBQUcsSUFBSSxDQUFDakMsT0FBTyxDQUFDaUMsYUFBYTtNQUM5QyxJQUFJQSxhQUFhLEVBQUU7UUFDdkI7UUFDTSxJQUFJLENBQUNDLG9CQUFvQixFQUFFO01BQ2pDO01BRUksSUFBSSxDQUFDMUUsS0FBSyxDQUFDeUUsYUFBYSxHQUFHQSxhQUFhO0lBQzVDOztJQUVBO0lBQ0E7O0lBR0U5SSxXQUFXLENBQUNxUSxNQUFNLEVBQUUsQ0FBQztNQUNuQjdQLEdBQUcsRUFBRSxRQUFRO01BQ2I5WCxLQUFLLEVBQUUsU0FBUzZuQixTQUFTLEdBQUc7UUFDMUIsT0FBTy9KLE1BQU0sQ0FBQ2hpQixJQUFJLENBQUMsSUFBSSxDQUFDO01BQzlCO0lBQ0EsQ0FBRyxFQUFFO01BQ0RnYyxHQUFHLEVBQUUsU0FBUztNQUNkOVgsS0FBSyxFQUFFLFNBQVM4bkIsVUFBVSxHQUFHO1FBQzNCLE9BQU8xSSxPQUFPLENBQUN0akIsSUFBSSxDQUFDLElBQUksQ0FBQztNQUMvQjtJQUNBLENBQUcsRUFBRTtNQUNEZ2MsR0FBRyxFQUFFLHNCQUFzQjtNQUMzQjlYLEtBQUssRUFBRSxTQUFTK25CLHVCQUF1QixHQUFHO1FBQ3hDLE9BQU8xSCxvQkFBb0IsQ0FBQ3ZrQixJQUFJLENBQUMsSUFBSSxDQUFDO01BQzVDO0lBQ0EsQ0FBRyxFQUFFO01BQ0RnYyxHQUFHLEVBQUUsdUJBQXVCO01BQzVCOVgsS0FBSyxFQUFFLFNBQVNnb0Isd0JBQXdCLEdBQUc7UUFDekMsT0FBT3pJLHFCQUFxQixDQUFDempCLElBQUksQ0FBQyxJQUFJLENBQUM7TUFDN0M7O01BRUE7Ozs7OztNQU9BOzs7Ozs7Ozs7Ozs7Ozs7O0lBaUJBLENBQUcsQ0FBQyxDQUFDOztJQUNILE9BQU82ckIsTUFBTTtFQUNmLENBQUMsRUFBRTs7RUFFSDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUFxQkFBLE1BQU0sQ0FBQ00sS0FBSyxHQUFHLENBQUMsT0FBT2hpQixNQUFNLEtBQUssV0FBVyxHQUFHQSxNQUFNLEdBQUdpaUIscUJBQU0sRUFBRUMsV0FBVztFQUM1RVIsTUFBTSxDQUFDM0QsVUFBVSxHQUFHQSxVQUFVO0VBQzlCMkQsTUFBTSxDQUFDRCxRQUFRLEdBQUdBLFFBQVE7RUFFMUIsZUFBZUMsTUFBTTs7RUMzaUZyQjs7OztFQUlBLElBQU1ybUIsTUFBSSxHQUFHLFVBQWI7RUFDQSxJQUFNQyxTQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyxVQUFRLEdBQUcsYUFBakI7RUFDQSxJQUFNQyxXQUFTLFNBQU9ELFVBQXRCO0VBQ0EsSUFBTUUsY0FBWSxHQUFHLFdBQXJCO0VBQ0EsSUFBTUMsb0JBQWtCLEdBQUdyRixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxDQUEzQjtFQUNBLElBQU04bUIsZ0JBQWMsR0FBRyxFQUF2Qjs7RUFDQSxJQUFNQyxhQUFhLEdBQUcsRUFBdEI7O0VBQ0EsSUFBTUMsV0FBVyxHQUFHLENBQXBCOztFQUNBLElBQU1DLGdCQUFnQixHQUFHLEVBQXpCOztFQUNBLElBQU1DLGtCQUFrQixHQUFHLEVBQTNCOztFQUNBLElBQU1DLHdCQUF3QixHQUFHLENBQWpDOztFQUNBLElBQU1DLGNBQWMsR0FBRyxJQUFJeG9CLE1BQUosQ0FBY3FvQixnQkFBZCxTQUFrQ0Msa0JBQWxDLFNBQXdESixnQkFBeEQsQ0FBdkI7RUFFQSxJQUFNTyxxQkFBbUIsR0FBRyxVQUE1QjtFQUNBLElBQU03bUIsaUJBQWUsR0FBRyxNQUF4QjtFQUNBLElBQU04bUIsaUJBQWlCLEdBQUcsUUFBMUI7RUFDQSxJQUFNQyxvQkFBb0IsR0FBRyxXQUE3QjtFQUNBLElBQU1DLG1CQUFtQixHQUFHLFVBQTVCO0VBQ0EsSUFBTUMsb0JBQW9CLEdBQUcscUJBQTdCO0VBQ0EsSUFBTUMsMEJBQTBCLEdBQUcsaUJBQW5DO0VBRUEsSUFBTTFaLFlBQVUsWUFBVTdOLFdBQTFCO0VBQ0EsSUFBTThOLGNBQVksY0FBWTlOLFdBQTlCO0VBQ0EsSUFBTTJOLFlBQVUsWUFBVTNOLFdBQTFCO0VBQ0EsSUFBTTROLGFBQVcsYUFBVzVOLFdBQTVCO0VBQ0EsSUFBTXduQixXQUFXLGFBQVd4bkIsV0FBNUI7RUFDQSxJQUFNUSxzQkFBb0IsYUFBV1IsV0FBWCxHQUF1QkMsY0FBakQ7RUFDQSxJQUFNd25CLHNCQUFzQixlQUFhem5CLFdBQWIsR0FBeUJDLGNBQXJEO0VBQ0EsSUFBTXluQixvQkFBb0IsYUFBVzFuQixXQUFYLEdBQXVCQyxjQUFqRDtFQUVBLElBQU04QyxzQkFBb0IsR0FBRywwQkFBN0I7RUFDQSxJQUFNNGtCLG1CQUFtQixHQUFHLGdCQUE1QjtFQUNBLElBQU1DLGFBQWEsR0FBRyxnQkFBdEI7RUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxhQUE1QjtFQUNBLElBQU1DLHNCQUFzQixHQUFHLDZEQUEvQjtFQUVBLElBQU1DLGFBQWEsR0FBRyxXQUF0QjtFQUNBLElBQU1DLGdCQUFnQixHQUFHLFNBQXpCO0VBQ0EsSUFBTUMsZ0JBQWdCLEdBQUcsY0FBekI7RUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxZQUE1QjtFQUNBLElBQU1DLGVBQWUsR0FBRyxhQUF4QjtFQUNBLElBQU1DLGNBQWMsR0FBRyxZQUF2QjtFQUVBLElBQU1uaEIsU0FBTyxHQUFHO0lBQ2RrUixNQUFNLEVBQUUsQ0FETTtJQUVkeUUsSUFBSSxFQUFFLElBRlE7SUFHZHlMLFFBQVEsRUFBRSxjQUhJO0lBSWRoVyxTQUFTLEVBQUUsUUFKRztJQUtkaVcsT0FBTyxFQUFFLFNBTEs7SUFNZEMsWUFBWSxFQUFFO0VBTkEsQ0FBaEI7RUFTQSxJQUFNL2dCLGFBQVcsR0FBRztJQUNsQjJRLE1BQU0sRUFBRSwwQkFEVTtJQUVsQnlFLElBQUksRUFBRSxTQUZZO0lBR2xCeUwsUUFBUSxFQUFFLGtCQUhRO0lBSWxCaFcsU0FBUyxFQUFFLGtCQUpPO0lBS2xCaVcsT0FBTyxFQUFFLFFBTFM7SUFNbEJDLFlBQVksRUFBRTtFQU5JLENBQXBCO0VBU0E7Ozs7TUFJTUM7SUFDSixrQkFBWWhzQixPQUFaLEVBQXFCd0IsTUFBckIsRUFBNkI7TUFDM0IsS0FBSzJDLFFBQUwsR0FBZ0JuRSxPQUFoQjtNQUNBLEtBQUtpc0IsT0FBTCxHQUFlLElBQWY7TUFDQSxLQUFLcGdCLE9BQUwsR0FBZSxLQUFLQyxVQUFMLENBQWdCdEssTUFBaEIsQ0FBZjtNQUNBLEtBQUswcUIsS0FBTCxHQUFhLEtBQUtDLGVBQUwsRUFBYjtNQUNBLEtBQUtDLFNBQUwsR0FBaUIsS0FBS0MsYUFBTCxFQUFqQjtNQUVBLEtBQUsvZixrQkFBTDtJQUNEOzs7O0lBZUQ7V0FDQXhGLDJCQUFTO01BQ1AsSUFBSSxLQUFLM0MsUUFBTCxDQUFjbW9CLFFBQWQsSUFBMEJqdUIscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQndsQixxQkFBMUIsQ0FBOUIsRUFBOEU7UUFDNUU7TUFDRDtNQUVELElBQU02QixRQUFRLEdBQUdsdUIscUJBQUMsQ0FBQyxLQUFLNnRCLEtBQU4sQ0FBRCxDQUFjaG5CLFFBQWQsQ0FBdUJyQixpQkFBdkIsQ0FBakI7TUFFQW1vQixRQUFRLENBQUNRLFdBQVQ7TUFFQSxJQUFJRCxRQUFKLEVBQWM7UUFDWjtNQUNEO01BRUQsS0FBS2hhLElBQUwsQ0FBVSxJQUFWO0lBQ0Q7V0FFREEscUJBQUtrYSxTQUFMLEVBQXdCO01BQUEsSUFBbkJBLFNBQW1CO1FBQW5CQSxTQUFtQixHQUFQLEtBQU87TUFBQTtNQUN0QixJQUFJLEtBQUt0b0IsUUFBTCxDQUFjbW9CLFFBQWQsSUFBMEJqdUIscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQndsQixxQkFBMUIsQ0FBMUIsSUFBNEVyc0IscUJBQUMsQ0FBQyxLQUFLNnRCLEtBQU4sQ0FBRCxDQUFjaG5CLFFBQWQsQ0FBdUJyQixpQkFBdkIsQ0FBaEYsRUFBeUg7UUFDdkg7TUFDRDtNQUVELElBQU1xTCxhQUFhLEdBQUc7UUFDcEJBLGFBQWEsRUFBRSxLQUFLL0s7TUFEQSxDQUF0QjtNQUdBLElBQU11b0IsU0FBUyxHQUFHcnVCLHFCQUFDLENBQUMyRyxLQUFGLENBQVFtTSxZQUFSLEVBQW9CakMsYUFBcEIsQ0FBbEI7TUFDQSxJQUFNckssTUFBTSxHQUFHbW5CLFFBQVEsQ0FBQ1cscUJBQVQsQ0FBK0IsS0FBS3hvQixRQUFwQyxDQUFmO01BRUE5RixxQkFBQyxDQUFDd0csTUFBRCxDQUFELENBQVU1RCxPQUFWLENBQWtCeXJCLFNBQWxCO01BRUEsSUFBSUEsU0FBUyxDQUFDam9CLGtCQUFWLEVBQUosRUFBb0M7UUFDbEM7TUFDRCxDQWZxQjs7TUFrQnRCLElBQUksQ0FBQyxLQUFLMm5CLFNBQU4sSUFBbUJLLFNBQXZCLEVBQWtDO1FBQ2hDO1FBQ0EsSUFBSSxPQUFPL0MsUUFBUCxLQUFrQixXQUF0QixFQUFtQztVQUNqQyxNQUFNLElBQUk3bUIsU0FBSixDQUFjLCtEQUFkLENBQU47UUFDRDtRQUVELElBQUkrcEIsZ0JBQWdCLEdBQUcsS0FBS3pvQixRQUE1QjtRQUVBLElBQUksS0FBSzBILE9BQUwsQ0FBYWdLLFNBQWIsS0FBMkIsUUFBL0IsRUFBeUM7VUFDdkMrVyxnQkFBZ0IsR0FBRy9uQixNQUFuQjtRQUNELENBRkQsTUFFTyxJQUFJNUYsSUFBSSxDQUFDbUMsU0FBTCxDQUFlLEtBQUt5SyxPQUFMLENBQWFnSyxTQUE1QixDQUFKLEVBQTRDO1VBQ2pEK1csZ0JBQWdCLEdBQUcsS0FBSy9nQixPQUFMLENBQWFnSyxTQUFoQyxDQURpRDs7VUFJakQsSUFBSSxPQUFPLEtBQUtoSyxPQUFMLENBQWFnSyxTQUFiLENBQXVCOVMsTUFBOUIsS0FBeUMsV0FBN0MsRUFBMEQ7WUFDeEQ2cEIsZ0JBQWdCLEdBQUcsS0FBSy9nQixPQUFMLENBQWFnSyxTQUFiLENBQXVCLENBQXZCLENBQW5CO1VBQ0Q7UUFDRixDQWpCK0I7UUFvQmhDO1FBQ0E7O1FBQ0EsSUFBSSxLQUFLaEssT0FBTCxDQUFhZ2dCLFFBQWIsS0FBMEIsY0FBOUIsRUFBOEM7VUFDNUN4dEIscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUFVK0ssUUFBVixDQUFtQm1iLDBCQUFuQjtRQUNEO1FBRUQsS0FBS2tCLE9BQUwsR0FBZSxJQUFJdkMsUUFBSixDQUFXa0QsZ0JBQVgsRUFBNkIsS0FBS1YsS0FBbEMsRUFBeUMsS0FBS1csZ0JBQUwsRUFBekMsQ0FBZjtNQUNELENBN0NxQjtNQWdEdEI7TUFDQTtNQUNBOztNQUNBLElBQUksa0JBQWtCaHRCLFFBQVEsQ0FBQ3lDLGVBQTNCLElBQ0FqRSxxQkFBQyxDQUFDd0csTUFBRCxDQUFELENBQVVDLE9BQVYsQ0FBa0J1bUIsbUJBQWxCLEVBQXVDL2lCLE1BQXZDLEtBQWtELENBRHRELEVBQ3lEO1FBQ3ZEaksscUJBQUMsQ0FBQ3dCLFFBQVEsQ0FBQzBWLElBQVYsQ0FBRCxDQUFpQjVGLFFBQWpCLEdBQTRCOUosRUFBNUIsQ0FBK0IsV0FBL0IsRUFBNEMsSUFBNUMsRUFBa0R4SCxxQkFBQyxDQUFDeXVCLElBQXBEO01BQ0Q7TUFFRCxLQUFLM29CLFFBQUwsQ0FBY29ELEtBQWQ7TUFDQSxLQUFLcEQsUUFBTCxDQUFjc0QsWUFBZCxDQUEyQixlQUEzQixFQUE0QyxJQUE1QztNQUVBcEoscUJBQUMsQ0FBQyxLQUFLNnRCLEtBQU4sQ0FBRCxDQUFjeGtCLFdBQWQsQ0FBMEI3RCxpQkFBMUI7TUFDQXhGLHFCQUFDLENBQUN3RyxNQUFELENBQUQsQ0FDRzZDLFdBREgsQ0FDZTdELGlCQURmLEVBRUc1QyxPQUZILENBRVc1QyxxQkFBQyxDQUFDMkcsS0FBRixDQUFRb00sYUFBUixFQUFxQmxDLGFBQXJCLENBRlg7SUFHRDtXQUVEb0QsdUJBQU87TUFDTCxJQUFJLEtBQUtuTyxRQUFMLENBQWNtb0IsUUFBZCxJQUEwQmp1QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJlLFFBQWpCLENBQTBCd2xCLHFCQUExQixDQUExQixJQUE0RSxDQUFDcnNCLHFCQUFDLENBQUMsS0FBSzZ0QixLQUFOLENBQUQsQ0FBY2huQixRQUFkLENBQXVCckIsaUJBQXZCLENBQWpGLEVBQTBIO1FBQ3hIO01BQ0Q7TUFFRCxJQUFNcUwsYUFBYSxHQUFHO1FBQ3BCQSxhQUFhLEVBQUUsS0FBSy9LO01BREEsQ0FBdEI7TUFHQSxJQUFNNG9CLFNBQVMsR0FBRzF1QixxQkFBQyxDQUFDMkcsS0FBRixDQUFRcU0sWUFBUixFQUFvQm5DLGFBQXBCLENBQWxCO01BQ0EsSUFBTXJLLE1BQU0sR0FBR21uQixRQUFRLENBQUNXLHFCQUFULENBQStCLEtBQUt4b0IsUUFBcEMsQ0FBZjtNQUVBOUYscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUFVNUQsT0FBVixDQUFrQjhyQixTQUFsQjtNQUVBLElBQUlBLFNBQVMsQ0FBQ3RvQixrQkFBVixFQUFKLEVBQW9DO1FBQ2xDO01BQ0Q7TUFFRCxJQUFJLEtBQUt3bkIsT0FBVCxFQUFrQjtRQUNoQixLQUFLQSxPQUFMLENBQWE5SyxPQUFiO01BQ0Q7TUFFRDlpQixxQkFBQyxDQUFDLEtBQUs2dEIsS0FBTixDQUFELENBQWN4a0IsV0FBZCxDQUEwQjdELGlCQUExQjtNQUNBeEYscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUNHNkMsV0FESCxDQUNlN0QsaUJBRGYsRUFFRzVDLE9BRkgsQ0FFVzVDLHFCQUFDLENBQUMyRyxLQUFGLENBQVFzTSxjQUFSLEVBQXNCcEMsYUFBdEIsQ0FGWDtJQUdEO1dBRUR2Syw2QkFBVTtNQUNSdEcscUJBQUMsQ0FBQ3VHLFVBQUYsQ0FBYSxLQUFLVCxRQUFsQixFQUE0QlosVUFBNUI7TUFDQWxGLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQm9KLEdBQWpCLENBQXFCL0osV0FBckI7TUFDQSxLQUFLVyxRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBSytuQixLQUFMLEdBQWEsSUFBYjtNQUNBLElBQUksS0FBS0QsT0FBTCxLQUFpQixJQUFyQixFQUEyQjtRQUN6QixLQUFLQSxPQUFMLENBQWE5SyxPQUFiO1FBQ0EsS0FBSzhLLE9BQUwsR0FBZSxJQUFmO01BQ0Q7SUFDRjtXQUVEcE0sMkJBQVM7TUFDUCxLQUFLdU0sU0FBTCxHQUFpQixLQUFLQyxhQUFMLEVBQWpCO01BQ0EsSUFBSSxLQUFLSixPQUFMLEtBQWlCLElBQXJCLEVBQTJCO1FBQ3pCLEtBQUtBLE9BQUwsQ0FBYTVKLGNBQWI7TUFDRDtJQUNGO0lBQUE7O1dBR0QvVixtREFBcUI7TUFBQTtNQUNuQmpPLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQjBCLEVBQWpCLENBQW9CbWxCLFdBQXBCLEVBQWlDLGVBQUssRUFBSTtRQUN4QzVzQixLQUFLLENBQUN3SCxjQUFOO1FBQ0F4SCxLQUFLLENBQUM0dUIsZUFBTjtRQUNBNXRCLEtBQUksQ0FBQzBILE1BQUw7TUFDRCxDQUpEO0lBS0Q7V0FFRGdGLGlDQUFXdEssTUFBWCxFQUFtQjtNQUNqQkEsTUFBTSxrQkFDRCxLQUFLeXJCLFdBQUwsQ0FBaUJ4aUIsT0FEaEIsRUFFRHBNLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQnNCLElBQWpCLEVBRkMsRUFHRGpFLE1BSEMsQ0FBTjtNQU1BdkMsSUFBSSxDQUFDcUMsZUFBTCxDQUNFK0IsTUFERixFQUVFN0IsTUFGRixFQUdFLEtBQUt5ckIsV0FBTCxDQUFpQmppQixXQUhuQjtNQU1BLE9BQU94SixNQUFQO0lBQ0Q7V0FFRDJxQiw2Q0FBa0I7TUFDaEIsSUFBSSxDQUFDLEtBQUtELEtBQVYsRUFBaUI7UUFDZixJQUFNcm5CLE1BQU0sR0FBR21uQixRQUFRLENBQUNXLHFCQUFULENBQStCLEtBQUt4b0IsUUFBcEMsQ0FBZjtRQUVBLElBQUlVLE1BQUosRUFBWTtVQUNWLEtBQUtxbkIsS0FBTCxHQUFhcm5CLE1BQU0sQ0FBQ3hFLGFBQVAsQ0FBcUIrcUIsYUFBckIsQ0FBYjtRQUNEO01BQ0Y7TUFFRCxPQUFPLEtBQUtjLEtBQVo7SUFDRDtXQUVEZ0IseUNBQWdCO01BQ2QsSUFBTUMsZUFBZSxHQUFHOXVCLHFCQUFDLENBQUMsS0FBSzhGLFFBQUwsQ0FBY3hCLFVBQWYsQ0FBekI7TUFDQSxJQUFJZ2EsU0FBUyxHQUFHOE8sZ0JBQWhCLENBRmM7O01BS2QsSUFBSTBCLGVBQWUsQ0FBQ2pvQixRQUFoQixDQUF5QnlsQixpQkFBekIsQ0FBSixFQUFpRDtRQUMvQ2hPLFNBQVMsR0FBR3RlLHFCQUFDLENBQUMsS0FBSzZ0QixLQUFOLENBQUQsQ0FBY2huQixRQUFkLENBQXVCNGxCLG9CQUF2QixJQUNWVSxnQkFEVSxHQUVWRCxhQUZGO01BR0QsQ0FKRCxNQUlPLElBQUk0QixlQUFlLENBQUNqb0IsUUFBaEIsQ0FBeUIwbEIsb0JBQXpCLENBQUosRUFBb0Q7UUFDekRqTyxTQUFTLEdBQUdnUCxlQUFaO01BQ0QsQ0FGTSxNQUVBLElBQUl3QixlQUFlLENBQUNqb0IsUUFBaEIsQ0FBeUIybEIsbUJBQXpCLENBQUosRUFBbUQ7UUFDeERsTyxTQUFTLEdBQUdpUCxjQUFaO01BQ0QsQ0FGTSxNQUVBLElBQUl2dEIscUJBQUMsQ0FBQyxLQUFLNnRCLEtBQU4sQ0FBRCxDQUFjaG5CLFFBQWQsQ0FBdUI0bEIsb0JBQXZCLENBQUosRUFBa0Q7UUFDdkRuTyxTQUFTLEdBQUcrTyxtQkFBWjtNQUNEO01BRUQsT0FBTy9PLFNBQVA7SUFDRDtXQUVEMFAseUNBQWdCO01BQ2QsT0FBT2h1QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJXLE9BQWpCLENBQXlCLFNBQXpCLEVBQW9Dd0QsTUFBcEMsR0FBNkMsQ0FBcEQ7SUFDRDtXQUVEOGtCLG1DQUFhO01BQUE7TUFDWCxJQUFNelIsTUFBTSxHQUFHLEVBQWY7TUFFQSxJQUFJLE9BQU8sS0FBSzlQLE9BQUwsQ0FBYThQLE1BQXBCLEtBQStCLFVBQW5DLEVBQStDO1FBQzdDQSxNQUFNLENBQUNyYyxFQUFQLEdBQVksY0FBSSxFQUFJO1VBQ2xCbUcsSUFBSSxDQUFDMlUsT0FBTCxrQkFDSzNVLElBQUksQ0FBQzJVLE9BRFYsRUFFS3pNLE1BQUksQ0FBQzlCLE9BQUwsQ0FBYThQLE1BQWIsQ0FBb0JsVyxJQUFJLENBQUMyVSxPQUF6QixFQUFrQ3pNLE1BQUksQ0FBQ3hKLFFBQXZDLENBRkw7VUFLQSxPQUFPc0IsSUFBUDtRQUNELENBUEQ7TUFRRCxDQVRELE1BU087UUFDTGtXLE1BQU0sQ0FBQ0EsTUFBUCxHQUFnQixLQUFLOVAsT0FBTCxDQUFhOFAsTUFBN0I7TUFDRDtNQUVELE9BQU9BLE1BQVA7SUFDRDtXQUVEa1IsK0NBQW1CO01BQ2pCLElBQU1kLFlBQVksR0FBRztRQUNuQnBQLFNBQVMsRUFBRSxLQUFLdVEsYUFBTCxFQURRO1FBRW5CNU4sU0FBUyxFQUFFO1VBQ1QzRCxNQUFNLEVBQUUsS0FBS3lSLFVBQUwsRUFEQztVQUVUaE4sSUFBSSxFQUFFO1lBQ0pSLE9BQU8sRUFBRSxLQUFLL1QsT0FBTCxDQUFhdVU7VUFEbEIsQ0FGRztVQUtUc0ksZUFBZSxFQUFFO1lBQ2Z2TSxpQkFBaUIsRUFBRSxLQUFLdFEsT0FBTCxDQUFhZ2dCO1VBRGpCO1FBTFI7TUFGUSxDQUFyQixDQURpQjs7TUFlakIsSUFBSSxLQUFLaGdCLE9BQUwsQ0FBYWlnQixPQUFiLEtBQXlCLFFBQTdCLEVBQXVDO1FBQ3JDQyxZQUFZLENBQUN6TSxTQUFiLENBQXVCMEQsVUFBdkIsR0FBb0M7VUFDbENwRCxPQUFPLEVBQUU7UUFEeUIsQ0FBcEM7TUFHRDtNQUVELHNCQUNLbU0sWUFETCxFQUVLLEtBQUtsZ0IsT0FBTCxDQUFha2dCLFlBRmxCO0lBSUQ7SUFBQTs7YUFHTXptQixtQkFBUCwwQkFBd0I5RCxNQUF4QixFQUFnQztNQUM5QixPQUFPLEtBQUsrRCxJQUFMLENBQVUsWUFBWTtRQUMzQixJQUFJRSxJQUFJLEdBQUdwSCxxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRb0gsSUFBUixDQUFhbEMsVUFBYixDQUFYO1FBQ0EsSUFBTXNJLE9BQU8sR0FBRyxRQUFPckssTUFBUCxNQUFrQixRQUFsQixHQUE2QkEsTUFBN0IsR0FBc0MsSUFBdEQ7UUFFQSxJQUFJLENBQUNpRSxJQUFMLEVBQVc7VUFDVEEsSUFBSSxHQUFHLElBQUl1bUIsUUFBSixDQUFhLElBQWIsRUFBbUJuZ0IsT0FBbkIsQ0FBUDtVQUNBeE4scUJBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUW9ILElBQVIsQ0FBYWxDLFVBQWIsRUFBdUJrQyxJQUF2QjtRQUNEO1FBRUQsSUFBSSxPQUFPakUsTUFBUCxLQUFrQixRQUF0QixFQUFnQztVQUM5QixJQUFJLE9BQU9pRSxJQUFJLENBQUNqRSxNQUFELENBQVgsS0FBd0IsV0FBNUIsRUFBeUM7WUFDdkMsTUFBTSxJQUFJcUIsU0FBSix3QkFBa0NyQixNQUFsQyxRQUFOO1VBQ0Q7VUFFRGlFLElBQUksQ0FBQ2pFLE1BQUQsQ0FBSjtRQUNEO01BQ0YsQ0FoQk0sQ0FBUDtJQWlCRDthQUVNZ3JCLGNBQVAscUJBQW1CcHVCLEtBQW5CLEVBQTBCO01BQ3hCLElBQUlBLEtBQUssS0FBS0EsS0FBSyxDQUFDb1EsS0FBTixLQUFnQmdjLHdCQUFoQixJQUNacHNCLEtBQUssQ0FBQzhJLElBQU4sS0FBZSxPQUFmLElBQTBCOUksS0FBSyxDQUFDb1EsS0FBTixLQUFnQjZiLFdBRG5DLENBQVQsRUFDMEQ7UUFDeEQ7TUFDRDtNQUVELElBQU1nRCxPQUFPLEdBQUcsR0FBR25sQixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQjVCLHNCQUExQixDQUFkLENBQWhCO01BRUEsS0FBSyxJQUFJNkIsQ0FBQyxHQUFHLENBQVIsRUFBV0MsR0FBRyxHQUFHZ2xCLE9BQU8sQ0FBQy9rQixNQUE5QixFQUFzQ0YsQ0FBQyxHQUFHQyxHQUExQyxFQUErQ0QsQ0FBQyxFQUFoRCxFQUFvRDtRQUNsRCxJQUFNdkQsTUFBTSxHQUFHbW5CLFFBQVEsQ0FBQ1cscUJBQVQsQ0FBK0JVLE9BQU8sQ0FBQ2psQixDQUFELENBQXRDLENBQWY7UUFDQSxJQUFNa2xCLE9BQU8sR0FBR2p2QixxQkFBQyxDQUFDZ3ZCLE9BQU8sQ0FBQ2psQixDQUFELENBQVIsQ0FBRCxDQUFjM0MsSUFBZCxDQUFtQmxDLFVBQW5CLENBQWhCO1FBQ0EsSUFBTTJMLGFBQWEsR0FBRztVQUNwQkEsYUFBYSxFQUFFbWUsT0FBTyxDQUFDamxCLENBQUQ7UUFERixDQUF0QjtRQUlBLElBQUloSyxLQUFLLElBQUlBLEtBQUssQ0FBQzhJLElBQU4sS0FBZSxPQUE1QixFQUFxQztVQUNuQ2dJLGFBQWEsQ0FBQ3FlLFVBQWQsR0FBMkJudkIsS0FBM0I7UUFDRDtRQUVELElBQUksQ0FBQ2t2QixPQUFMLEVBQWM7VUFDWjtRQUNEO1FBRUQsSUFBTUUsWUFBWSxHQUFHRixPQUFPLENBQUNwQixLQUE3QjtRQUNBLElBQUksQ0FBQzd0QixxQkFBQyxDQUFDd0csTUFBRCxDQUFELENBQVVLLFFBQVYsQ0FBbUJyQixpQkFBbkIsQ0FBTCxFQUEwQztVQUN4QztRQUNEO1FBRUQsSUFBSXpGLEtBQUssS0FBS0EsS0FBSyxDQUFDOEksSUFBTixLQUFlLE9BQWYsSUFDVixrQkFBa0JoRixJQUFsQixDQUF1QjlELEtBQUssQ0FBQ0UsTUFBTixDQUFheUosT0FBcEMsQ0FEVSxJQUNzQzNKLEtBQUssQ0FBQzhJLElBQU4sS0FBZSxPQUFmLElBQTBCOUksS0FBSyxDQUFDb1EsS0FBTixLQUFnQjZiLFdBRHJGLENBQUwsSUFFQWhzQixxQkFBQyxDQUFDZ0osUUFBRixDQUFXeEMsTUFBWCxFQUFtQnpHLEtBQUssQ0FBQ0UsTUFBekIsQ0FGSixFQUVzQztVQUNwQztRQUNEO1FBRUQsSUFBTXl1QixTQUFTLEdBQUcxdUIscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUXFNLFlBQVIsRUFBb0JuQyxhQUFwQixDQUFsQjtRQUNBN1EscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUFVNUQsT0FBVixDQUFrQjhyQixTQUFsQjtRQUNBLElBQUlBLFNBQVMsQ0FBQ3RvQixrQkFBVixFQUFKLEVBQW9DO1VBQ2xDO1FBQ0QsQ0E5QmlEO1FBaUNsRDs7UUFDQSxJQUFJLGtCQUFrQjVFLFFBQVEsQ0FBQ3lDLGVBQS9CLEVBQWdEO1VBQzlDakUscUJBQUMsQ0FBQ3dCLFFBQVEsQ0FBQzBWLElBQVYsQ0FBRCxDQUFpQjVGLFFBQWpCLEdBQTRCcEMsR0FBNUIsQ0FBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsRUFBbURsUCxxQkFBQyxDQUFDeXVCLElBQXJEO1FBQ0Q7UUFFRE8sT0FBTyxDQUFDamxCLENBQUQsQ0FBUCxDQUFXWCxZQUFYLENBQXdCLGVBQXhCLEVBQXlDLE9BQXpDO1FBRUEsSUFBSTZsQixPQUFPLENBQUNyQixPQUFaLEVBQXFCO1VBQ25CcUIsT0FBTyxDQUFDckIsT0FBUixDQUFnQjlLLE9BQWhCO1FBQ0Q7UUFFRDlpQixxQkFBQyxDQUFDbXZCLFlBQUQsQ0FBRCxDQUFnQnZvQixXQUFoQixDQUE0QnBCLGlCQUE1QjtRQUNBeEYscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUNHSSxXQURILENBQ2VwQixpQkFEZixFQUVHNUMsT0FGSCxDQUVXNUMscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUXNNLGNBQVIsRUFBc0JwQyxhQUF0QixDQUZYO01BR0Q7SUFDRjthQUVNeWQsd0JBQVAsK0JBQTZCM3NCLE9BQTdCLEVBQXNDO01BQ3BDLElBQUk2RSxNQUFKO01BQ0EsSUFBTTVFLFFBQVEsR0FBR2hCLElBQUksQ0FBQ2Msc0JBQUwsQ0FBNEJDLE9BQTVCLENBQWpCO01BRUEsSUFBSUMsUUFBSixFQUFjO1FBQ1o0RSxNQUFNLEdBQUdoRixRQUFRLENBQUNRLGFBQVQsQ0FBdUJKLFFBQXZCLENBQVQ7TUFDRDtNQUVELE9BQU80RSxNQUFNLElBQUk3RSxPQUFPLENBQUMyQyxVQUF6QjtJQUNEO0lBQUE7O2FBR004cUIseUJBQVAsZ0NBQThCcnZCLEtBQTlCLEVBQXFDO01BQ25DO01BQ0E7TUFDQTtNQUNBO01BQ0E7TUFDQTtNQUNBO01BQ0EsSUFBSSxrQkFBa0I4RCxJQUFsQixDQUF1QjlELEtBQUssQ0FBQ0UsTUFBTixDQUFheUosT0FBcEMsSUFDRjNKLEtBQUssQ0FBQ29RLEtBQU4sS0FBZ0I0YixhQUFoQixJQUFpQ2hzQixLQUFLLENBQUNvUSxLQUFOLEtBQWdCMmIsZ0JBQWhCLEtBQ2hDL3JCLEtBQUssQ0FBQ29RLEtBQU4sS0FBZ0IrYixrQkFBaEIsSUFBc0Nuc0IsS0FBSyxDQUFDb1EsS0FBTixLQUFnQjhiLGdCQUF0RCxJQUNDanNCLHFCQUFDLENBQUNELEtBQUssQ0FBQ0UsTUFBUCxDQUFELENBQWdCd0csT0FBaEIsQ0FBd0JzbUIsYUFBeEIsRUFBdUM5aUIsTUFGUixDQUQvQixHQUdpRCxDQUFDbWlCLGNBQWMsQ0FBQ3ZvQixJQUFmLENBQW9COUQsS0FBSyxDQUFDb1EsS0FBMUIsQ0FIdEQsRUFHd0Y7UUFDdEY7TUFDRDtNQUVELElBQUksS0FBSzhkLFFBQUwsSUFBaUJqdUIscUJBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUTZHLFFBQVIsQ0FBaUJ3bEIscUJBQWpCLENBQXJCLEVBQTREO1FBQzFEO01BQ0Q7TUFFRCxJQUFNN2xCLE1BQU0sR0FBR21uQixRQUFRLENBQUNXLHFCQUFULENBQStCLElBQS9CLENBQWY7TUFDQSxJQUFNSixRQUFRLEdBQUdsdUIscUJBQUMsQ0FBQ3dHLE1BQUQsQ0FBRCxDQUFVSyxRQUFWLENBQW1CckIsaUJBQW5CLENBQWpCO01BRUEsSUFBSSxDQUFDMG9CLFFBQUQsSUFBYW51QixLQUFLLENBQUNvUSxLQUFOLEtBQWdCMmIsZ0JBQWpDLEVBQWlEO1FBQy9DO01BQ0Q7TUFFRC9yQixLQUFLLENBQUN3SCxjQUFOO01BQ0F4SCxLQUFLLENBQUM0dUIsZUFBTjtNQUVBLElBQUksQ0FBQ1QsUUFBRCxJQUFjbnVCLEtBQUssQ0FBQ29RLEtBQU4sS0FBZ0IyYixnQkFBaEIsSUFBa0MvckIsS0FBSyxDQUFDb1EsS0FBTixLQUFnQjRiLGFBQXBFLEVBQW9GO1FBQ2xGLElBQUloc0IsS0FBSyxDQUFDb1EsS0FBTixLQUFnQjJiLGdCQUFwQixFQUFvQztVQUNsQzlyQixxQkFBQyxDQUFDd0csTUFBTSxDQUFDeEUsYUFBUCxDQUFxQmtHLHNCQUFyQixDQUFELENBQUQsQ0FBOEN0RixPQUE5QyxDQUFzRCxPQUF0RDtRQUNEO1FBRUQ1QyxxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRNEMsT0FBUixDQUFnQixPQUFoQjtRQUNBO01BQ0Q7TUFFRCxJQUFNeXNCLEtBQUssR0FBRyxHQUFHeGxCLEtBQUgsQ0FBU3JLLElBQVQsQ0FBY2dILE1BQU0sQ0FBQ3NELGdCQUFQLENBQXdCbWpCLHNCQUF4QixDQUFkLEVBQ1h2WixNQURXLENBQ0osY0FBSTtRQUFBLE9BQUkxVCxxQkFBQyxDQUFDc3ZCLElBQUQsQ0FBRCxDQUFRcHZCLEVBQVIsQ0FBVyxVQUFYLENBQUo7TUFBQSxDQURBLENBQWQ7TUFHQSxJQUFJbXZCLEtBQUssQ0FBQ3BsQixNQUFOLEtBQWlCLENBQXJCLEVBQXdCO1FBQ3RCO01BQ0Q7TUFFRCxJQUFJNkUsS0FBSyxHQUFHdWdCLEtBQUssQ0FBQ2pmLE9BQU4sQ0FBY3JRLEtBQUssQ0FBQ0UsTUFBcEIsQ0FBWjtNQUVBLElBQUlGLEtBQUssQ0FBQ29RLEtBQU4sS0FBZ0I4YixnQkFBaEIsSUFBb0NuZCxLQUFLLEdBQUcsQ0FBaEQsRUFBbUQ7UUFBRTtRQUNuREEsS0FBSztNQUNOO01BRUQsSUFBSS9PLEtBQUssQ0FBQ29RLEtBQU4sS0FBZ0IrYixrQkFBaEIsSUFBc0NwZCxLQUFLLEdBQUd1Z0IsS0FBSyxDQUFDcGxCLE1BQU4sR0FBZSxDQUFqRSxFQUFvRTtRQUFFO1FBQ3BFNkUsS0FBSztNQUNOO01BRUQsSUFBSUEsS0FBSyxHQUFHLENBQVosRUFBZTtRQUNiQSxLQUFLLEdBQUcsQ0FBUjtNQUNEO01BRUR1Z0IsS0FBSyxDQUFDdmdCLEtBQUQsQ0FBTCxDQUFhNUYsS0FBYjtJQUNEOzs7V0E5WUQsZUFBcUI7UUFDbkIsT0FBT2pFLFNBQVA7TUFDRDs7O1dBRUQsZUFBcUI7UUFDbkIsT0FBT21ILFNBQVA7TUFDRDs7O1dBRUQsZUFBeUI7UUFDdkIsT0FBT08sYUFBUDtNQUNEOzs7O0VBdVlIOzs7O0VBSUEzTSxxQkFBQyxDQUFDd0IsUUFBRCxDQUFELENBQ0dnRyxFQURILENBQ01vbEIsc0JBRE4sRUFDOEIxa0Isc0JBRDlCLEVBQ29EeWxCLFFBQVEsQ0FBQ3lCLHNCQUQ3RCxFQUVHNW5CLEVBRkgsQ0FFTW9sQixzQkFGTixFQUU4QkcsYUFGOUIsRUFFNkNZLFFBQVEsQ0FBQ3lCLHNCQUZ0RCxFQUdHNW5CLEVBSEgsQ0FHUzdCLHNCQUhULFNBR2lDa25CLG9CQUhqQyxFQUd5RGMsUUFBUSxDQUFDUSxXQUhsRSxFQUlHM21CLEVBSkgsQ0FJTTdCLHNCQUpOLEVBSTRCdUMsc0JBSjVCLEVBSWtELFVBQVVuSSxLQUFWLEVBQWlCO0lBQy9EQSxLQUFLLENBQUN3SCxjQUFOO0lBQ0F4SCxLQUFLLENBQUM0dUIsZUFBTjtJQUNBaEIsUUFBUSxDQUFDMW1CLGdCQUFULENBQTBCekgsSUFBMUIsQ0FBK0JRLHFCQUFDLENBQUMsSUFBRCxDQUFoQyxFQUF3QyxRQUF4QztFQUNELENBUkgsRUFTR3dILEVBVEgsQ0FTTTdCLHNCQVROLEVBUzRCbW5CLG1CQVQ1QixFQVNpRCxXQUFDLEVBQUk7SUFDbEQ1YyxDQUFDLENBQUN5ZSxlQUFGO0VBQ0QsQ0FYSDtFQWFBOzs7O0VBSUEzdUIscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYTJvQixRQUFRLENBQUMxbUIsZ0JBQXRCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5QmttQixRQUF6QjtFQUNBM3RCLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU9zb0IsUUFBUSxDQUFDMW1CLGdCQUFoQjtFQUNELENBSEQ7O0VDM2ZBOzs7O0VBSUEsSUFBTWpDLE1BQUksR0FBRyxPQUFiO0VBQ0EsSUFBTUMsU0FBTyxHQUFHLE9BQWhCO0VBQ0EsSUFBTUMsVUFBUSxHQUFHLFVBQWpCO0VBQ0EsSUFBTUMsV0FBUyxTQUFPRCxVQUF0QjtFQUNBLElBQU1FLGNBQVksR0FBRyxXQUFyQjtFQUNBLElBQU1DLG9CQUFrQixHQUFHckYscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsQ0FBM0I7RUFDQSxJQUFNOG1CLGNBQWMsR0FBRyxFQUF2Qjs7RUFFQSxJQUFNeUQscUJBQXFCLEdBQUcseUJBQTlCO0VBQ0EsSUFBTUMsNkJBQTZCLEdBQUcseUJBQXRDO0VBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsZ0JBQTVCO0VBQ0EsSUFBTUMsZUFBZSxHQUFHLFlBQXhCO0VBQ0EsSUFBTW5xQixpQkFBZSxHQUFHLE1BQXhCO0VBQ0EsSUFBTUMsaUJBQWUsR0FBRyxNQUF4QjtFQUNBLElBQU1tcUIsaUJBQWlCLEdBQUcsY0FBMUI7RUFFQSxJQUFNM2MsWUFBVSxZQUFVN04sV0FBMUI7RUFDQSxJQUFNeXFCLG9CQUFvQixxQkFBbUJ6cUIsV0FBN0M7RUFDQSxJQUFNOE4sY0FBWSxjQUFZOU4sV0FBOUI7RUFDQSxJQUFNMk4sWUFBVSxZQUFVM04sV0FBMUI7RUFDQSxJQUFNNE4sYUFBVyxhQUFXNU4sV0FBNUI7RUFDQSxJQUFNMHFCLGFBQWEsZUFBYTFxQixXQUFoQztFQUNBLElBQU0ycUIsWUFBWSxjQUFZM3FCLFdBQTlCO0VBQ0EsSUFBTTRxQixxQkFBbUIscUJBQW1CNXFCLFdBQTVDO0VBQ0EsSUFBTTZxQixxQkFBcUIsdUJBQXFCN3FCLFdBQWhEO0VBQ0EsSUFBTThxQixxQkFBcUIsdUJBQXFCOXFCLFdBQWhEO0VBQ0EsSUFBTStxQix1QkFBdUIseUJBQXVCL3FCLFdBQXBEO0VBQ0EsSUFBTVEsc0JBQW9CLGFBQVdSLFdBQVgsR0FBdUJDLGNBQWpEO0VBRUEsSUFBTStxQixlQUFlLEdBQUcsZUFBeEI7RUFDQSxJQUFNQyxtQkFBbUIsR0FBRyxhQUE1QjtFQUNBLElBQU1sb0Isc0JBQW9CLEdBQUcsdUJBQTdCO0VBQ0EsSUFBTW1vQix1QkFBcUIsR0FBRyx3QkFBOUI7RUFDQSxJQUFNQyxzQkFBc0IsR0FBRyxtREFBL0I7RUFDQSxJQUFNQyx1QkFBdUIsR0FBRyxhQUFoQztFQUVBLElBQU1ua0IsU0FBTyxHQUFHO0lBQ2Rva0IsUUFBUSxFQUFFLElBREk7SUFFZGxrQixRQUFRLEVBQUUsSUFGSTtJQUdkcEQsS0FBSyxFQUFFLElBSE87SUFJZGdMLElBQUksRUFBRTtFQUpRLENBQWhCO0VBT0EsSUFBTXZILGFBQVcsR0FBRztJQUNsQjZqQixRQUFRLEVBQUUsa0JBRFE7SUFFbEJsa0IsUUFBUSxFQUFFLFNBRlE7SUFHbEJwRCxLQUFLLEVBQUUsU0FIVztJQUlsQmdMLElBQUksRUFBRTtFQUpZLENBQXBCO0VBT0E7Ozs7TUFJTXVjO0lBQ0osZUFBWTl1QixPQUFaLEVBQXFCd0IsTUFBckIsRUFBNkI7TUFDM0IsS0FBS3FLLE9BQUwsR0FBZSxLQUFLQyxVQUFMLENBQWdCdEssTUFBaEIsQ0FBZjtNQUNBLEtBQUsyQyxRQUFMLEdBQWdCbkUsT0FBaEI7TUFDQSxLQUFLK3VCLE9BQUwsR0FBZS91QixPQUFPLENBQUNLLGFBQVIsQ0FBc0JtdUIsZUFBdEIsQ0FBZjtNQUNBLEtBQUtRLFNBQUwsR0FBaUIsSUFBakI7TUFDQSxLQUFLQyxRQUFMLEdBQWdCLEtBQWhCO01BQ0EsS0FBS0Msa0JBQUwsR0FBMEIsS0FBMUI7TUFDQSxLQUFLQyxvQkFBTCxHQUE0QixLQUE1QjtNQUNBLEtBQUsxZCxnQkFBTCxHQUF3QixLQUF4QjtNQUNBLEtBQUsyZCxlQUFMLEdBQXVCLENBQXZCO0lBQ0Q7Ozs7SUFXRDtXQUNBdG9CLHlCQUFPb0ksYUFBUCxFQUFzQjtNQUNwQixPQUFPLEtBQUsrZixRQUFMLEdBQWdCLEtBQUszYyxJQUFMLEVBQWhCLEdBQThCLEtBQUtDLElBQUwsQ0FBVXJELGFBQVYsQ0FBckM7SUFDRDtXQUVEcUQscUJBQUtyRCxhQUFMLEVBQW9CO01BQUE7TUFDbEIsSUFBSSxLQUFLK2YsUUFBTCxJQUFpQixLQUFLeGQsZ0JBQTFCLEVBQTRDO1FBQzFDO01BQ0Q7TUFFRCxJQUFNaWIsU0FBUyxHQUFHcnVCLHFCQUFDLENBQUMyRyxLQUFGLENBQVFtTSxZQUFSLEVBQW9CO1FBQ3BDakMsYUFBYSxFQUFiQTtNQURvQyxDQUFwQixDQUFsQjtNQUlBN1EscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJ5ckIsU0FBekI7TUFFQSxJQUFJQSxTQUFTLENBQUNqb0Isa0JBQVYsRUFBSixFQUFvQztRQUNsQztNQUNEO01BRUQsS0FBS3dxQixRQUFMLEdBQWdCLElBQWhCO01BRUEsSUFBSTV3QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJlLFFBQWpCLENBQTBCdEIsaUJBQTFCLENBQUosRUFBZ0Q7UUFDOUMsS0FBSzZOLGdCQUFMLEdBQXdCLElBQXhCO01BQ0Q7TUFFRCxLQUFLNGQsZUFBTDtNQUNBLEtBQUtDLGFBQUw7TUFFQSxLQUFLQyxhQUFMO01BRUEsS0FBS0MsZUFBTDtNQUNBLEtBQUtDLGVBQUw7TUFFQXB4QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUIwQixFQUFqQixDQUNFdW9CLHFCQURGLEVBRUVNLHVCQUZGLEVBR0UsZUFBSztRQUFBLE9BQUl0dkIsS0FBSSxDQUFDa1QsSUFBTCxDQUFVbFUsS0FBVixDQUFKO01BQUEsQ0FIUDtNQU1BQyxxQkFBQyxDQUFDLEtBQUswd0IsT0FBTixDQUFELENBQWdCbHBCLEVBQWhCLENBQW1CMG9CLHVCQUFuQixFQUE0QyxZQUFNO1FBQ2hEbHdCLHFCQUFDLENBQUNlLEtBQUksQ0FBQytFLFFBQU4sQ0FBRCxDQUFpQm5GLEdBQWpCLENBQXFCc3ZCLHFCQUFyQixFQUE0QyxlQUFLLEVBQUk7VUFDbkQsSUFBSWp3QixxQkFBQyxDQUFDRCxLQUFLLENBQUNFLE1BQVAsQ0FBRCxDQUFnQkMsRUFBaEIsQ0FBbUJhLEtBQUksQ0FBQytFLFFBQXhCLENBQUosRUFBdUM7WUFDckMvRSxLQUFJLENBQUMrdkIsb0JBQUwsR0FBNEIsSUFBNUI7VUFDRDtRQUNGLENBSkQ7TUFLRCxDQU5EO01BUUEsS0FBS08sYUFBTCxDQUFtQjtRQUFBLE9BQU10d0IsS0FBSSxDQUFDdXdCLFlBQUwsQ0FBa0J6Z0IsYUFBbEIsQ0FBTjtNQUFBLENBQW5CO0lBQ0Q7V0FFRG9ELHFCQUFLbFUsS0FBTCxFQUFZO01BQUE7TUFDVixJQUFJQSxLQUFKLEVBQVc7UUFDVEEsS0FBSyxDQUFDd0gsY0FBTjtNQUNEO01BRUQsSUFBSSxDQUFDLEtBQUtxcEIsUUFBTixJQUFrQixLQUFLeGQsZ0JBQTNCLEVBQTZDO1FBQzNDO01BQ0Q7TUFFRCxJQUFNc2IsU0FBUyxHQUFHMXVCLHFCQUFDLENBQUMyRyxLQUFGLENBQVFxTSxZQUFSLENBQWxCO01BRUFoVCxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJsRCxPQUFqQixDQUF5QjhyQixTQUF6QjtNQUVBLElBQUksQ0FBQyxLQUFLa0MsUUFBTixJQUFrQmxDLFNBQVMsQ0FBQ3RvQixrQkFBVixFQUF0QixFQUFzRDtRQUNwRDtNQUNEO01BRUQsS0FBS3dxQixRQUFMLEdBQWdCLEtBQWhCO01BQ0EsSUFBTVcsVUFBVSxHQUFHdnhCLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmUsUUFBakIsQ0FBMEJ0QixpQkFBMUIsQ0FBbkI7TUFFQSxJQUFJZ3NCLFVBQUosRUFBZ0I7UUFDZCxLQUFLbmUsZ0JBQUwsR0FBd0IsSUFBeEI7TUFDRDtNQUVELEtBQUsrZCxlQUFMO01BQ0EsS0FBS0MsZUFBTDtNQUVBcHhCLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWTBOLEdBQVosQ0FBZ0IyZ0IsYUFBaEI7TUFFQTd2QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJjLFdBQWpCLENBQTZCcEIsaUJBQTdCO01BRUF4RixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJvSixHQUFqQixDQUFxQjZnQixxQkFBckI7TUFDQS92QixxQkFBQyxDQUFDLEtBQUswd0IsT0FBTixDQUFELENBQWdCeGhCLEdBQWhCLENBQW9CZ2hCLHVCQUFwQjtNQUVBLElBQUlxQixVQUFKLEVBQWdCO1FBQ2QsSUFBTXB2QixrQkFBa0IsR0FBR3ZCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDLEtBQUs0RCxRQUEzQyxDQUEzQjtRQUVBOUYscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQ0duRixHQURILENBQ09DLElBQUksQ0FBQzFCLGNBRFosRUFDNEIsZUFBSztVQUFBLE9BQUlvUSxNQUFJLENBQUNraUIsVUFBTCxDQUFnQnp4QixLQUFoQixDQUFKO1FBQUEsQ0FEakMsRUFFR21CLG9CQUZILENBRXdCaUIsa0JBRnhCO01BR0QsQ0FORCxNQU1PO1FBQ0wsS0FBS3F2QixVQUFMO01BQ0Q7SUFDRjtXQUVEbHJCLDZCQUFVO01BQ1IsQ0FBQ3FELE1BQUQsRUFBUyxLQUFLN0QsUUFBZCxFQUF3QixLQUFLNHFCLE9BQTdCLEVBQ0d0UCxPQURILENBQ1cscUJBQVc7UUFBQSxPQUFJcGhCLHFCQUFDLENBQUN5eEIsV0FBRCxDQUFELENBQWV2aUIsR0FBZixDQUFtQi9KLFdBQW5CLENBQUo7TUFBQSxDQUR0QjtNQUdBOzs7Ozs7TUFLQW5GLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWTBOLEdBQVosQ0FBZ0IyZ0IsYUFBaEI7TUFFQTd2QixxQkFBQyxDQUFDdUcsVUFBRixDQUFhLEtBQUtULFFBQWxCLEVBQTRCWixVQUE1QjtNQUVBLEtBQUtzSSxPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUsxSCxRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBSzRxQixPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUtDLFNBQUwsR0FBaUIsSUFBakI7TUFDQSxLQUFLQyxRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBS0Msa0JBQUwsR0FBMEIsSUFBMUI7TUFDQSxLQUFLQyxvQkFBTCxHQUE0QixJQUE1QjtNQUNBLEtBQUsxZCxnQkFBTCxHQUF3QixJQUF4QjtNQUNBLEtBQUsyZCxlQUFMLEdBQXVCLElBQXZCO0lBQ0Q7V0FFRFcsdUNBQWU7TUFDYixLQUFLUixhQUFMO0lBQ0Q7SUFBQTs7V0FHRHpqQixpQ0FBV3RLLE1BQVgsRUFBbUI7TUFDakJBLE1BQU0sa0JBQ0RpSixTQURDLEVBRURqSixNQUZDLENBQU47TUFJQXZDLElBQUksQ0FBQ3FDLGVBQUwsQ0FBcUIrQixNQUFyQixFQUEyQjdCLE1BQTNCLEVBQW1Dd0osYUFBbkM7TUFDQSxPQUFPeEosTUFBUDtJQUNEO1dBRUR3dUIsbUVBQTZCO01BQUE7TUFDM0IsSUFBTUMsa0JBQWtCLEdBQUc1eEIscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUWlwQixvQkFBUixDQUEzQjtNQUVBNXZCLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCZ3ZCLGtCQUF6QjtNQUNBLElBQUlBLGtCQUFrQixDQUFDeHJCLGtCQUFuQixFQUFKLEVBQTZDO1FBQzNDO01BQ0Q7TUFFRCxJQUFNeXJCLGtCQUFrQixHQUFHLEtBQUsvckIsUUFBTCxDQUFjZ3NCLFlBQWQsR0FBNkJ0d0IsUUFBUSxDQUFDeUMsZUFBVCxDQUF5QmtZLFlBQWpGO01BRUEsSUFBSSxDQUFDMFYsa0JBQUwsRUFBeUI7UUFDdkIsS0FBSy9yQixRQUFMLENBQWMyTyxLQUFkLENBQW9CNkMsU0FBcEIsR0FBZ0MsUUFBaEM7TUFDRDtNQUVELEtBQUt4UixRQUFMLENBQWNpRCxTQUFkLENBQXdCbUIsR0FBeEIsQ0FBNEJ5bEIsaUJBQTVCO01BRUEsSUFBTW9DLHVCQUF1QixHQUFHbnhCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDLEtBQUt3dUIsT0FBM0MsQ0FBaEM7TUFDQTF3QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJvSixHQUFqQixDQUFxQnRPLElBQUksQ0FBQzFCLGNBQTFCO01BRUFjLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQm5GLEdBQWpCLENBQXFCQyxJQUFJLENBQUMxQixjQUExQixFQUEwQyxZQUFNO1FBQzlDd1EsTUFBSSxDQUFDNUosUUFBTCxDQUFjaUQsU0FBZCxDQUF3Qi9CLE1BQXhCLENBQStCMm9CLGlCQUEvQjtRQUNBLElBQUksQ0FBQ2tDLGtCQUFMLEVBQXlCO1VBQ3ZCN3hCLHFCQUFDLENBQUMwUCxNQUFJLENBQUM1SixRQUFOLENBQUQsQ0FBaUJuRixHQUFqQixDQUFxQkMsSUFBSSxDQUFDMUIsY0FBMUIsRUFBMEMsWUFBTTtZQUM5Q3dRLE1BQUksQ0FBQzVKLFFBQUwsQ0FBYzJPLEtBQWQsQ0FBb0I2QyxTQUFwQixHQUFnQyxFQUFoQztVQUNELENBRkQsRUFHR3BXLG9CQUhILENBR3dCd08sTUFBSSxDQUFDNUosUUFIN0IsRUFHdUNpc0IsdUJBSHZDO1FBSUQ7TUFDRixDQVJELEVBU0c3d0Isb0JBVEgsQ0FTd0I2d0IsdUJBVHhCO01BVUEsS0FBS2pzQixRQUFMLENBQWNvRCxLQUFkO0lBQ0Q7V0FFRG9vQixxQ0FBYXpnQixhQUFiLEVBQTRCO01BQUE7TUFDMUIsSUFBTTBnQixVQUFVLEdBQUd2eEIscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCZSxRQUFqQixDQUEwQnRCLGlCQUExQixDQUFuQjtNQUNBLElBQU15c0IsU0FBUyxHQUFHLEtBQUt0QixPQUFMLEdBQWUsS0FBS0EsT0FBTCxDQUFhMXVCLGFBQWIsQ0FBMkJvdUIsbUJBQTNCLENBQWYsR0FBaUUsSUFBbkY7TUFFQSxJQUFJLENBQUMsS0FBS3RxQixRQUFMLENBQWN4QixVQUFmLElBQ0EsS0FBS3dCLFFBQUwsQ0FBY3hCLFVBQWQsQ0FBeUJ0QixRQUF6QixLQUFzQzRWLElBQUksQ0FBQ3FaLFlBRC9DLEVBQzZEO1FBQzNEO1FBQ0F6d0IsUUFBUSxDQUFDMFYsSUFBVCxDQUFjZ2IsV0FBZCxDQUEwQixLQUFLcHNCLFFBQS9CO01BQ0Q7TUFFRCxLQUFLQSxRQUFMLENBQWMyTyxLQUFkLENBQW9CZ1osT0FBcEIsR0FBOEIsT0FBOUI7TUFDQSxLQUFLM25CLFFBQUwsQ0FBY2lkLGVBQWQsQ0FBOEIsYUFBOUI7TUFDQSxLQUFLamQsUUFBTCxDQUFjc0QsWUFBZCxDQUEyQixZQUEzQixFQUF5QyxJQUF6QztNQUNBLEtBQUt0RCxRQUFMLENBQWNzRCxZQUFkLENBQTJCLE1BQTNCLEVBQW1DLFFBQW5DO01BRUEsSUFBSXBKLHFCQUFDLENBQUMsS0FBSzB3QixPQUFOLENBQUQsQ0FBZ0I3cEIsUUFBaEIsQ0FBeUIwb0IscUJBQXpCLEtBQW1EeUMsU0FBdkQsRUFBa0U7UUFDaEVBLFNBQVMsQ0FBQ3BZLFNBQVYsR0FBc0IsQ0FBdEI7TUFDRCxDQUZELE1BRU87UUFDTCxLQUFLOVQsUUFBTCxDQUFjOFQsU0FBZCxHQUEwQixDQUExQjtNQUNEO01BRUQsSUFBSTJYLFVBQUosRUFBZ0I7UUFDZDN3QixJQUFJLENBQUM4QixNQUFMLENBQVksS0FBS29ELFFBQWpCO01BQ0Q7TUFFRDlGLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQnlMLFFBQWpCLENBQTBCL0wsaUJBQTFCO01BRUEsSUFBSSxLQUFLZ0ksT0FBTCxDQUFhdEUsS0FBakIsRUFBd0I7UUFDdEIsS0FBS2lwQixhQUFMO01BQ0Q7TUFFRCxJQUFNQyxVQUFVLEdBQUdweUIscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUW9NLGFBQVIsRUFBcUI7UUFDdENsQyxhQUFhLEVBQWJBO01BRHNDLENBQXJCLENBQW5CO01BSUEsSUFBTXdoQixrQkFBa0IsR0FBRyxTQUFyQkEsa0JBQXFCLEdBQU07UUFDL0IsSUFBSW5nQixNQUFJLENBQUMxRSxPQUFMLENBQWF0RSxLQUFqQixFQUF3QjtVQUN0QmdKLE1BQUksQ0FBQ3BNLFFBQUwsQ0FBY29ELEtBQWQ7UUFDRDtRQUVEZ0osTUFBSSxDQUFDa0IsZ0JBQUwsR0FBd0IsS0FBeEI7UUFDQXBULHFCQUFDLENBQUNrUyxNQUFJLENBQUNwTSxRQUFOLENBQUQsQ0FBaUJsRCxPQUFqQixDQUF5Qnd2QixVQUF6QjtNQUNELENBUEQ7TUFTQSxJQUFJYixVQUFKLEVBQWdCO1FBQ2QsSUFBTXB2QixrQkFBa0IsR0FBR3ZCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDLEtBQUt3dUIsT0FBM0MsQ0FBM0I7UUFFQTF3QixxQkFBQyxDQUFDLEtBQUswd0IsT0FBTixDQUFELENBQ0cvdkIsR0FESCxDQUNPQyxJQUFJLENBQUMxQixjQURaLEVBQzRCbXpCLGtCQUQ1QixFQUVHbnhCLG9CQUZILENBRXdCaUIsa0JBRnhCO01BR0QsQ0FORCxNQU1PO1FBQ0xrd0Isa0JBQWtCO01BQ25CO0lBQ0Y7V0FFREYseUNBQWdCO01BQUE7TUFDZG55QixxQkFBQyxDQUFDd0IsUUFBRCxDQUFELENBQ0cwTixHQURILENBQ08yZ0IsYUFEUDtNQUFBLENBRUdyb0IsRUFGSCxDQUVNcW9CLGFBRk4sRUFFcUIsZUFBSyxFQUFJO1FBQzFCLElBQUlydUIsUUFBUSxLQUFLekIsS0FBSyxDQUFDRSxNQUFuQixJQUNBcXlCLE1BQUksQ0FBQ3hzQixRQUFMLEtBQWtCL0YsS0FBSyxDQUFDRSxNQUR4QixJQUVBRCxxQkFBQyxDQUFDc3lCLE1BQUksQ0FBQ3hzQixRQUFOLENBQUQsQ0FBaUJ5c0IsR0FBakIsQ0FBcUJ4eUIsS0FBSyxDQUFDRSxNQUEzQixFQUFtQ2dLLE1BQW5DLEtBQThDLENBRmxELEVBRXFEO1VBQ25EcW9CLE1BQUksQ0FBQ3hzQixRQUFMLENBQWNvRCxLQUFkO1FBQ0Q7TUFDRixDQVJIO0lBU0Q7V0FFRGlvQiw2Q0FBa0I7TUFBQTtNQUNoQixJQUFJLEtBQUtQLFFBQVQsRUFBbUI7UUFDakI1d0IscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCMEIsRUFBakIsQ0FBb0J3b0IscUJBQXBCLEVBQTJDLGVBQUssRUFBSTtVQUNsRCxJQUFJd0MsTUFBSSxDQUFDaGxCLE9BQUwsQ0FBYWxCLFFBQWIsSUFBeUJ2TSxLQUFLLENBQUNvUSxLQUFOLEtBQWdCMmIsY0FBN0MsRUFBNkQ7WUFDM0QvckIsS0FBSyxDQUFDd0gsY0FBTjtZQUNBaXJCLE1BQUksQ0FBQ3ZlLElBQUw7VUFDRCxDQUhELE1BR08sSUFBSSxDQUFDdWUsTUFBSSxDQUFDaGxCLE9BQUwsQ0FBYWxCLFFBQWQsSUFBMEJ2TSxLQUFLLENBQUNvUSxLQUFOLEtBQWdCMmIsY0FBOUMsRUFBOEQ7WUFDbkUwRyxNQUFJLENBQUNiLDBCQUFMO1VBQ0Q7UUFDRixDQVBEO01BUUQsQ0FURCxNQVNPLElBQUksQ0FBQyxLQUFLZixRQUFWLEVBQW9CO1FBQ3pCNXdCLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQm9KLEdBQWpCLENBQXFCOGdCLHFCQUFyQjtNQUNEO0lBQ0Y7V0FFRG9CLDZDQUFrQjtNQUFBO01BQ2hCLElBQUksS0FBS1IsUUFBVCxFQUFtQjtRQUNqQjV3QixxQkFBQyxDQUFDMkosTUFBRCxDQUFELENBQVVuQyxFQUFWLENBQWFzb0IsWUFBYixFQUEyQixlQUFLO1VBQUEsT0FBSTJDLE1BQUksQ0FBQ2YsWUFBTCxDQUFrQjN4QixLQUFsQixDQUFKO1FBQUEsQ0FBaEM7TUFDRCxDQUZELE1BRU87UUFDTEMscUJBQUMsQ0FBQzJKLE1BQUQsQ0FBRCxDQUFVdUYsR0FBVixDQUFjNGdCLFlBQWQ7TUFDRDtJQUNGO1dBRUQwQixtQ0FBYTtNQUFBO01BQ1gsS0FBSzFyQixRQUFMLENBQWMyTyxLQUFkLENBQW9CZ1osT0FBcEIsR0FBOEIsTUFBOUI7TUFDQSxLQUFLM25CLFFBQUwsQ0FBY3NELFlBQWQsQ0FBMkIsYUFBM0IsRUFBMEMsSUFBMUM7TUFDQSxLQUFLdEQsUUFBTCxDQUFjaWQsZUFBZCxDQUE4QixZQUE5QjtNQUNBLEtBQUtqZCxRQUFMLENBQWNpZCxlQUFkLENBQThCLE1BQTlCO01BQ0EsS0FBSzNQLGdCQUFMLEdBQXdCLEtBQXhCO01BQ0EsS0FBS2llLGFBQUwsQ0FBbUIsWUFBTTtRQUN2QnJ4QixxQkFBQyxDQUFDd0IsUUFBUSxDQUFDMFYsSUFBVixDQUFELENBQWlCdFEsV0FBakIsQ0FBNkI4b0IsZUFBN0I7UUFDQWdELE1BQUksQ0FBQ0MsaUJBQUw7UUFDQUQsTUFBSSxDQUFDRSxlQUFMO1FBQ0E1eUIscUJBQUMsQ0FBQzB5QixNQUFJLENBQUM1c0IsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJxUSxjQUF6QjtNQUNELENBTEQ7SUFNRDtXQUVENGYsNkNBQWtCO01BQ2hCLElBQUksS0FBS2xDLFNBQVQsRUFBb0I7UUFDbEIzd0IscUJBQUMsQ0FBQyxLQUFLMndCLFNBQU4sQ0FBRCxDQUFrQjNwQixNQUFsQjtRQUNBLEtBQUsycEIsU0FBTCxHQUFpQixJQUFqQjtNQUNEO0lBQ0Y7V0FFRFUsdUNBQWMvTixRQUFkLEVBQXdCO01BQUE7TUFDdEIsSUFBTXdQLE9BQU8sR0FBRzl5QixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJlLFFBQWpCLENBQTBCdEIsaUJBQTFCLElBQ2RBLGlCQURjLEdBQ0ksRUFEcEI7TUFHQSxJQUFJLEtBQUtxckIsUUFBTCxJQUFpQixLQUFLcGpCLE9BQUwsQ0FBYWdqQixRQUFsQyxFQUE0QztRQUMxQyxLQUFLRyxTQUFMLEdBQWlCbnZCLFFBQVEsQ0FBQ3V4QixhQUFULENBQXVCLEtBQXZCLENBQWpCO1FBQ0EsS0FBS3BDLFNBQUwsQ0FBZXFDLFNBQWYsR0FBMkJ2RCxtQkFBM0I7UUFFQSxJQUFJcUQsT0FBSixFQUFhO1VBQ1gsS0FBS25DLFNBQUwsQ0FBZTVuQixTQUFmLENBQXlCbUIsR0FBekIsQ0FBNkI0b0IsT0FBN0I7UUFDRDtRQUVEOXlCLHFCQUFDLENBQUMsS0FBSzJ3QixTQUFOLENBQUQsQ0FBa0JzQyxRQUFsQixDQUEyQnp4QixRQUFRLENBQUMwVixJQUFwQztRQUVBbFgscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCMEIsRUFBakIsQ0FBb0J1b0IscUJBQXBCLEVBQXlDLGVBQUssRUFBSTtVQUNoRCxJQUFJbUQsTUFBSSxDQUFDcEMsb0JBQVQsRUFBK0I7WUFDN0JvQyxNQUFJLENBQUNwQyxvQkFBTCxHQUE0QixLQUE1QjtZQUNBO1VBQ0Q7VUFFRCxJQUFJL3dCLEtBQUssQ0FBQ0UsTUFBTixLQUFpQkYsS0FBSyxDQUFDd1YsYUFBM0IsRUFBMEM7WUFDeEM7VUFDRDtVQUVELElBQUkyZCxNQUFJLENBQUMxbEIsT0FBTCxDQUFhZ2pCLFFBQWIsS0FBMEIsUUFBOUIsRUFBd0M7WUFDdEMwQyxNQUFJLENBQUN2QiwwQkFBTDtVQUNELENBRkQsTUFFTztZQUNMdUIsTUFBSSxDQUFDamYsSUFBTDtVQUNEO1FBQ0YsQ0FmRDtRQWlCQSxJQUFJNmUsT0FBSixFQUFhO1VBQ1hseUIsSUFBSSxDQUFDOEIsTUFBTCxDQUFZLEtBQUtpdUIsU0FBakI7UUFDRDtRQUVEM3dCLHFCQUFDLENBQUMsS0FBSzJ3QixTQUFOLENBQUQsQ0FBa0JwZixRQUFsQixDQUEyQi9MLGlCQUEzQjtRQUVBLElBQUksQ0FBQzhkLFFBQUwsRUFBZTtVQUNiO1FBQ0Q7UUFFRCxJQUFJLENBQUN3UCxPQUFMLEVBQWM7VUFDWnhQLFFBQVE7VUFDUjtRQUNEO1FBRUQsSUFBTTZQLDBCQUEwQixHQUFHdnlCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDLEtBQUt5dUIsU0FBM0MsQ0FBbkM7UUFFQTN3QixxQkFBQyxDQUFDLEtBQUsyd0IsU0FBTixDQUFELENBQ0dod0IsR0FESCxDQUNPQyxJQUFJLENBQUMxQixjQURaLEVBQzRCb2tCLFFBRDVCLEVBRUdwaUIsb0JBRkgsQ0FFd0JpeUIsMEJBRnhCO01BR0QsQ0EvQ0QsTUErQ08sSUFBSSxDQUFDLEtBQUt2QyxRQUFOLElBQWtCLEtBQUtELFNBQTNCLEVBQXNDO1FBQzNDM3dCLHFCQUFDLENBQUMsS0FBSzJ3QixTQUFOLENBQUQsQ0FBa0IvcEIsV0FBbEIsQ0FBOEJwQixpQkFBOUI7UUFFQSxJQUFNNHRCLGNBQWMsR0FBRyxTQUFqQkEsY0FBaUIsR0FBTTtVQUMzQkYsTUFBSSxDQUFDTCxlQUFMO1VBQ0EsSUFBSXZQLFFBQUosRUFBYztZQUNaQSxRQUFRO1VBQ1Q7UUFDRixDQUxEO1FBT0EsSUFBSXRqQixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJlLFFBQWpCLENBQTBCdEIsaUJBQTFCLENBQUosRUFBZ0Q7VUFDOUMsSUFBTTR0QiwyQkFBMEIsR0FBR3Z5QixJQUFJLENBQUNzQixnQ0FBTCxDQUFzQyxLQUFLeXVCLFNBQTNDLENBQW5DO1VBRUEzd0IscUJBQUMsQ0FBQyxLQUFLMndCLFNBQU4sQ0FBRCxDQUNHaHdCLEdBREgsQ0FDT0MsSUFBSSxDQUFDMUIsY0FEWixFQUM0QmswQixjQUQ1QixFQUVHbHlCLG9CQUZILENBRXdCaXlCLDJCQUZ4QjtRQUdELENBTkQsTUFNTztVQUNMQyxjQUFjO1FBQ2Y7TUFDRixDQW5CTSxNQW1CQSxJQUFJOVAsUUFBSixFQUFjO1FBQ25CQSxRQUFRO01BQ1Q7SUFDRjtJQUdEO0lBQ0E7SUFDQTtJQUFBOztXQUVBNE4seUNBQWdCO01BQ2QsSUFBTVcsa0JBQWtCLEdBQUcsS0FBSy9yQixRQUFMLENBQWNnc0IsWUFBZCxHQUE2QnR3QixRQUFRLENBQUN5QyxlQUFULENBQXlCa1ksWUFBakY7TUFFQSxJQUFJLENBQUMsS0FBSzBVLGtCQUFOLElBQTRCZ0Isa0JBQWhDLEVBQW9EO1FBQ2xELEtBQUsvckIsUUFBTCxDQUFjMk8sS0FBZCxDQUFvQjRlLFdBQXBCLEdBQXFDLEtBQUt0QyxlQUExQztNQUNEO01BRUQsSUFBSSxLQUFLRixrQkFBTCxJQUEyQixDQUFDZ0Isa0JBQWhDLEVBQW9EO1FBQ2xELEtBQUsvckIsUUFBTCxDQUFjMk8sS0FBZCxDQUFvQjZlLFlBQXBCLEdBQXNDLEtBQUt2QyxlQUEzQztNQUNEO0lBQ0Y7V0FFRDRCLGlEQUFvQjtNQUNsQixLQUFLN3NCLFFBQUwsQ0FBYzJPLEtBQWQsQ0FBb0I0ZSxXQUFwQixHQUFrQyxFQUFsQztNQUNBLEtBQUt2dEIsUUFBTCxDQUFjMk8sS0FBZCxDQUFvQjZlLFlBQXBCLEdBQW1DLEVBQW5DO0lBQ0Q7V0FFRHRDLDZDQUFrQjtNQUNoQixJQUFNdFgsSUFBSSxHQUFHbFksUUFBUSxDQUFDMFYsSUFBVCxDQUFjbkMscUJBQWQsRUFBYjtNQUNBLEtBQUs4YixrQkFBTCxHQUEwQnZ2QixJQUFJLENBQUM0akIsS0FBTCxDQUFXeEwsSUFBSSxDQUFDTyxJQUFMLEdBQVlQLElBQUksQ0FBQ1EsS0FBNUIsSUFBcUN2USxNQUFNLENBQUN5VCxVQUF0RTtNQUNBLEtBQUsyVCxlQUFMLEdBQXVCLEtBQUt3QyxrQkFBTCxFQUF2QjtJQUNEO1dBRUR0Qyx5Q0FBZ0I7TUFBQTtNQUNkLElBQUksS0FBS0osa0JBQVQsRUFBNkI7UUFDM0I7UUFDQTtRQUNBLElBQU0yQyxZQUFZLEdBQUcsR0FBRzNwQixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQndtQixzQkFBMUIsQ0FBZCxDQUFyQjtRQUNBLElBQU1tRCxhQUFhLEdBQUcsR0FBRzVwQixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQnltQix1QkFBMUIsQ0FBZCxDQUF0QixDQUoyQjs7UUFPM0J2d0IscUJBQUMsQ0FBQ3d6QixZQUFELENBQUQsQ0FBZ0J0c0IsSUFBaEIsQ0FBcUIsVUFBQzRILEtBQUQsRUFBUW5OLE9BQVIsRUFBb0I7VUFDdkMsSUFBTSt4QixhQUFhLEdBQUcveEIsT0FBTyxDQUFDOFMsS0FBUixDQUFjNmUsWUFBcEM7VUFDQSxJQUFNSyxpQkFBaUIsR0FBRzN6QixxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVdTLEdBQVgsQ0FBZSxlQUFmLENBQTFCO1VBQ0FwQyxxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQ0d5RixJQURILENBQ1EsZUFEUixFQUN5QnNzQixhQUR6QixFQUVHdHhCLEdBRkgsQ0FFTyxlQUZQLEVBRTJCRyxVQUFVLENBQUNveEIsaUJBQUQsQ0FBVixHQUFnQ0MsT0FBSSxDQUFDN0MsZUFGaEU7UUFHRCxDQU5ELEVBUDJCOztRQWdCM0Ivd0IscUJBQUMsQ0FBQ3l6QixhQUFELENBQUQsQ0FBaUJ2c0IsSUFBakIsQ0FBc0IsVUFBQzRILEtBQUQsRUFBUW5OLE9BQVIsRUFBb0I7VUFDeEMsSUFBTWt5QixZQUFZLEdBQUdseUIsT0FBTyxDQUFDOFMsS0FBUixDQUFja0wsV0FBbkM7VUFDQSxJQUFNbVUsZ0JBQWdCLEdBQUc5ekIscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXUyxHQUFYLENBQWUsY0FBZixDQUF6QjtVQUNBcEMscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUNHeUYsSUFESCxDQUNRLGNBRFIsRUFDd0J5c0IsWUFEeEIsRUFFR3p4QixHQUZILENBRU8sY0FGUCxFQUUwQkcsVUFBVSxDQUFDdXhCLGdCQUFELENBQVYsR0FBK0JGLE9BQUksQ0FBQzdDLGVBRjlEO1FBR0QsQ0FORCxFQWhCMkI7O1FBeUIzQixJQUFNMkMsYUFBYSxHQUFHbHlCLFFBQVEsQ0FBQzBWLElBQVQsQ0FBY3pDLEtBQWQsQ0FBb0I2ZSxZQUExQztRQUNBLElBQU1LLGlCQUFpQixHQUFHM3pCLHFCQUFDLENBQUN3QixRQUFRLENBQUMwVixJQUFWLENBQUQsQ0FBaUI5VSxHQUFqQixDQUFxQixlQUFyQixDQUExQjtRQUNBcEMscUJBQUMsQ0FBQ3dCLFFBQVEsQ0FBQzBWLElBQVYsQ0FBRCxDQUNHOVAsSUFESCxDQUNRLGVBRFIsRUFDeUJzc0IsYUFEekIsRUFFR3R4QixHQUZILENBRU8sZUFGUCxFQUUyQkcsVUFBVSxDQUFDb3hCLGlCQUFELENBQVYsR0FBZ0MsS0FBSzVDLGVBRmhFO01BR0Q7TUFFRC93QixxQkFBQyxDQUFDd0IsUUFBUSxDQUFDMFYsSUFBVixDQUFELENBQWlCM0YsUUFBakIsQ0FBMEJtZSxlQUExQjtJQUNEO1dBRURrRCw2Q0FBa0I7TUFDaEI7TUFDQSxJQUFNWSxZQUFZLEdBQUcsR0FBRzNwQixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQndtQixzQkFBMUIsQ0FBZCxDQUFyQjtNQUNBdHdCLHFCQUFDLENBQUN3ekIsWUFBRCxDQUFELENBQWdCdHNCLElBQWhCLENBQXFCLFVBQUM0SCxLQUFELEVBQVFuTixPQUFSLEVBQW9CO1FBQ3ZDLElBQU1rYyxPQUFPLEdBQUc3ZCxxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVd5RixJQUFYLENBQWdCLGVBQWhCLENBQWhCO1FBQ0FwSCxxQkFBQyxDQUFDMkIsT0FBRCxDQUFELENBQVc0RSxVQUFYLENBQXNCLGVBQXRCO1FBQ0E1RSxPQUFPLENBQUM4UyxLQUFSLENBQWM2ZSxZQUFkLEdBQTZCelYsT0FBTyxHQUFHQSxPQUFILEdBQWEsRUFBakQ7TUFDRCxDQUpELEVBSGdCOztNQVVoQixJQUFNa1csUUFBUSxHQUFHLEdBQUdscUIsS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsTUFBNkJ5bUIsdUJBQTdCLENBQWQsQ0FBakI7TUFDQXZ3QixxQkFBQyxDQUFDK3pCLFFBQUQsQ0FBRCxDQUFZN3NCLElBQVosQ0FBaUIsVUFBQzRILEtBQUQsRUFBUW5OLE9BQVIsRUFBb0I7UUFDbkMsSUFBTXF5QixNQUFNLEdBQUdoMEIscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXeUYsSUFBWCxDQUFnQixjQUFoQixDQUFmO1FBQ0EsSUFBSSxPQUFPNHNCLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7VUFDakNoMEIscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXUyxHQUFYLENBQWUsY0FBZixFQUErQjR4QixNQUEvQixFQUF1Q3p0QixVQUF2QyxDQUFrRCxjQUFsRDtRQUNEO01BQ0YsQ0FMRCxFQVhnQjs7TUFtQmhCLElBQU1zWCxPQUFPLEdBQUc3ZCxxQkFBQyxDQUFDd0IsUUFBUSxDQUFDMFYsSUFBVixDQUFELENBQWlCOVAsSUFBakIsQ0FBc0IsZUFBdEIsQ0FBaEI7TUFDQXBILHFCQUFDLENBQUN3QixRQUFRLENBQUMwVixJQUFWLENBQUQsQ0FBaUIzUSxVQUFqQixDQUE0QixlQUE1QjtNQUNBL0UsUUFBUSxDQUFDMFYsSUFBVCxDQUFjekMsS0FBZCxDQUFvQjZlLFlBQXBCLEdBQW1DelYsT0FBTyxHQUFHQSxPQUFILEdBQWEsRUFBdkQ7SUFDRDtXQUVEMFYsbURBQXFCO01BQUU7TUFDckIsSUFBTVUsU0FBUyxHQUFHenlCLFFBQVEsQ0FBQ3V4QixhQUFULENBQXVCLEtBQXZCLENBQWxCO01BQ0FrQixTQUFTLENBQUNqQixTQUFWLEdBQXNCeEQsNkJBQXRCO01BQ0FodUIsUUFBUSxDQUFDMFYsSUFBVCxDQUFjZ2IsV0FBZCxDQUEwQitCLFNBQTFCO01BQ0EsSUFBTUMsY0FBYyxHQUFHRCxTQUFTLENBQUNsZixxQkFBVixHQUFrQzhGLEtBQWxDLEdBQTBDb1osU0FBUyxDQUFDL1gsV0FBM0U7TUFDQTFhLFFBQVEsQ0FBQzBWLElBQVQsQ0FBY2lNLFdBQWQsQ0FBMEI4USxTQUExQjtNQUNBLE9BQU9DLGNBQVA7SUFDRDtJQUFBOztVQUdNanRCLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDME4sYUFBaEMsRUFBK0M7TUFDN0MsT0FBTyxLQUFLM0osSUFBTCxDQUFVLFlBQVk7UUFDM0IsSUFBSUUsSUFBSSxHQUFHcEgscUJBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUW9ILElBQVIsQ0FBYWxDLFVBQWIsQ0FBWDtRQUNBLElBQU1zSSxPQUFPLGtCQUNScEIsU0FEUSxFQUVScE0scUJBQUMsQ0FBQyxJQUFELENBQUQsQ0FBUW9ILElBQVIsRUFGUSxFQUdQLFFBQU9qRSxNQUFQLE1BQWtCLFFBQWxCLElBQThCQSxNQUE5QixHQUF1Q0EsTUFBdkMsR0FBZ0QsRUFIekMsQ0FBYjtRQU1BLElBQUksQ0FBQ2lFLElBQUwsRUFBVztVQUNUQSxJQUFJLEdBQUcsSUFBSXFwQixLQUFKLENBQVUsSUFBVixFQUFnQmpqQixPQUFoQixDQUFQO1VBQ0F4TixxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRb0gsSUFBUixDQUFhbEMsVUFBYixFQUF1QmtDLElBQXZCO1FBQ0Q7UUFFRCxJQUFJLE9BQU9qRSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO1VBQzlCLElBQUksT0FBT2lFLElBQUksQ0FBQ2pFLE1BQUQsQ0FBWCxLQUF3QixXQUE1QixFQUF5QztZQUN2QyxNQUFNLElBQUlxQixTQUFKLHdCQUFrQ3JCLE1BQWxDLFFBQU47VUFDRDtVQUVEaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFKLENBQWEwTixhQUFiO1FBQ0QsQ0FORCxNQU1PLElBQUlyRCxPQUFPLENBQUMwRyxJQUFaLEVBQWtCO1VBQ3ZCOU0sSUFBSSxDQUFDOE0sSUFBTCxDQUFVckQsYUFBVjtRQUNEO01BQ0YsQ0F0Qk0sQ0FBUDtJQXVCRDs7O1dBbGVELGVBQXFCO1FBQ25CLE9BQU81TCxTQUFQO01BQ0Q7OztXQUVELGVBQXFCO1FBQ25CLE9BQU9tSCxTQUFQO01BQ0Q7Ozs7RUErZEg7Ozs7RUFJQXBNLHFCQUFDLENBQUN3QixRQUFELENBQUQsQ0FBWWdHLEVBQVosQ0FBZTdCLHNCQUFmLEVBQXFDdUMsc0JBQXJDLEVBQTJELFVBQVVuSSxLQUFWLEVBQWlCO0lBQUE7SUFDMUUsSUFBSUUsTUFBSjtJQUNBLElBQU0yQixRQUFRLEdBQUdoQixJQUFJLENBQUNjLHNCQUFMLENBQTRCLElBQTVCLENBQWpCO0lBRUEsSUFBSUUsUUFBSixFQUFjO01BQ1ozQixNQUFNLEdBQUd1QixRQUFRLENBQUNRLGFBQVQsQ0FBdUJKLFFBQXZCLENBQVQ7SUFDRDtJQUVELElBQU11QixNQUFNLEdBQUduRCxxQkFBQyxDQUFDQyxNQUFELENBQUQsQ0FBVW1ILElBQVYsQ0FBZWxDLFVBQWYsSUFDYixRQURhLGtCQUVSbEYscUJBQUMsQ0FBQ0MsTUFBRCxDQUFELENBQVVtSCxJQUFWLEVBRlEsRUFHUnBILHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLEVBSFEsQ0FBZjtJQU1BLElBQUksS0FBS3NDLE9BQUwsS0FBaUIsR0FBakIsSUFBd0IsS0FBS0EsT0FBTCxLQUFpQixNQUE3QyxFQUFxRDtNQUNuRDNKLEtBQUssQ0FBQ3dILGNBQU47SUFDRDtJQUVELElBQU1tTyxPQUFPLEdBQUcxVixxQkFBQyxDQUFDQyxNQUFELENBQUQsQ0FBVVUsR0FBVixDQUFjbVMsWUFBZCxFQUEwQixtQkFBUyxFQUFJO01BQ3JELElBQUl1YixTQUFTLENBQUNqb0Isa0JBQVYsRUFBSixFQUFvQztRQUNsQztRQUNBO01BQ0Q7TUFFRHNQLE9BQU8sQ0FBQy9VLEdBQVIsQ0FBWXNTLGNBQVosRUFBMEIsWUFBTTtRQUM5QixJQUFJalQscUJBQUMsQ0FBQ20wQixPQUFELENBQUQsQ0FBUWowQixFQUFSLENBQVcsVUFBWCxDQUFKLEVBQTRCO1VBQzFCaTBCLE9BQUksQ0FBQ2pyQixLQUFMO1FBQ0Q7TUFDRixDQUpEO0lBS0QsQ0FYZSxDQUFoQjtJQWFBdW5CLEtBQUssQ0FBQ3hwQixnQkFBTixDQUF1QnpILElBQXZCLENBQTRCUSxxQkFBQyxDQUFDQyxNQUFELENBQTdCLEVBQXVDa0QsTUFBdkMsRUFBK0MsSUFBL0M7RUFDRCxDQWhDRDtFQWtDQTs7OztFQUlBbkQscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYXlyQixLQUFLLENBQUN4cEIsZ0JBQW5CO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5QmdwQixLQUF6QjtFQUNBendCLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU9vckIsS0FBSyxDQUFDeHBCLGdCQUFiO0VBQ0QsQ0FIRDs7RUNubUJBOzs7Ozs7RUFPQSxJQUFNbXRCLFFBQVEsR0FBRyxDQUNmLFlBRGUsRUFFZixNQUZlLEVBR2YsTUFIZSxFQUlmLFVBSmUsRUFLZixVQUxlLEVBTWYsUUFOZSxFQU9mLEtBUGUsRUFRZixZQVJlLENBQWpCO0VBV0EsSUFBTUMsc0JBQXNCLEdBQUcsZ0JBQS9CO0VBRU8sSUFBTUMsZ0JBQWdCLEdBQUc7SUFDOUI7SUFDQSxLQUFLLENBQUMsT0FBRCxFQUFVLEtBQVYsRUFBaUIsSUFBakIsRUFBdUIsTUFBdkIsRUFBK0IsTUFBL0IsRUFBdUNELHNCQUF2QyxDQUZ5QjtJQUc5QnZWLENBQUMsRUFBRSxDQUFDLFFBQUQsRUFBVyxNQUFYLEVBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLENBSDJCO0lBSTlCRixJQUFJLEVBQUUsRUFKd0I7SUFLOUJHLENBQUMsRUFBRSxFQUwyQjtJQU05QndWLEVBQUUsRUFBRSxFQU4wQjtJQU85QkMsR0FBRyxFQUFFLEVBUHlCO0lBUTlCQyxJQUFJLEVBQUUsRUFSd0I7SUFTOUJDLEdBQUcsRUFBRSxFQVR5QjtJQVU5QkMsRUFBRSxFQUFFLEVBVjBCO0lBVzlCQyxFQUFFLEVBQUUsRUFYMEI7SUFZOUJDLEVBQUUsRUFBRSxFQVowQjtJQWE5QkMsRUFBRSxFQUFFLEVBYjBCO0lBYzlCQyxFQUFFLEVBQUUsRUFkMEI7SUFlOUJDLEVBQUUsRUFBRSxFQWYwQjtJQWdCOUJDLEVBQUUsRUFBRSxFQWhCMEI7SUFpQjlCQyxFQUFFLEVBQUUsRUFqQjBCO0lBa0I5Qm5yQixDQUFDLEVBQUUsRUFsQjJCO0lBbUI5Qm9yQixHQUFHLEVBQUUsQ0FBQyxLQUFELEVBQVEsUUFBUixFQUFrQixLQUFsQixFQUF5QixPQUF6QixFQUFrQyxPQUFsQyxFQUEyQyxRQUEzQyxDQW5CeUI7SUFvQjlCQyxFQUFFLEVBQUUsRUFwQjBCO0lBcUI5QkMsRUFBRSxFQUFFLEVBckIwQjtJQXNCOUJDLENBQUMsRUFBRSxFQXRCMkI7SUF1QjlCQyxHQUFHLEVBQUUsRUF2QnlCO0lBd0I5QkMsQ0FBQyxFQUFFLEVBeEIyQjtJQXlCOUJDLEtBQUssRUFBRSxFQXpCdUI7SUEwQjlCQyxJQUFJLEVBQUUsRUExQndCO0lBMkI5QkMsR0FBRyxFQUFFLEVBM0J5QjtJQTRCOUJDLEdBQUcsRUFBRSxFQTVCeUI7SUE2QjlCQyxNQUFNLEVBQUUsRUE3QnNCO0lBOEI5QkMsQ0FBQyxFQUFFLEVBOUIyQjtJQStCOUJDLEVBQUUsRUFBRTtFQS9CMEIsQ0FBekI7RUFrQ1A7Ozs7OztFQUtBLElBQU1DLGdCQUFnQixHQUFHLGdFQUF6QjtFQUVBOzs7Ozs7RUFLQSxJQUFNQyxnQkFBZ0IsR0FBRyxvSUFBekI7RUFFQSxTQUFTQyxnQkFBVCxDQUEwQnhoQixJQUExQixFQUFnQ3loQixvQkFBaEMsRUFBc0Q7SUFDcEQsSUFBTUMsUUFBUSxHQUFHMWhCLElBQUksQ0FBQ3FDLFFBQUwsQ0FBY3JYLFdBQWQsRUFBakI7SUFFQSxJQUFJeTJCLG9CQUFvQixDQUFDL2xCLE9BQXJCLENBQTZCZ21CLFFBQTdCLE1BQTJDLENBQUMsQ0FBaEQsRUFBbUQ7TUFDakQsSUFBSWhDLFFBQVEsQ0FBQ2hrQixPQUFULENBQWlCZ21CLFFBQWpCLE1BQStCLENBQUMsQ0FBcEMsRUFBdUM7UUFDckMsT0FBT3R6QixPQUFPLENBQUNrekIsZ0JBQWdCLENBQUNueUIsSUFBakIsQ0FBc0I2USxJQUFJLENBQUMyaEIsU0FBM0IsS0FBeUNKLGdCQUFnQixDQUFDcHlCLElBQWpCLENBQXNCNlEsSUFBSSxDQUFDMmhCLFNBQTNCLENBQTFDLENBQWQ7TUFDRDtNQUVELE9BQU8sSUFBUDtJQUNEO0lBRUQsSUFBTUMsTUFBTSxHQUFHSCxvQkFBb0IsQ0FBQ3ppQixNQUFyQixDQUE0QixtQkFBUztNQUFBLE9BQUk2aUIsU0FBUyxZQUFZM3lCLE1BQXpCO0lBQUEsQ0FBckMsQ0FBZixDQVhvRDs7SUFjcEQsS0FBSyxJQUFJbUcsQ0FBQyxHQUFHLENBQVIsRUFBV0MsR0FBRyxHQUFHc3NCLE1BQU0sQ0FBQ3JzQixNQUE3QixFQUFxQ0YsQ0FBQyxHQUFHQyxHQUF6QyxFQUE4Q0QsQ0FBQyxFQUEvQyxFQUFtRDtNQUNqRCxJQUFJdXNCLE1BQU0sQ0FBQ3ZzQixDQUFELENBQU4sQ0FBVWxHLElBQVYsQ0FBZXV5QixRQUFmLENBQUosRUFBOEI7UUFDNUIsT0FBTyxJQUFQO01BQ0Q7SUFDRjtJQUVELE9BQU8sS0FBUDtFQUNEO0VBRU0sU0FBU0ksWUFBVCxDQUFzQkMsVUFBdEIsRUFBa0NDLFNBQWxDLEVBQTZDQyxVQUE3QyxFQUF5RDtJQUM5RCxJQUFJRixVQUFVLENBQUN4c0IsTUFBWCxLQUFzQixDQUExQixFQUE2QjtNQUMzQixPQUFPd3NCLFVBQVA7SUFDRDtJQUVELElBQUlFLFVBQVUsSUFBSSxPQUFPQSxVQUFQLEtBQXNCLFVBQXhDLEVBQW9EO01BQ2xELE9BQU9BLFVBQVUsQ0FBQ0YsVUFBRCxDQUFqQjtJQUNEO0lBRUQsSUFBTUcsU0FBUyxHQUFHLElBQUlqdEIsTUFBTSxDQUFDa3RCLFNBQVgsRUFBbEI7SUFDQSxJQUFNQyxlQUFlLEdBQUdGLFNBQVMsQ0FBQ0csZUFBVixDQUEwQk4sVUFBMUIsRUFBc0MsV0FBdEMsQ0FBeEI7SUFDQSxJQUFNTyxhQUFhLEdBQUcxekIsTUFBTSxDQUFDb2IsSUFBUCxDQUFZZ1ksU0FBWixDQUF0QjtJQUNBLElBQU0zQyxRQUFRLEdBQUcsR0FBR2xxQixLQUFILENBQVNySyxJQUFULENBQWNzM0IsZUFBZSxDQUFDNWYsSUFBaEIsQ0FBcUJwTixnQkFBckIsQ0FBc0MsR0FBdEMsQ0FBZCxDQUFqQjtJQVo4RCwyQkFjckRDLENBZHFELEVBYzlDQyxHQWQ4QztNQWU1RCxJQUFNMFQsRUFBRSxHQUFHcVcsUUFBUSxDQUFDaHFCLENBQUQsQ0FBbkI7TUFDQSxJQUFNa3RCLE1BQU0sR0FBR3ZaLEVBQUUsQ0FBQzNHLFFBQUgsQ0FBWXJYLFdBQVosRUFBZjtNQUVBLElBQUlzM0IsYUFBYSxDQUFDNW1CLE9BQWQsQ0FBc0JzTixFQUFFLENBQUMzRyxRQUFILENBQVlyWCxXQUFaLEVBQXRCLE1BQXFELENBQUMsQ0FBMUQsRUFBNkQ7UUFDM0RnZSxFQUFFLENBQUNwWixVQUFILENBQWM2ZSxXQUFkLENBQTBCekYsRUFBMUI7UUFFQTtNQUNEO01BRUQsSUFBTXdaLGFBQWEsR0FBRyxHQUFHcnRCLEtBQUgsQ0FBU3JLLElBQVQsQ0FBY2tlLEVBQUUsQ0FBQ2lFLFVBQWpCLENBQXRCLENBeEI0RDs7TUEwQjVELElBQU13VixxQkFBcUIsR0FBRyxHQUFHclAsTUFBSCxDQUFVNE8sU0FBUyxDQUFDLEdBQUQsQ0FBVCxJQUFrQixFQUE1QixFQUFnQ0EsU0FBUyxDQUFDTyxNQUFELENBQVQsSUFBcUIsRUFBckQsQ0FBOUI7TUFFQUMsYUFBYSxDQUFDOVYsT0FBZCxDQUFzQixjQUFJLEVBQUk7UUFDNUIsSUFBSSxDQUFDOFUsZ0JBQWdCLENBQUN4aEIsSUFBRCxFQUFPeWlCLHFCQUFQLENBQXJCLEVBQW9EO1VBQ2xEelosRUFBRSxDQUFDcUYsZUFBSCxDQUFtQnJPLElBQUksQ0FBQ3FDLFFBQXhCO1FBQ0Q7TUFDRixDQUpEO0lBNUI0RDtJQWM5RCxLQUFLLElBQUloTixDQUFDLEdBQUcsQ0FBUixFQUFXQyxHQUFHLEdBQUcrcEIsUUFBUSxDQUFDOXBCLE1BQS9CLEVBQXVDRixDQUFDLEdBQUdDLEdBQTNDLEVBQWdERCxDQUFDLEVBQWpELEVBQXFEO01BQUEsaUJBQTVDQSxDQUE0QztNQUFBLHlCQU9qRDtJQVlIO0lBRUQsT0FBTytzQixlQUFlLENBQUM1ZixJQUFoQixDQUFxQmtnQixTQUE1QjtFQUNEOztFQ25IRDs7OztFQUlBLElBQU1weUIsTUFBSSxHQUFHLFNBQWI7RUFDQSxJQUFNQyxTQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyxVQUFRLEdBQUcsWUFBakI7RUFDQSxJQUFNQyxXQUFTLFNBQU9ELFVBQXRCO0VBQ0EsSUFBTUcsb0JBQWtCLEdBQUdyRixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxDQUEzQjtFQUNBLElBQU1xeUIsY0FBWSxHQUFHLFlBQXJCO0VBQ0EsSUFBTUMsb0JBQWtCLEdBQUcsSUFBSTF6QixNQUFKLGFBQXFCeXpCLGNBQXJCLFdBQXlDLEdBQXpDLENBQTNCO0VBQ0EsSUFBTUUscUJBQXFCLEdBQUcsQ0FBQyxVQUFELEVBQWEsV0FBYixFQUEwQixZQUExQixDQUE5QjtFQUVBLElBQU1oeUIsaUJBQWUsR0FBRyxNQUF4QjtFQUNBLElBQU1DLGlCQUFlLEdBQUcsTUFBeEI7RUFFQSxJQUFNZ3lCLGdCQUFnQixHQUFHLE1BQXpCO0VBQ0EsSUFBTUMsZUFBZSxHQUFHLEtBQXhCO0VBRUEsSUFBTUMsc0JBQXNCLEdBQUcsZ0JBQS9CO0VBQ0EsSUFBTUMsY0FBYyxHQUFHLFFBQXZCO0VBRUEsSUFBTUMsYUFBYSxHQUFHLE9BQXRCO0VBQ0EsSUFBTUMsYUFBYSxHQUFHLE9BQXRCO0VBQ0EsSUFBTUMsYUFBYSxHQUFHLE9BQXRCO0VBQ0EsSUFBTUMsY0FBYyxHQUFHLFFBQXZCO0VBRUEsSUFBTUMsYUFBYSxHQUFHO0lBQ3BCQyxJQUFJLEVBQUUsTUFEYztJQUVwQkMsR0FBRyxFQUFFLEtBRmU7SUFHcEJDLEtBQUssRUFBRSxPQUhhO0lBSXBCQyxNQUFNLEVBQUUsUUFKWTtJQUtwQkMsSUFBSSxFQUFFO0VBTGMsQ0FBdEI7RUFRQSxJQUFNanNCLFNBQU8sR0FBRztJQUNka3NCLFNBQVMsRUFBRSxJQURHO0lBRWRDLFFBQVEsRUFBRSx5Q0FDUSwyQkFEUixHQUVRLHlDQUpKO0lBS2QzMUIsT0FBTyxFQUFFLGFBTEs7SUFNZDQxQixLQUFLLEVBQUUsRUFOTztJQU9kQyxLQUFLLEVBQUUsQ0FQTztJQVFkbGYsSUFBSSxFQUFFLEtBUlE7SUFTZDNYLFFBQVEsRUFBRSxLQVRJO0lBVWQwYyxTQUFTLEVBQUUsS0FWRztJQVdkaEIsTUFBTSxFQUFFLENBWE07SUFZZG9iLFNBQVMsRUFBRSxLQVpHO0lBYWRDLGlCQUFpQixFQUFFLE1BYkw7SUFjZG5MLFFBQVEsRUFBRSxjQWRJO0lBZWRvTCxXQUFXLEVBQUUsRUFmQztJQWdCZEMsUUFBUSxFQUFFLElBaEJJO0lBaUJkbEMsVUFBVSxFQUFFLElBakJFO0lBa0JkRCxTQUFTLEVBQUVwQyxnQkFsQkc7SUFtQmQ1RyxZQUFZLEVBQUU7RUFuQkEsQ0FBaEI7RUFzQkEsSUFBTS9nQixhQUFXLEdBQUc7SUFDbEIyckIsU0FBUyxFQUFFLFNBRE87SUFFbEJDLFFBQVEsRUFBRSxRQUZRO0lBR2xCQyxLQUFLLEVBQUUsMkJBSFc7SUFJbEI1MUIsT0FBTyxFQUFFLFFBSlM7SUFLbEI2MUIsS0FBSyxFQUFFLGlCQUxXO0lBTWxCbGYsSUFBSSxFQUFFLFNBTlk7SUFPbEIzWCxRQUFRLEVBQUUsa0JBUFE7SUFRbEIwYyxTQUFTLEVBQUUsbUJBUk87SUFTbEJoQixNQUFNLEVBQUUsMEJBVFU7SUFVbEJvYixTQUFTLEVBQUUsMEJBVk87SUFXbEJDLGlCQUFpQixFQUFFLGdCQVhEO0lBWWxCbkwsUUFBUSxFQUFFLGtCQVpRO0lBYWxCb0wsV0FBVyxFQUFFLG1CQWJLO0lBY2xCQyxRQUFRLEVBQUUsU0FkUTtJQWVsQmxDLFVBQVUsRUFBRSxpQkFmTTtJQWdCbEJELFNBQVMsRUFBRSxRQWhCTztJQWlCbEJoSixZQUFZLEVBQUU7RUFqQkksQ0FBcEI7RUFvQkEsSUFBTS9tQixPQUFLLEdBQUc7SUFDWm15QixJQUFJLFdBQVMzekIsV0FERDtJQUVaNHpCLE1BQU0sYUFBVzV6QixXQUZMO0lBR1o2ekIsSUFBSSxXQUFTN3pCLFdBSEQ7SUFJWjh6QixLQUFLLFlBQVU5ekIsV0FKSDtJQUtaK3pCLFFBQVEsZUFBYS96QixXQUxUO0lBTVpnMEIsS0FBSyxZQUFVaDBCLFdBTkg7SUFPWmkwQixPQUFPLGNBQVlqMEIsV0FQUDtJQVFaazBCLFFBQVEsZUFBYWwwQixXQVJUO0lBU1ptMEIsVUFBVSxpQkFBZW4wQixXQVRiO0lBVVpvMEIsVUFBVSxpQkFBZXAwQjtFQVZiLENBQWQ7RUFhQTs7OztNQUlNcTBCO0lBQ0osaUJBQVk3M0IsT0FBWixFQUFxQndCLE1BQXJCLEVBQTZCO01BQzNCLElBQUksT0FBT2tvQixRQUFQLEtBQWtCLFdBQXRCLEVBQW1DO1FBQ2pDLE1BQU0sSUFBSTdtQixTQUFKLENBQWMsOERBQWQsQ0FBTjtNQUNELENBSDBCOztNQU0zQixLQUFLaTFCLFVBQUwsR0FBa0IsSUFBbEI7TUFDQSxLQUFLQyxRQUFMLEdBQWdCLENBQWhCO01BQ0EsS0FBS0MsV0FBTCxHQUFtQixFQUFuQjtNQUNBLEtBQUtDLGNBQUwsR0FBc0IsRUFBdEI7TUFDQSxLQUFLaE0sT0FBTCxHQUFlLElBQWYsQ0FWMkI7O01BYTNCLEtBQUtqc0IsT0FBTCxHQUFlQSxPQUFmO01BQ0EsS0FBS3dCLE1BQUwsR0FBYyxLQUFLc0ssVUFBTCxDQUFnQnRLLE1BQWhCLENBQWQ7TUFDQSxLQUFLMDJCLEdBQUwsR0FBVyxJQUFYO01BRUEsS0FBS0MsYUFBTDtJQUNEOzs7O0lBK0JEO1dBQ0FDLDJCQUFTO01BQ1AsS0FBS04sVUFBTCxHQUFrQixJQUFsQjtJQUNEO1dBRURPLDZCQUFVO01BQ1IsS0FBS1AsVUFBTCxHQUFrQixLQUFsQjtJQUNEO1dBRURRLHlDQUFnQjtNQUNkLEtBQUtSLFVBQUwsR0FBa0IsQ0FBQyxLQUFLQSxVQUF4QjtJQUNEO1dBRURoeEIseUJBQU8xSSxLQUFQLEVBQWM7TUFDWixJQUFJLENBQUMsS0FBSzA1QixVQUFWLEVBQXNCO1FBQ3BCO01BQ0Q7TUFFRCxJQUFJMTVCLEtBQUosRUFBVztRQUNULElBQU1tNkIsT0FBTyxHQUFHLEtBQUt0TCxXQUFMLENBQWlCMXBCLFFBQWpDO1FBQ0EsSUFBSStwQixPQUFPLEdBQUdqdkIscUJBQUMsQ0FBQ0QsS0FBSyxDQUFDd1YsYUFBUCxDQUFELENBQXVCbk8sSUFBdkIsQ0FBNEI4eUIsT0FBNUIsQ0FBZDtRQUVBLElBQUksQ0FBQ2pMLE9BQUwsRUFBYztVQUNaQSxPQUFPLEdBQUcsSUFBSSxLQUFLTCxXQUFULENBQ1I3dUIsS0FBSyxDQUFDd1YsYUFERSxFQUVSLEtBQUs0a0Isa0JBQUwsRUFGUSxDQUFWO1VBSUFuNkIscUJBQUMsQ0FBQ0QsS0FBSyxDQUFDd1YsYUFBUCxDQUFELENBQXVCbk8sSUFBdkIsQ0FBNEI4eUIsT0FBNUIsRUFBcUNqTCxPQUFyQztRQUNEO1FBRURBLE9BQU8sQ0FBQzJLLGNBQVIsQ0FBdUJRLEtBQXZCLEdBQStCLENBQUNuTCxPQUFPLENBQUMySyxjQUFSLENBQXVCUSxLQUF2RDtRQUVBLElBQUluTCxPQUFPLENBQUNvTCxvQkFBUixFQUFKLEVBQW9DO1VBQ2xDcEwsT0FBTyxDQUFDcUwsTUFBUixDQUFlLElBQWYsRUFBcUJyTCxPQUFyQjtRQUNELENBRkQsTUFFTztVQUNMQSxPQUFPLENBQUNzTCxNQUFSLENBQWUsSUFBZixFQUFxQnRMLE9BQXJCO1FBQ0Q7TUFDRixDQW5CRCxNQW1CTztRQUNMLElBQUlqdkIscUJBQUMsQ0FBQyxLQUFLdzZCLGFBQUwsRUFBRCxDQUFELENBQXdCM3pCLFFBQXhCLENBQWlDckIsaUJBQWpDLENBQUosRUFBdUQ7VUFDckQsS0FBSyswQixNQUFMLENBQVksSUFBWixFQUFrQixJQUFsQjtVQUNBO1FBQ0Q7UUFFRCxLQUFLRCxNQUFMLENBQVksSUFBWixFQUFrQixJQUFsQjtNQUNEO0lBQ0Y7V0FFRGgwQiw2QkFBVTtNQUNSMkosWUFBWSxDQUFDLEtBQUt5cEIsUUFBTixDQUFaO01BRUExNUIscUJBQUMsQ0FBQ3VHLFVBQUYsQ0FBYSxLQUFLNUUsT0FBbEIsRUFBMkIsS0FBS2l0QixXQUFMLENBQWlCMXBCLFFBQTVDO01BRUFsRixxQkFBQyxDQUFDLEtBQUsyQixPQUFOLENBQUQsQ0FBZ0J1TixHQUFoQixDQUFvQixLQUFLMGYsV0FBTCxDQUFpQnpwQixTQUFyQztNQUNBbkYscUJBQUMsQ0FBQyxLQUFLMkIsT0FBTixDQUFELENBQWdCOEUsT0FBaEIsQ0FBd0IsUUFBeEIsRUFBa0N5SSxHQUFsQyxDQUFzQyxlQUF0QyxFQUF1RCxLQUFLdXJCLGlCQUE1RDtNQUVBLElBQUksS0FBS1osR0FBVCxFQUFjO1FBQ1o3NUIscUJBQUMsQ0FBQyxLQUFLNjVCLEdBQU4sQ0FBRCxDQUFZN3lCLE1BQVo7TUFDRDtNQUVELEtBQUt5eUIsVUFBTCxHQUFrQixJQUFsQjtNQUNBLEtBQUtDLFFBQUwsR0FBZ0IsSUFBaEI7TUFDQSxLQUFLQyxXQUFMLEdBQW1CLElBQW5CO01BQ0EsS0FBS0MsY0FBTCxHQUFzQixJQUF0QjtNQUNBLElBQUksS0FBS2hNLE9BQVQsRUFBa0I7UUFDaEIsS0FBS0EsT0FBTCxDQUFhOUssT0FBYjtNQUNEO01BRUQsS0FBSzhLLE9BQUwsR0FBZSxJQUFmO01BQ0EsS0FBS2pzQixPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUt3QixNQUFMLEdBQWMsSUFBZDtNQUNBLEtBQUswMkIsR0FBTCxHQUFXLElBQVg7SUFDRDtXQUVEM2xCLHVCQUFPO01BQUE7TUFDTCxJQUFJbFUscUJBQUMsQ0FBQyxLQUFLMkIsT0FBTixDQUFELENBQWdCUyxHQUFoQixDQUFvQixTQUFwQixNQUFtQyxNQUF2QyxFQUErQztRQUM3QyxNQUFNLElBQUkwQixLQUFKLENBQVUscUNBQVYsQ0FBTjtNQUNEO01BRUQsSUFBTXVxQixTQUFTLEdBQUdydUIscUJBQUMsQ0FBQzJHLEtBQUYsQ0FBUSxLQUFLaW9CLFdBQUwsQ0FBaUJqb0IsS0FBakIsQ0FBdUJxeUIsSUFBL0IsQ0FBbEI7TUFDQSxJQUFJLEtBQUswQixhQUFMLE1BQXdCLEtBQUtqQixVQUFqQyxFQUE2QztRQUMzQ3o1QixxQkFBQyxDQUFDLEtBQUsyQixPQUFOLENBQUQsQ0FBZ0JpQixPQUFoQixDQUF3QnlyQixTQUF4QjtRQUVBLElBQU1zTSxVQUFVLEdBQUcvNUIsSUFBSSxDQUFDb0QsY0FBTCxDQUFvQixLQUFLckMsT0FBekIsQ0FBbkI7UUFDQSxJQUFNaTVCLFVBQVUsR0FBRzU2QixxQkFBQyxDQUFDZ0osUUFBRixDQUNqQjJ4QixVQUFVLEtBQUssSUFBZixHQUFzQkEsVUFBdEIsR0FBbUMsS0FBS2g1QixPQUFMLENBQWFnVixhQUFiLENBQTJCMVMsZUFEN0MsRUFFakIsS0FBS3RDLE9BRlksQ0FBbkI7UUFLQSxJQUFJMHNCLFNBQVMsQ0FBQ2pvQixrQkFBVixNQUFrQyxDQUFDdzBCLFVBQXZDLEVBQW1EO1VBQ2pEO1FBQ0Q7UUFFRCxJQUFNZixHQUFHLEdBQUcsS0FBS1csYUFBTCxFQUFaO1FBQ0EsSUFBTUssS0FBSyxHQUFHajZCLElBQUksQ0FBQ1EsTUFBTCxDQUFZLEtBQUt3dEIsV0FBTCxDQUFpQjVwQixJQUE3QixDQUFkO1FBRUE2MEIsR0FBRyxDQUFDendCLFlBQUosQ0FBaUIsSUFBakIsRUFBdUJ5eEIsS0FBdkI7UUFDQSxLQUFLbDVCLE9BQUwsQ0FBYXlILFlBQWIsQ0FBMEIsa0JBQTFCLEVBQThDeXhCLEtBQTlDO1FBRUEsS0FBS0MsVUFBTDtRQUVBLElBQUksS0FBSzMzQixNQUFMLENBQVltMUIsU0FBaEIsRUFBMkI7VUFDekJ0NEIscUJBQUMsQ0FBQzY1QixHQUFELENBQUQsQ0FBT3RvQixRQUFQLENBQWdCaE0saUJBQWhCO1FBQ0Q7UUFFRCxJQUFNK1ksU0FBUyxHQUFHLE9BQU8sS0FBS25iLE1BQUwsQ0FBWW1iLFNBQW5CLEtBQWlDLFVBQWpDLEdBQ2hCLEtBQUtuYixNQUFMLENBQVltYixTQUFaLENBQXNCOWUsSUFBdEIsQ0FBMkIsSUFBM0IsRUFBaUNxNkIsR0FBakMsRUFBc0MsS0FBS2w0QixPQUEzQyxDQURnQixHQUVoQixLQUFLd0IsTUFBTCxDQUFZbWIsU0FGZDtRQUlBLElBQU15YyxVQUFVLEdBQUcsS0FBS0MsY0FBTCxDQUFvQjFjLFNBQXBCLENBQW5CO1FBQ0EsS0FBSzJjLGtCQUFMLENBQXdCRixVQUF4QjtRQUVBLElBQU1yQyxTQUFTLEdBQUcsS0FBS3dDLGFBQUwsRUFBbEI7UUFDQWw3QixxQkFBQyxDQUFDNjVCLEdBQUQsQ0FBRCxDQUFPenlCLElBQVAsQ0FBWSxLQUFLd25CLFdBQUwsQ0FBaUIxcEIsUUFBN0IsRUFBdUMsSUFBdkM7UUFFQSxJQUFJLENBQUNsRixxQkFBQyxDQUFDZ0osUUFBRixDQUFXLEtBQUtySCxPQUFMLENBQWFnVixhQUFiLENBQTJCMVMsZUFBdEMsRUFBdUQsS0FBSzQxQixHQUE1RCxDQUFMLEVBQXVFO1VBQ3JFNzVCLHFCQUFDLENBQUM2NUIsR0FBRCxDQUFELENBQU81RyxRQUFQLENBQWdCeUYsU0FBaEI7UUFDRDtRQUVEMTRCLHFCQUFDLENBQUMsS0FBSzJCLE9BQU4sQ0FBRCxDQUFnQmlCLE9BQWhCLENBQXdCLEtBQUtnc0IsV0FBTCxDQUFpQmpvQixLQUFqQixDQUF1QnV5QixRQUEvQztRQUVBLEtBQUt0TCxPQUFMLEdBQWUsSUFBSXZDLFFBQUosQ0FBVyxLQUFLMXBCLE9BQWhCLEVBQXlCazRCLEdBQXpCLEVBQThCLEtBQUtyTCxnQkFBTCxDQUFzQnVNLFVBQXRCLENBQTlCLENBQWY7UUFFQS82QixxQkFBQyxDQUFDNjVCLEdBQUQsQ0FBRCxDQUFPdG9CLFFBQVAsQ0FBZ0IvTCxpQkFBaEI7UUFDQXhGLHFCQUFDLENBQUM2NUIsR0FBRCxDQUFELENBQU90b0IsUUFBUCxDQUFnQixLQUFLcE8sTUFBTCxDQUFZeTFCLFdBQTVCLEVBNUMyQztRQStDM0M7UUFDQTtRQUNBOztRQUNBLElBQUksa0JBQWtCcDNCLFFBQVEsQ0FBQ3lDLGVBQS9CLEVBQWdEO1VBQzlDakUscUJBQUMsQ0FBQ3dCLFFBQVEsQ0FBQzBWLElBQVYsQ0FBRCxDQUFpQjVGLFFBQWpCLEdBQTRCOUosRUFBNUIsQ0FBK0IsV0FBL0IsRUFBNEMsSUFBNUMsRUFBa0R4SCxxQkFBQyxDQUFDeXVCLElBQXBEO1FBQ0Q7UUFFRCxJQUFNN1osUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBTTtVQUNyQixJQUFJN1QsS0FBSSxDQUFDb0MsTUFBTCxDQUFZbTFCLFNBQWhCLEVBQTJCO1lBQ3pCdjNCLEtBQUksQ0FBQ282QixjQUFMO1VBQ0Q7VUFFRCxJQUFNQyxjQUFjLEdBQUdyNkIsS0FBSSxDQUFDNDRCLFdBQTVCO1VBQ0E1NEIsS0FBSSxDQUFDNDRCLFdBQUwsR0FBbUIsSUFBbkI7VUFFQTM1QixxQkFBQyxDQUFDZSxLQUFJLENBQUNZLE9BQU4sQ0FBRCxDQUFnQmlCLE9BQWhCLENBQXdCN0IsS0FBSSxDQUFDNnRCLFdBQUwsQ0FBaUJqb0IsS0FBakIsQ0FBdUJzeUIsS0FBL0M7VUFFQSxJQUFJbUMsY0FBYyxLQUFLM0QsZUFBdkIsRUFBd0M7WUFDdEMxMkIsS0FBSSxDQUFDdzVCLE1BQUwsQ0FBWSxJQUFaLEVBQWtCeDVCLEtBQWxCO1VBQ0Q7UUFDRixDQWJEO1FBZUEsSUFBSWYscUJBQUMsQ0FBQyxLQUFLNjVCLEdBQU4sQ0FBRCxDQUFZaHpCLFFBQVosQ0FBcUJ0QixpQkFBckIsQ0FBSixFQUEyQztVQUN6QyxJQUFNcEQsa0JBQWtCLEdBQUd2QixJQUFJLENBQUNzQixnQ0FBTCxDQUFzQyxLQUFLMjNCLEdBQTNDLENBQTNCO1VBRUE3NUIscUJBQUMsQ0FBQyxLQUFLNjVCLEdBQU4sQ0FBRCxDQUNHbDVCLEdBREgsQ0FDT0MsSUFBSSxDQUFDMUIsY0FEWixFQUM0QjBWLFFBRDVCLEVBRUcxVCxvQkFGSCxDQUV3QmlCLGtCQUZ4QjtRQUdELENBTkQsTUFNTztVQUNMeVMsUUFBUTtRQUNUO01BQ0Y7SUFDRjtXQUVEWCxxQkFBS3FQLFFBQUwsRUFBZTtNQUFBO01BQ2IsSUFBTXVXLEdBQUcsR0FBRyxLQUFLVyxhQUFMLEVBQVo7TUFDQSxJQUFNOUwsU0FBUyxHQUFHMXVCLHFCQUFDLENBQUMyRyxLQUFGLENBQVEsS0FBS2lvQixXQUFMLENBQWlCam9CLEtBQWpCLENBQXVCbXlCLElBQS9CLENBQWxCO01BQ0EsSUFBTWxrQixRQUFRLEdBQUcsU0FBWEEsUUFBVyxHQUFNO1FBQ3JCLElBQUl0RixNQUFJLENBQUNxcUIsV0FBTCxLQUFxQm5DLGdCQUFyQixJQUF5Q3FDLEdBQUcsQ0FBQ3YxQixVQUFqRCxFQUE2RDtVQUMzRHUxQixHQUFHLENBQUN2MUIsVUFBSixDQUFlNmUsV0FBZixDQUEyQjBXLEdBQTNCO1FBQ0Q7UUFFRHZxQixNQUFJLENBQUMrckIsY0FBTDtRQUNBL3JCLE1BQUksQ0FBQzNOLE9BQUwsQ0FBYW9oQixlQUFiLENBQTZCLGtCQUE3QjtRQUNBL2lCLHFCQUFDLENBQUNzUCxNQUFJLENBQUMzTixPQUFOLENBQUQsQ0FBZ0JpQixPQUFoQixDQUF3QjBNLE1BQUksQ0FBQ3NmLFdBQUwsQ0FBaUJqb0IsS0FBakIsQ0FBdUJveUIsTUFBL0M7UUFDQSxJQUFJenBCLE1BQUksQ0FBQ3NlLE9BQUwsS0FBaUIsSUFBckIsRUFBMkI7VUFDekJ0ZSxNQUFJLENBQUNzZSxPQUFMLENBQWE5SyxPQUFiO1FBQ0Q7UUFFRCxJQUFJUSxRQUFKLEVBQWM7VUFDWkEsUUFBUTtRQUNUO01BQ0YsQ0FmRDtNQWlCQXRqQixxQkFBQyxDQUFDLEtBQUsyQixPQUFOLENBQUQsQ0FBZ0JpQixPQUFoQixDQUF3QjhyQixTQUF4QjtNQUVBLElBQUlBLFNBQVMsQ0FBQ3RvQixrQkFBVixFQUFKLEVBQW9DO1FBQ2xDO01BQ0Q7TUFFRHBHLHFCQUFDLENBQUM2NUIsR0FBRCxDQUFELENBQU9qekIsV0FBUCxDQUFtQnBCLGlCQUFuQixFQTFCYTtNQTZCYjs7TUFDQSxJQUFJLGtCQUFrQmhFLFFBQVEsQ0FBQ3lDLGVBQS9CLEVBQWdEO1FBQzlDakUscUJBQUMsQ0FBQ3dCLFFBQVEsQ0FBQzBWLElBQVYsQ0FBRCxDQUFpQjVGLFFBQWpCLEdBQTRCcEMsR0FBNUIsQ0FBZ0MsV0FBaEMsRUFBNkMsSUFBN0MsRUFBbURsUCxxQkFBQyxDQUFDeXVCLElBQXJEO01BQ0Q7TUFFRCxLQUFLbUwsY0FBTCxDQUFvQjlCLGFBQXBCLElBQXFDLEtBQXJDO01BQ0EsS0FBSzhCLGNBQUwsQ0FBb0IvQixhQUFwQixJQUFxQyxLQUFyQztNQUNBLEtBQUsrQixjQUFMLENBQW9CaEMsYUFBcEIsSUFBcUMsS0FBckM7TUFFQSxJQUFJNTNCLHFCQUFDLENBQUMsS0FBSzY1QixHQUFOLENBQUQsQ0FBWWh6QixRQUFaLENBQXFCdEIsaUJBQXJCLENBQUosRUFBMkM7UUFDekMsSUFBTXBELGtCQUFrQixHQUFHdkIsSUFBSSxDQUFDc0IsZ0NBQUwsQ0FBc0MyM0IsR0FBdEMsQ0FBM0I7UUFFQTc1QixxQkFBQyxDQUFDNjVCLEdBQUQsQ0FBRCxDQUNHbDVCLEdBREgsQ0FDT0MsSUFBSSxDQUFDMUIsY0FEWixFQUM0QjBWLFFBRDVCLEVBRUcxVCxvQkFGSCxDQUV3QmlCLGtCQUZ4QjtNQUdELENBTkQsTUFNTztRQUNMeVMsUUFBUTtNQUNUO01BRUQsS0FBSytrQixXQUFMLEdBQW1CLEVBQW5CO0lBQ0Q7V0FFRG5ZLDJCQUFTO01BQ1AsSUFBSSxLQUFLb00sT0FBTCxLQUFpQixJQUFyQixFQUEyQjtRQUN6QixLQUFLQSxPQUFMLENBQWE1SixjQUFiO01BQ0Q7SUFDRjtJQUFBOztXQUdEMFcseUNBQWdCO01BQ2QsT0FBTzUzQixPQUFPLENBQUMsS0FBS3c0QixRQUFMLEVBQUQsQ0FBZDtJQUNEO1dBRURMLGlEQUFtQkYsVUFBbkIsRUFBK0I7TUFDN0IvNkIscUJBQUMsQ0FBQyxLQUFLdzZCLGFBQUwsRUFBRCxDQUFELENBQXdCanBCLFFBQXhCLENBQW9DOGxCLGNBQXBDLFNBQW9EMEQsVUFBcEQ7SUFDRDtXQUVEUCx5Q0FBZ0I7TUFDZCxLQUFLWCxHQUFMLEdBQVcsS0FBS0EsR0FBTCxJQUFZNzVCLHFCQUFDLENBQUMsS0FBS21ELE1BQUwsQ0FBWW8xQixRQUFiLENBQUQsQ0FBd0IsQ0FBeEIsQ0FBdkI7TUFDQSxPQUFPLEtBQUtzQixHQUFaO0lBQ0Q7V0FFRGlCLG1DQUFhO01BQ1gsSUFBTWpCLEdBQUcsR0FBRyxLQUFLVyxhQUFMLEVBQVo7TUFDQSxLQUFLZSxpQkFBTCxDQUF1QnY3QixxQkFBQyxDQUFDNjVCLEdBQUcsQ0FBQy92QixnQkFBSixDQUFxQjR0QixzQkFBckIsQ0FBRCxDQUF4QixFQUF3RSxLQUFLNEQsUUFBTCxFQUF4RTtNQUNBdDdCLHFCQUFDLENBQUM2NUIsR0FBRCxDQUFELENBQU9qekIsV0FBUCxDQUFzQnJCLGlCQUF0QixTQUF5Q0MsaUJBQXpDO0lBQ0Q7V0FFRCsxQiwrQ0FBa0JwMEIsUUFBbEIsRUFBNEJxMEIsT0FBNUIsRUFBcUM7TUFDbkMsSUFBSSxRQUFPQSxPQUFQLE1BQW1CLFFBQW5CLEtBQWdDQSxPQUFPLENBQUN4NEIsUUFBUixJQUFvQnc0QixPQUFPLENBQUM5MkIsTUFBNUQsQ0FBSixFQUF5RTtRQUN2RTtRQUNBLElBQUksS0FBS3ZCLE1BQUwsQ0FBWW9XLElBQWhCLEVBQXNCO1VBQ3BCLElBQUksQ0FBQ3ZaLHFCQUFDLENBQUN3N0IsT0FBRCxDQUFELENBQVdoMUIsTUFBWCxHQUFvQnRHLEVBQXBCLENBQXVCaUgsUUFBdkIsQ0FBTCxFQUF1QztZQUNyQ0EsUUFBUSxDQUFDczBCLEtBQVQsR0FBaUJDLE1BQWpCLENBQXdCRixPQUF4QjtVQUNEO1FBQ0YsQ0FKRCxNQUlPO1VBQ0xyMEIsUUFBUSxDQUFDdzBCLElBQVQsQ0FBYzM3QixxQkFBQyxDQUFDdzdCLE9BQUQsQ0FBRCxDQUFXRyxJQUFYLEVBQWQ7UUFDRDtRQUVEO01BQ0Q7TUFFRCxJQUFJLEtBQUt4NEIsTUFBTCxDQUFZb1csSUFBaEIsRUFBc0I7UUFDcEIsSUFBSSxLQUFLcFcsTUFBTCxDQUFZMDFCLFFBQWhCLEVBQTBCO1VBQ3hCMkMsT0FBTyxHQUFHaEYsWUFBWSxDQUFDZ0YsT0FBRCxFQUFVLEtBQUtyNEIsTUFBTCxDQUFZdXpCLFNBQXRCLEVBQWlDLEtBQUt2ekIsTUFBTCxDQUFZd3pCLFVBQTdDLENBQXRCO1FBQ0Q7UUFFRHh2QixRQUFRLENBQUNvUyxJQUFULENBQWNpaUIsT0FBZDtNQUNELENBTkQsTUFNTztRQUNMcjBCLFFBQVEsQ0FBQ3cwQixJQUFULENBQWNILE9BQWQ7TUFDRDtJQUNGO1dBRURGLCtCQUFXO01BQ1QsSUFBSTlDLEtBQUssR0FBRyxLQUFLNzJCLE9BQUwsQ0FBYUUsWUFBYixDQUEwQixxQkFBMUIsQ0FBWjtNQUVBLElBQUksQ0FBQzIyQixLQUFMLEVBQVk7UUFDVkEsS0FBSyxHQUFHLE9BQU8sS0FBS3IxQixNQUFMLENBQVlxMUIsS0FBbkIsS0FBNkIsVUFBN0IsR0FDTixLQUFLcjFCLE1BQUwsQ0FBWXExQixLQUFaLENBQWtCaDVCLElBQWxCLENBQXVCLEtBQUttQyxPQUE1QixDQURNLEdBRU4sS0FBS3dCLE1BQUwsQ0FBWXExQixLQUZkO01BR0Q7TUFFRCxPQUFPQSxLQUFQO0lBQ0Q7SUFBQTs7V0FHRGhLLDZDQUFpQnVNLFVBQWpCLEVBQTZCO01BQUE7TUFDM0IsSUFBTWEsZUFBZSxHQUFHO1FBQ3RCdGQsU0FBUyxFQUFFeWMsVUFEVztRQUV0QjlaLFNBQVMsRUFBRTtVQUNUM0QsTUFBTSxFQUFFLEtBQUt5UixVQUFMLEVBREM7VUFFVGhOLElBQUksRUFBRTtZQUNKdUcsUUFBUSxFQUFFLEtBQUtubEIsTUFBTCxDQUFZdzFCO1VBRGxCLENBRkc7VUFLVHBTLEtBQUssRUFBRTtZQUNMNWtCLE9BQU8sRUFBRWcyQjtVQURKLENBTEU7VUFRVHROLGVBQWUsRUFBRTtZQUNmdk0saUJBQWlCLEVBQUUsS0FBSzNhLE1BQUwsQ0FBWXFxQjtVQURoQjtRQVJSLENBRlc7UUFjdEJyTCxRQUFRLEVBQUUsc0JBQUksRUFBSTtVQUNoQixJQUFJL2EsSUFBSSxDQUFDNGEsaUJBQUwsS0FBMkI1YSxJQUFJLENBQUNrWCxTQUFwQyxFQUErQztZQUM3QzVPLE1BQUksQ0FBQ21zQiw0QkFBTCxDQUFrQ3owQixJQUFsQztVQUNEO1FBQ0YsQ0FsQnFCO1FBbUJ0QmdiLFFBQVEsRUFBRSxzQkFBSTtVQUFBLE9BQUkxUyxNQUFJLENBQUNtc0IsNEJBQUwsQ0FBa0N6MEIsSUFBbEMsQ0FBSjtRQUFBO01BbkJRLENBQXhCO01Bc0JBLHNCQUNLdzBCLGVBREwsRUFFSyxLQUFLejRCLE1BQUwsQ0FBWXVxQixZQUZqQjtJQUlEO1dBRURxQixtQ0FBYTtNQUFBO01BQ1gsSUFBTXpSLE1BQU0sR0FBRyxFQUFmO01BRUEsSUFBSSxPQUFPLEtBQUtuYSxNQUFMLENBQVltYSxNQUFuQixLQUE4QixVQUFsQyxFQUE4QztRQUM1Q0EsTUFBTSxDQUFDcmMsRUFBUCxHQUFZLGNBQUksRUFBSTtVQUNsQm1HLElBQUksQ0FBQzJVLE9BQUwsa0JBQ0szVSxJQUFJLENBQUMyVSxPQURWLEVBRUs3SixNQUFJLENBQUMvTyxNQUFMLENBQVltYSxNQUFaLENBQW1CbFcsSUFBSSxDQUFDMlUsT0FBeEIsRUFBaUM3SixNQUFJLENBQUN2USxPQUF0QyxDQUZMO1VBS0EsT0FBT3lGLElBQVA7UUFDRCxDQVBEO01BUUQsQ0FURCxNQVNPO1FBQ0xrVyxNQUFNLENBQUNBLE1BQVAsR0FBZ0IsS0FBS25hLE1BQUwsQ0FBWW1hLE1BQTVCO01BQ0Q7TUFFRCxPQUFPQSxNQUFQO0lBQ0Q7V0FFRDRkLHlDQUFnQjtNQUNkLElBQUksS0FBSy8zQixNQUFMLENBQVl1MUIsU0FBWixLQUEwQixLQUE5QixFQUFxQztRQUNuQyxPQUFPbDNCLFFBQVEsQ0FBQzBWLElBQWhCO01BQ0Q7TUFFRCxJQUFJdFcsSUFBSSxDQUFDbUMsU0FBTCxDQUFlLEtBQUtJLE1BQUwsQ0FBWXUxQixTQUEzQixDQUFKLEVBQTJDO1FBQ3pDLE9BQU8xNEIscUJBQUMsQ0FBQyxLQUFLbUQsTUFBTCxDQUFZdTFCLFNBQWIsQ0FBUjtNQUNEO01BRUQsT0FBTzE0QixxQkFBQyxDQUFDd0IsUUFBRCxDQUFELENBQVlpZixJQUFaLENBQWlCLEtBQUt0ZCxNQUFMLENBQVl1MUIsU0FBN0IsQ0FBUDtJQUNEO1dBRURzQyx5Q0FBZTFjLFNBQWYsRUFBMEI7TUFDeEIsT0FBTzBaLGFBQWEsQ0FBQzFaLFNBQVMsQ0FBQ3ZhLFdBQVYsRUFBRCxDQUFwQjtJQUNEO1dBRUQrMUIseUNBQWdCO01BQUE7TUFDZCxJQUFNZ0MsUUFBUSxHQUFHLEtBQUszNEIsTUFBTCxDQUFZUCxPQUFaLENBQW9CSCxLQUFwQixDQUEwQixHQUExQixDQUFqQjtNQUVBcTVCLFFBQVEsQ0FBQzFhLE9BQVQsQ0FBaUIsaUJBQU8sRUFBSTtRQUMxQixJQUFJeGUsT0FBTyxLQUFLLE9BQWhCLEVBQXlCO1VBQ3ZCNUMscUJBQUMsQ0FBQ3N5QixNQUFJLENBQUMzd0IsT0FBTixDQUFELENBQWdCNkYsRUFBaEIsQ0FDRThxQixNQUFJLENBQUMxRCxXQUFMLENBQWlCam9CLEtBQWpCLENBQXVCd3lCLEtBRHpCLEVBRUU3RyxNQUFJLENBQUNudkIsTUFBTCxDQUFZdkIsUUFGZCxFQUdFLGVBQUs7WUFBQSxPQUFJMHdCLE1BQUksQ0FBQzdwQixNQUFMLENBQVkxSSxLQUFaLENBQUo7VUFBQSxDQUhQO1FBS0QsQ0FORCxNQU1PLElBQUk2QyxPQUFPLEtBQUttMUIsY0FBaEIsRUFBZ0M7VUFDckMsSUFBTWdFLE9BQU8sR0FBR241QixPQUFPLEtBQUtnMUIsYUFBWixHQUNkdEYsTUFBSSxDQUFDMUQsV0FBTCxDQUFpQmpvQixLQUFqQixDQUF1QjJ5QixVQURULEdBRWRoSCxNQUFJLENBQUMxRCxXQUFMLENBQWlCam9CLEtBQWpCLENBQXVCeXlCLE9BRnpCO1VBR0EsSUFBTTRDLFFBQVEsR0FBR3A1QixPQUFPLEtBQUtnMUIsYUFBWixHQUNmdEYsTUFBSSxDQUFDMUQsV0FBTCxDQUFpQmpvQixLQUFqQixDQUF1QjR5QixVQURSLEdBRWZqSCxNQUFJLENBQUMxRCxXQUFMLENBQWlCam9CLEtBQWpCLENBQXVCMHlCLFFBRnpCO1VBSUFyNUIscUJBQUMsQ0FBQ3N5QixNQUFJLENBQUMzd0IsT0FBTixDQUFELENBQ0c2RixFQURILENBQ011MEIsT0FETixFQUNlekosTUFBSSxDQUFDbnZCLE1BQUwsQ0FBWXZCLFFBRDNCLEVBQ3FDLGVBQUs7WUFBQSxPQUFJMHdCLE1BQUksQ0FBQ2dJLE1BQUwsQ0FBWXY2QixLQUFaLENBQUo7VUFBQSxDQUQxQyxFQUVHeUgsRUFGSCxDQUVNdzBCLFFBRk4sRUFFZ0IxSixNQUFJLENBQUNudkIsTUFBTCxDQUFZdkIsUUFGNUIsRUFFc0MsZUFBSztZQUFBLE9BQUkwd0IsTUFBSSxDQUFDaUksTUFBTCxDQUFZeDZCLEtBQVosQ0FBSjtVQUFBLENBRjNDO1FBR0Q7TUFDRixDQW5CRDtNQXFCQSxLQUFLMDZCLGlCQUFMLEdBQXlCLFlBQU07UUFDN0IsSUFBSW5JLE1BQUksQ0FBQzN3QixPQUFULEVBQWtCO1VBQ2hCMndCLE1BQUksQ0FBQ3JlLElBQUw7UUFDRDtNQUNGLENBSkQ7TUFNQWpVLHFCQUFDLENBQUMsS0FBSzJCLE9BQU4sQ0FBRCxDQUFnQjhFLE9BQWhCLENBQXdCLFFBQXhCLEVBQWtDZSxFQUFsQyxDQUFxQyxlQUFyQyxFQUFzRCxLQUFLaXpCLGlCQUEzRDtNQUVBLElBQUksS0FBS3QzQixNQUFMLENBQVl2QixRQUFoQixFQUEwQjtRQUN4QixLQUFLdUIsTUFBTCxrQkFDSyxLQUFLQSxNQURWO1VBRUVQLE9BQU8sRUFBRSxRQUZYO1VBR0VoQixRQUFRLEVBQUU7UUFIWjtNQUtELENBTkQsTUFNTztRQUNMLEtBQUtxNkIsU0FBTDtNQUNEO0lBQ0Y7V0FFREEsaUNBQVk7TUFDVixJQUFNQyxTQUFTLFdBQVUsS0FBS3Y2QixPQUFMLENBQWFFLFlBQWIsQ0FBMEIscUJBQTFCLENBQXpCO01BRUEsSUFBSSxLQUFLRixPQUFMLENBQWFFLFlBQWIsQ0FBMEIsT0FBMUIsS0FBc0NxNkIsU0FBUyxLQUFLLFFBQXhELEVBQWtFO1FBQ2hFLEtBQUt2NkIsT0FBTCxDQUFheUgsWUFBYixDQUNFLHFCQURGLEVBRUUsS0FBS3pILE9BQUwsQ0FBYUUsWUFBYixDQUEwQixPQUExQixLQUFzQyxFQUZ4QztRQUtBLEtBQUtGLE9BQUwsQ0FBYXlILFlBQWIsQ0FBMEIsT0FBMUIsRUFBbUMsRUFBbkM7TUFDRDtJQUNGO1dBRURreEIseUJBQU92NkIsS0FBUCxFQUFja3ZCLE9BQWQsRUFBdUI7TUFDckIsSUFBTWlMLE9BQU8sR0FBRyxLQUFLdEwsV0FBTCxDQUFpQjFwQixRQUFqQztNQUNBK3BCLE9BQU8sR0FBR0EsT0FBTyxJQUFJanZCLHFCQUFDLENBQUNELEtBQUssQ0FBQ3dWLGFBQVAsQ0FBRCxDQUF1Qm5PLElBQXZCLENBQTRCOHlCLE9BQTVCLENBQXJCO01BRUEsSUFBSSxDQUFDakwsT0FBTCxFQUFjO1FBQ1pBLE9BQU8sR0FBRyxJQUFJLEtBQUtMLFdBQVQsQ0FDUjd1QixLQUFLLENBQUN3VixhQURFLEVBRVIsS0FBSzRrQixrQkFBTCxFQUZRLENBQVY7UUFJQW42QixxQkFBQyxDQUFDRCxLQUFLLENBQUN3VixhQUFQLENBQUQsQ0FBdUJuTyxJQUF2QixDQUE0Qjh5QixPQUE1QixFQUFxQ2pMLE9BQXJDO01BQ0Q7TUFFRCxJQUFJbHZCLEtBQUosRUFBVztRQUNUa3ZCLE9BQU8sQ0FBQzJLLGNBQVIsQ0FDRTc1QixLQUFLLENBQUM4SSxJQUFOLEtBQWUsU0FBZixHQUEyQmd2QixhQUEzQixHQUEyQ0QsYUFEN0MsSUFFSSxJQUZKO01BR0Q7TUFFRCxJQUFJNTNCLHFCQUFDLENBQUNpdkIsT0FBTyxDQUFDdUwsYUFBUixFQUFELENBQUQsQ0FBMkIzekIsUUFBM0IsQ0FBb0NyQixpQkFBcEMsS0FBd0R5cEIsT0FBTyxDQUFDMEssV0FBUixLQUF3Qm5DLGdCQUFwRixFQUFzRztRQUNwR3ZJLE9BQU8sQ0FBQzBLLFdBQVIsR0FBc0JuQyxnQkFBdEI7UUFDQTtNQUNEO01BRUR2bkIsWUFBWSxDQUFDZ2YsT0FBTyxDQUFDeUssUUFBVCxDQUFaO01BRUF6SyxPQUFPLENBQUMwSyxXQUFSLEdBQXNCbkMsZ0JBQXRCO01BRUEsSUFBSSxDQUFDdkksT0FBTyxDQUFDOXJCLE1BQVIsQ0FBZXMxQixLQUFoQixJQUF5QixDQUFDeEosT0FBTyxDQUFDOXJCLE1BQVIsQ0FBZXMxQixLQUFmLENBQXFCdmtCLElBQW5ELEVBQXlEO1FBQ3ZEK2EsT0FBTyxDQUFDL2EsSUFBUjtRQUNBO01BQ0Q7TUFFRCthLE9BQU8sQ0FBQ3lLLFFBQVIsR0FBbUI3NEIsVUFBVSxDQUFDLFlBQU07UUFDbEMsSUFBSW91QixPQUFPLENBQUMwSyxXQUFSLEtBQXdCbkMsZ0JBQTVCLEVBQThDO1VBQzVDdkksT0FBTyxDQUFDL2EsSUFBUjtRQUNEO01BQ0YsQ0FKNEIsRUFJMUIrYSxPQUFPLENBQUM5ckIsTUFBUixDQUFlczFCLEtBQWYsQ0FBcUJ2a0IsSUFKSyxDQUE3QjtJQUtEO1dBRURxbUIseUJBQU94NkIsS0FBUCxFQUFja3ZCLE9BQWQsRUFBdUI7TUFDckIsSUFBTWlMLE9BQU8sR0FBRyxLQUFLdEwsV0FBTCxDQUFpQjFwQixRQUFqQztNQUNBK3BCLE9BQU8sR0FBR0EsT0FBTyxJQUFJanZCLHFCQUFDLENBQUNELEtBQUssQ0FBQ3dWLGFBQVAsQ0FBRCxDQUF1Qm5PLElBQXZCLENBQTRCOHlCLE9BQTVCLENBQXJCO01BRUEsSUFBSSxDQUFDakwsT0FBTCxFQUFjO1FBQ1pBLE9BQU8sR0FBRyxJQUFJLEtBQUtMLFdBQVQsQ0FDUjd1QixLQUFLLENBQUN3VixhQURFLEVBRVIsS0FBSzRrQixrQkFBTCxFQUZRLENBQVY7UUFJQW42QixxQkFBQyxDQUFDRCxLQUFLLENBQUN3VixhQUFQLENBQUQsQ0FBdUJuTyxJQUF2QixDQUE0Qjh5QixPQUE1QixFQUFxQ2pMLE9BQXJDO01BQ0Q7TUFFRCxJQUFJbHZCLEtBQUosRUFBVztRQUNUa3ZCLE9BQU8sQ0FBQzJLLGNBQVIsQ0FDRTc1QixLQUFLLENBQUM4SSxJQUFOLEtBQWUsVUFBZixHQUE0Qmd2QixhQUE1QixHQUE0Q0QsYUFEOUMsSUFFSSxLQUZKO01BR0Q7TUFFRCxJQUFJM0ksT0FBTyxDQUFDb0wsb0JBQVIsRUFBSixFQUFvQztRQUNsQztNQUNEO01BRURwcUIsWUFBWSxDQUFDZ2YsT0FBTyxDQUFDeUssUUFBVCxDQUFaO01BRUF6SyxPQUFPLENBQUMwSyxXQUFSLEdBQXNCbEMsZUFBdEI7TUFFQSxJQUFJLENBQUN4SSxPQUFPLENBQUM5ckIsTUFBUixDQUFlczFCLEtBQWhCLElBQXlCLENBQUN4SixPQUFPLENBQUM5ckIsTUFBUixDQUFlczFCLEtBQWYsQ0FBcUJ4a0IsSUFBbkQsRUFBeUQ7UUFDdkRnYixPQUFPLENBQUNoYixJQUFSO1FBQ0E7TUFDRDtNQUVEZ2IsT0FBTyxDQUFDeUssUUFBUixHQUFtQjc0QixVQUFVLENBQUMsWUFBTTtRQUNsQyxJQUFJb3VCLE9BQU8sQ0FBQzBLLFdBQVIsS0FBd0JsQyxlQUE1QixFQUE2QztVQUMzQ3hJLE9BQU8sQ0FBQ2hiLElBQVI7UUFDRDtNQUNGLENBSjRCLEVBSTFCZ2IsT0FBTyxDQUFDOXJCLE1BQVIsQ0FBZXMxQixLQUFmLENBQXFCeGtCLElBSkssQ0FBN0I7SUFLRDtXQUVEb21CLHVEQUF1QjtNQUNyQixLQUFLLElBQU16M0IsT0FBWCxJQUFzQixLQUFLZzNCLGNBQTNCLEVBQTJDO1FBQ3pDLElBQUksS0FBS0EsY0FBTCxDQUFvQmgzQixPQUFwQixDQUFKLEVBQWtDO1VBQ2hDLE9BQU8sSUFBUDtRQUNEO01BQ0Y7TUFFRCxPQUFPLEtBQVA7SUFDRDtXQUVENkssaUNBQVd0SyxNQUFYLEVBQW1CO01BQ2pCLElBQU1nNUIsY0FBYyxHQUFHbjhCLHFCQUFDLENBQUMsS0FBSzJCLE9BQU4sQ0FBRCxDQUFnQnlGLElBQWhCLEVBQXZCO01BRUE5RCxNQUFNLENBQUNvYixJQUFQLENBQVl5ZCxjQUFaLEVBQ0cvYSxPQURILENBQ1csa0JBQVEsRUFBSTtRQUNuQixJQUFJbVcscUJBQXFCLENBQUNubkIsT0FBdEIsQ0FBOEJnc0IsUUFBOUIsTUFBNEMsQ0FBQyxDQUFqRCxFQUFvRDtVQUNsRCxPQUFPRCxjQUFjLENBQUNDLFFBQUQsQ0FBckI7UUFDRDtNQUNGLENBTEg7TUFPQWo1QixNQUFNLGtCQUNELEtBQUt5ckIsV0FBTCxDQUFpQnhpQixPQURoQixFQUVEK3ZCLGNBRkMsRUFHQSxRQUFPaDVCLE1BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE1BQTlCLEdBQXVDQSxNQUF2QyxHQUFnRCxFQUhoRCxDQUFOO01BTUEsSUFBSSxPQUFPQSxNQUFNLENBQUNzMUIsS0FBZCxLQUF3QixRQUE1QixFQUFzQztRQUNwQ3QxQixNQUFNLENBQUNzMUIsS0FBUCxHQUFlO1VBQ2J2a0IsSUFBSSxFQUFFL1EsTUFBTSxDQUFDczFCLEtBREE7VUFFYnhrQixJQUFJLEVBQUU5USxNQUFNLENBQUNzMUI7UUFGQSxDQUFmO01BSUQ7TUFFRCxJQUFJLE9BQU90MUIsTUFBTSxDQUFDcTFCLEtBQWQsS0FBd0IsUUFBNUIsRUFBc0M7UUFDcENyMUIsTUFBTSxDQUFDcTFCLEtBQVAsR0FBZXIxQixNQUFNLENBQUNxMUIsS0FBUCxDQUFhajVCLFFBQWIsRUFBZjtNQUNEO01BRUQsSUFBSSxPQUFPNEQsTUFBTSxDQUFDcTRCLE9BQWQsS0FBMEIsUUFBOUIsRUFBd0M7UUFDdENyNEIsTUFBTSxDQUFDcTRCLE9BQVAsR0FBaUJyNEIsTUFBTSxDQUFDcTRCLE9BQVAsQ0FBZWo4QixRQUFmLEVBQWpCO01BQ0Q7TUFFRHFCLElBQUksQ0FBQ3FDLGVBQUwsQ0FDRStCLE1BREYsRUFFRTdCLE1BRkYsRUFHRSxLQUFLeXJCLFdBQUwsQ0FBaUJqaUIsV0FIbkI7TUFNQSxJQUFJeEosTUFBTSxDQUFDMDFCLFFBQVgsRUFBcUI7UUFDbkIxMUIsTUFBTSxDQUFDbzFCLFFBQVAsR0FBa0IvQixZQUFZLENBQUNyekIsTUFBTSxDQUFDbzFCLFFBQVIsRUFBa0JwMUIsTUFBTSxDQUFDdXpCLFNBQXpCLEVBQW9DdnpCLE1BQU0sQ0FBQ3d6QixVQUEzQyxDQUE5QjtNQUNEO01BRUQsT0FBT3h6QixNQUFQO0lBQ0Q7V0FFRGczQixtREFBcUI7TUFDbkIsSUFBTWgzQixNQUFNLEdBQUcsRUFBZjtNQUVBLElBQUksS0FBS0EsTUFBVCxFQUFpQjtRQUNmLEtBQUssSUFBTXFZLEdBQVgsSUFBa0IsS0FBS3JZLE1BQXZCLEVBQStCO1VBQzdCLElBQUksS0FBS3lyQixXQUFMLENBQWlCeGlCLE9BQWpCLENBQXlCb1AsR0FBekIsTUFBa0MsS0FBS3JZLE1BQUwsQ0FBWXFZLEdBQVosQ0FBdEMsRUFBd0Q7WUFDdERyWSxNQUFNLENBQUNxWSxHQUFELENBQU4sR0FBYyxLQUFLclksTUFBTCxDQUFZcVksR0FBWixDQUFkO1VBQ0Q7UUFDRjtNQUNGO01BRUQsT0FBT3JZLE1BQVA7SUFDRDtXQUVEazRCLDJDQUFpQjtNQUNmLElBQU1nQixJQUFJLEdBQUdyOEIscUJBQUMsQ0FBQyxLQUFLdzZCLGFBQUwsRUFBRCxDQUFkO01BQ0EsSUFBTThCLFFBQVEsR0FBR0QsSUFBSSxDQUFDM25CLElBQUwsQ0FBVSxPQUFWLEVBQW1CalYsS0FBbkIsQ0FBeUI2M0Isb0JBQXpCLENBQWpCO01BQ0EsSUFBSWdGLFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLENBQUNyeUIsTUFBbEMsRUFBMEM7UUFDeENveUIsSUFBSSxDQUFDejFCLFdBQUwsQ0FBaUIwMUIsUUFBUSxDQUFDQyxJQUFULENBQWMsRUFBZCxDQUFqQjtNQUNEO0lBQ0Y7V0FFRFYscUVBQTZCVyxVQUE3QixFQUF5QztNQUN2QyxLQUFLM0MsR0FBTCxHQUFXMkMsVUFBVSxDQUFDemhCLFFBQVgsQ0FBb0I2QyxNQUEvQjtNQUNBLEtBQUt5ZCxjQUFMO01BQ0EsS0FBS0osa0JBQUwsQ0FBd0IsS0FBS0QsY0FBTCxDQUFvQndCLFVBQVUsQ0FBQ2xlLFNBQS9CLENBQXhCO0lBQ0Q7V0FFRDZjLDJDQUFpQjtNQUNmLElBQU10QixHQUFHLEdBQUcsS0FBS1csYUFBTCxFQUFaO01BQ0EsSUFBTWlDLG1CQUFtQixHQUFHLEtBQUt0NUIsTUFBTCxDQUFZbTFCLFNBQXhDO01BRUEsSUFBSXVCLEdBQUcsQ0FBQ2g0QixZQUFKLENBQWlCLGFBQWpCLE1BQW9DLElBQXhDLEVBQThDO1FBQzVDO01BQ0Q7TUFFRDdCLHFCQUFDLENBQUM2NUIsR0FBRCxDQUFELENBQU9qekIsV0FBUCxDQUFtQnJCLGlCQUFuQjtNQUNBLEtBQUtwQyxNQUFMLENBQVltMUIsU0FBWixHQUF3QixLQUF4QjtNQUNBLEtBQUtya0IsSUFBTDtNQUNBLEtBQUtDLElBQUw7TUFDQSxLQUFLL1EsTUFBTCxDQUFZbTFCLFNBQVosR0FBd0JtRSxtQkFBeEI7SUFDRDtJQUFBOztZQUdNeDFCLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDO01BQzlCLE9BQU8sS0FBSytELElBQUwsQ0FBVSxZQUFZO1FBQzNCLElBQU1DLFFBQVEsR0FBR25ILHFCQUFDLENBQUMsSUFBRCxDQUFsQjtRQUNBLElBQUlvSCxJQUFJLEdBQUdELFFBQVEsQ0FBQ0MsSUFBVCxDQUFjbEMsVUFBZCxDQUFYO1FBQ0EsSUFBTXNJLE9BQU8sR0FBRyxRQUFPckssTUFBUCxNQUFrQixRQUFsQixJQUE4QkEsTUFBOUM7UUFFQSxJQUFJLENBQUNpRSxJQUFELElBQVMsZUFBZXZELElBQWYsQ0FBb0JWLE1BQXBCLENBQWIsRUFBMEM7VUFDeEM7UUFDRDtRQUVELElBQUksQ0FBQ2lFLElBQUwsRUFBVztVQUNUQSxJQUFJLEdBQUcsSUFBSW95QixPQUFKLENBQVksSUFBWixFQUFrQmhzQixPQUFsQixDQUFQO1VBQ0FyRyxRQUFRLENBQUNDLElBQVQsQ0FBY2xDLFVBQWQsRUFBd0JrQyxJQUF4QjtRQUNEO1FBRUQsSUFBSSxPQUFPakUsTUFBUCxLQUFrQixRQUF0QixFQUFnQztVQUM5QixJQUFJLE9BQU9pRSxJQUFJLENBQUNqRSxNQUFELENBQVgsS0FBd0IsV0FBNUIsRUFBeUM7WUFDdkMsTUFBTSxJQUFJcUIsU0FBSix3QkFBa0NyQixNQUFsQyxRQUFOO1VBQ0Q7VUFFRGlFLElBQUksQ0FBQ2pFLE1BQUQsQ0FBSjtRQUNEO01BQ0YsQ0FyQk0sQ0FBUDtJQXNCRDs7O1dBN21CRCxlQUFxQjtRQUNuQixPQUFPOEIsU0FBUDtNQUNEOzs7V0FFRCxlQUFxQjtRQUNuQixPQUFPbUgsU0FBUDtNQUNEOzs7V0FFRCxlQUFrQjtRQUNoQixPQUFPcEgsTUFBUDtNQUNEOzs7V0FFRCxlQUFzQjtRQUNwQixPQUFPRSxVQUFQO01BQ0Q7OztXQUVELGVBQW1CO1FBQ2pCLE9BQU95QixPQUFQO01BQ0Q7OztXQUVELGVBQXVCO1FBQ3JCLE9BQU94QixXQUFQO01BQ0Q7OztXQUVELGVBQXlCO1FBQ3ZCLE9BQU93SCxhQUFQO01BQ0Q7Ozs7RUFzbEJIOzs7O0VBSUEzTSxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhdzBCLE9BQU8sQ0FBQ3Z5QixnQkFBckI7RUFDQWpILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVd5QyxXQUFYLEdBQXlCK3hCLE9BQXpCO0VBQ0F4NUIscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsRUFBVzBDLFVBQVgsR0FBd0IsWUFBTTtJQUM1QjFILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLElBQWFLLG9CQUFiO0lBQ0EsT0FBT20wQixPQUFPLENBQUN2eUIsZ0JBQWY7RUFDRCxDQUhEOztFQzV1QkE7Ozs7RUFJQSxJQUFNakMsTUFBSSxHQUFHLFNBQWI7RUFDQSxJQUFNQyxTQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyxVQUFRLEdBQUcsWUFBakI7RUFDQSxJQUFNQyxXQUFTLFNBQU9ELFVBQXRCO0VBQ0EsSUFBTUcsb0JBQWtCLEdBQUdyRixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxDQUEzQjtFQUNBLElBQU1xeUIsWUFBWSxHQUFHLFlBQXJCO0VBQ0EsSUFBTUMsa0JBQWtCLEdBQUcsSUFBSTF6QixNQUFKLGFBQXFCeXpCLFlBQXJCLFdBQXlDLEdBQXpDLENBQTNCO0VBRUEsSUFBTTl4QixpQkFBZSxHQUFHLE1BQXhCO0VBQ0EsSUFBTUMsaUJBQWUsR0FBRyxNQUF4QjtFQUVBLElBQU1rM0IsY0FBYyxHQUFHLGlCQUF2QjtFQUNBLElBQU1DLGdCQUFnQixHQUFHLGVBQXpCO0VBRUEsSUFBTXZ3QixTQUFPLGtCQUNSb3RCLE9BQU8sQ0FBQ3B0QixPQURBO0lBRVhrUyxTQUFTLEVBQUUsT0FGQTtJQUdYMWIsT0FBTyxFQUFFLE9BSEU7SUFJWDQ0QixPQUFPLEVBQUUsRUFKRTtJQUtYakQsUUFBUSxFQUFFLHlDQUNFLDJCQURGLEdBRUUsa0NBRkYsR0FHRTtFQVJELEVBQWI7RUFXQSxJQUFNNXJCLGFBQVcsa0JBQ1o2c0IsT0FBTyxDQUFDN3NCLFdBREk7SUFFZjZ1QixPQUFPLEVBQUU7RUFGTSxFQUFqQjtFQUtBLElBQU03MEIsS0FBSyxHQUFHO0lBQ1pteUIsSUFBSSxXQUFTM3pCLFdBREQ7SUFFWjR6QixNQUFNLGFBQVc1ekIsV0FGTDtJQUdaNnpCLElBQUksV0FBUzd6QixXQUhEO0lBSVo4ekIsS0FBSyxZQUFVOXpCLFdBSkg7SUFLWit6QixRQUFRLGVBQWEvekIsV0FMVDtJQU1aZzBCLEtBQUssWUFBVWgwQixXQU5IO0lBT1ppMEIsT0FBTyxjQUFZajBCLFdBUFA7SUFRWmswQixRQUFRLGVBQWFsMEIsV0FSVDtJQVNabTBCLFVBQVUsaUJBQWVuMEIsV0FUYjtJQVVabzBCLFVBQVUsaUJBQWVwMEI7RUFWYixDQUFkO0VBYUE7Ozs7TUFJTXkzQjs7Ozs7OztJQThCSjtXQUNBbEMseUNBQWdCO01BQ2QsT0FBTyxLQUFLWSxRQUFMLE1BQW1CLEtBQUt1QixXQUFMLEVBQTFCO0lBQ0Q7V0FFRDVCLGlEQUFtQkYsVUFBbkIsRUFBK0I7TUFDN0IvNkIscUJBQUMsQ0FBQyxLQUFLdzZCLGFBQUwsRUFBRCxDQUFELENBQXdCanBCLFFBQXhCLENBQW9DOGxCLFlBQXBDLFNBQW9EMEQsVUFBcEQ7SUFDRDtXQUVEUCx5Q0FBZ0I7TUFDZCxLQUFLWCxHQUFMLEdBQVcsS0FBS0EsR0FBTCxJQUFZNzVCLHFCQUFDLENBQUMsS0FBS21ELE1BQUwsQ0FBWW8xQixRQUFiLENBQUQsQ0FBd0IsQ0FBeEIsQ0FBdkI7TUFDQSxPQUFPLEtBQUtzQixHQUFaO0lBQ0Q7V0FFRGlCLG1DQUFhO01BQ1gsSUFBTXVCLElBQUksR0FBR3I4QixxQkFBQyxDQUFDLEtBQUt3NkIsYUFBTCxFQUFELENBQWQsQ0FEVzs7TUFJWCxLQUFLZSxpQkFBTCxDQUF1QmMsSUFBSSxDQUFDNWIsSUFBTCxDQUFVaWMsY0FBVixDQUF2QixFQUFrRCxLQUFLcEIsUUFBTCxFQUFsRDtNQUNBLElBQUlFLE9BQU8sR0FBRyxLQUFLcUIsV0FBTCxFQUFkO01BQ0EsSUFBSSxPQUFPckIsT0FBUCxLQUFtQixVQUF2QixFQUFtQztRQUNqQ0EsT0FBTyxHQUFHQSxPQUFPLENBQUNoOEIsSUFBUixDQUFhLEtBQUttQyxPQUFsQixDQUFWO01BQ0Q7TUFFRCxLQUFLNDVCLGlCQUFMLENBQXVCYyxJQUFJLENBQUM1YixJQUFMLENBQVVrYyxnQkFBVixDQUF2QixFQUFvRG5CLE9BQXBEO01BRUFhLElBQUksQ0FBQ3oxQixXQUFMLENBQW9CckIsaUJBQXBCLFNBQXVDQyxpQkFBdkM7SUFDRDtJQUFBOztXQUdEcTNCLHFDQUFjO01BQ1osT0FBTyxLQUFLbDdCLE9BQUwsQ0FBYUUsWUFBYixDQUEwQixjQUExQixLQUNMLEtBQUtzQixNQUFMLENBQVlxNEIsT0FEZDtJQUVEO1dBRURILDJDQUFpQjtNQUNmLElBQU1nQixJQUFJLEdBQUdyOEIscUJBQUMsQ0FBQyxLQUFLdzZCLGFBQUwsRUFBRCxDQUFkO01BQ0EsSUFBTThCLFFBQVEsR0FBR0QsSUFBSSxDQUFDM25CLElBQUwsQ0FBVSxPQUFWLEVBQW1CalYsS0FBbkIsQ0FBeUI2M0Isa0JBQXpCLENBQWpCO01BQ0EsSUFBSWdGLFFBQVEsS0FBSyxJQUFiLElBQXFCQSxRQUFRLENBQUNyeUIsTUFBVCxHQUFrQixDQUEzQyxFQUE4QztRQUM1Q295QixJQUFJLENBQUN6MUIsV0FBTCxDQUFpQjAxQixRQUFRLENBQUNDLElBQVQsQ0FBYyxFQUFkLENBQWpCO01BQ0Q7SUFDRjtJQUFBOztZQUdNdDFCLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDO01BQzlCLE9BQU8sS0FBSytELElBQUwsQ0FBVSxZQUFZO1FBQzNCLElBQUlFLElBQUksR0FBR3BILHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLENBQWFsQyxVQUFiLENBQVg7UUFDQSxJQUFNc0ksT0FBTyxHQUFHLFFBQU9ySyxNQUFQLE1BQWtCLFFBQWxCLEdBQTZCQSxNQUE3QixHQUFzQyxJQUF0RDtRQUVBLElBQUksQ0FBQ2lFLElBQUQsSUFBUyxlQUFldkQsSUFBZixDQUFvQlYsTUFBcEIsQ0FBYixFQUEwQztVQUN4QztRQUNEO1FBRUQsSUFBSSxDQUFDaUUsSUFBTCxFQUFXO1VBQ1RBLElBQUksR0FBRyxJQUFJdzFCLE9BQUosQ0FBWSxJQUFaLEVBQWtCcHZCLE9BQWxCLENBQVA7VUFDQXhOLHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLENBQWFsQyxVQUFiLEVBQXVCa0MsSUFBdkI7UUFDRDtRQUVELElBQUksT0FBT2pFLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDOUIsSUFBSSxPQUFPaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFYLEtBQXdCLFdBQTVCLEVBQXlDO1lBQ3ZDLE1BQU0sSUFBSXFCLFNBQUosd0JBQWtDckIsTUFBbEMsUUFBTjtVQUNEO1VBRURpRSxJQUFJLENBQUNqRSxNQUFELENBQUo7UUFDRDtNQUNGLENBcEJNLENBQVA7SUFxQkQ7Ozs7O01BOUZELGVBQXFCO1FBQ25CLE9BQU84QixTQUFQO01BQ0Q7OztXQUVELGVBQXFCO1FBQ25CLE9BQU9tSCxTQUFQO01BQ0Q7OztXQUVELGVBQWtCO1FBQ2hCLE9BQU9wSCxNQUFQO01BQ0Q7OztXQUVELGVBQXNCO1FBQ3BCLE9BQU9FLFVBQVA7TUFDRDs7O1dBRUQsZUFBbUI7UUFDakIsT0FBT3lCLEtBQVA7TUFDRDs7O1dBRUQsZUFBdUI7UUFDckIsT0FBT3hCLFdBQVA7TUFDRDs7O1dBRUQsZUFBeUI7UUFDdkIsT0FBT3dILGFBQVA7TUFDRDs7O0lBNUJtQjZzQjtFQW1HdEI7Ozs7RUFJQXg1QixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhNDNCLE9BQU8sQ0FBQzMxQixnQkFBckI7RUFDQWpILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVd5QyxXQUFYLEdBQXlCbTFCLE9BQXpCO0VBQ0E1OEIscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsRUFBVzBDLFVBQVgsR0FBd0IsWUFBTTtJQUM1QjFILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLElBQWFLLG9CQUFiO0lBQ0EsT0FBT3UzQixPQUFPLENBQUMzMUIsZ0JBQWY7RUFDRCxDQUhEOztFQzVKQTs7OztFQUlBLElBQU1qQyxNQUFJLEdBQUcsV0FBYjtFQUNBLElBQU1DLFNBQU8sR0FBRyxPQUFoQjtFQUNBLElBQU1DLFVBQVEsR0FBRyxjQUFqQjtFQUNBLElBQU1DLFdBQVMsU0FBT0QsVUFBdEI7RUFDQSxJQUFNRSxjQUFZLEdBQUcsV0FBckI7RUFDQSxJQUFNQyxvQkFBa0IsR0FBR3JGLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLENBQTNCO0VBRUEsSUFBTTgzQix3QkFBd0IsR0FBRyxlQUFqQztFQUNBLElBQU1uMUIsbUJBQWlCLEdBQUcsUUFBMUI7RUFFQSxJQUFNbzFCLGNBQWMsZ0JBQWM1M0IsV0FBbEM7RUFDQSxJQUFNNjNCLFlBQVksY0FBWTczQixXQUE5QjtFQUNBLElBQU00QyxtQkFBbUIsWUFBVTVDLFdBQVYsR0FBc0JDLGNBQS9DO0VBRUEsSUFBTTYzQixhQUFhLEdBQUcsUUFBdEI7RUFDQSxJQUFNQyxlQUFlLEdBQUcsVUFBeEI7RUFFQSxJQUFNQyxpQkFBaUIsR0FBRyxxQkFBMUI7RUFDQSxJQUFNQyx5QkFBdUIsR0FBRyxtQkFBaEM7RUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxXQUEzQjtFQUNBLElBQU1DLGtCQUFrQixHQUFHLFdBQTNCO0VBQ0EsSUFBTUMsbUJBQW1CLEdBQUcsa0JBQTVCO0VBQ0EsSUFBTUMsbUJBQWlCLEdBQUcsV0FBMUI7RUFDQSxJQUFNQyx1QkFBdUIsR0FBRyxnQkFBaEM7RUFDQSxJQUFNQywwQkFBd0IsR0FBRyxrQkFBakM7RUFFQSxJQUFNdHhCLFNBQU8sR0FBRztJQUNka1IsTUFBTSxFQUFFLEVBRE07SUFFZHFnQixNQUFNLEVBQUUsTUFGTTtJQUdkMTlCLE1BQU0sRUFBRTtFQUhNLENBQWhCO0VBTUEsSUFBTTBNLGFBQVcsR0FBRztJQUNsQjJRLE1BQU0sRUFBRSxRQURVO0lBRWxCcWdCLE1BQU0sRUFBRSxRQUZVO0lBR2xCMTlCLE1BQU0sRUFBRTtFQUhVLENBQXBCO0VBTUE7Ozs7TUFJTTI5QjtJQUNKLG1CQUFZajhCLE9BQVosRUFBcUJ3QixNQUFyQixFQUE2QjtNQUFBO01BQzNCLEtBQUsyQyxRQUFMLEdBQWdCbkUsT0FBaEI7TUFDQSxLQUFLazhCLGNBQUwsR0FBc0JsOEIsT0FBTyxDQUFDK0gsT0FBUixLQUFvQixNQUFwQixHQUE2QkMsTUFBN0IsR0FBc0NoSSxPQUE1RDtNQUNBLEtBQUs2TCxPQUFMLEdBQWUsS0FBS0MsVUFBTCxDQUFnQnRLLE1BQWhCLENBQWY7TUFDQSxLQUFLeVEsU0FBTCxHQUFvQixLQUFLcEcsT0FBTCxDQUFhdk4sTUFBaEIsU0FBMEJvOUIsa0JBQTFCLFVBQ1EsS0FBSzd2QixPQUFMLENBQWF2TixNQURyQixTQUMrQnM5QixtQkFEL0IsV0FFUSxLQUFLL3ZCLE9BQUwsQ0FBYXZOLE1BRnJCLFNBRStCdzlCLHVCQUYvQixDQUFqQjtNQUdBLEtBQUtLLFFBQUwsR0FBZ0IsRUFBaEI7TUFDQSxLQUFLQyxRQUFMLEdBQWdCLEVBQWhCO01BQ0EsS0FBS0MsYUFBTCxHQUFxQixJQUFyQjtNQUNBLEtBQUtDLGFBQUwsR0FBcUIsQ0FBckI7TUFFQWorQixxQkFBQyxDQUFDLEtBQUs2OUIsY0FBTixDQUFELENBQXVCcjJCLEVBQXZCLENBQTBCdzFCLFlBQTFCLEVBQXdDLGVBQUs7UUFBQSxPQUFJajhCLEtBQUksQ0FBQ205QixRQUFMLENBQWNuK0IsS0FBZCxDQUFKO01BQUEsQ0FBN0M7TUFFQSxLQUFLbytCLE9BQUw7TUFDQSxLQUFLRCxRQUFMO0lBQ0Q7Ozs7SUFXRDtXQUNBQyw2QkFBVTtNQUFBO01BQ1IsSUFBTUMsVUFBVSxHQUFHLEtBQUtQLGNBQUwsS0FBd0IsS0FBS0EsY0FBTCxDQUFvQmwwQixNQUE1QyxHQUNqQnN6QixhQURpQixHQUNEQyxlQURsQjtNQUdBLElBQU1tQixZQUFZLEdBQUcsS0FBSzd3QixPQUFMLENBQWFtd0IsTUFBYixLQUF3QixNQUF4QixHQUNuQlMsVUFEbUIsR0FDTixLQUFLNXdCLE9BQUwsQ0FBYW13QixNQUQ1QjtNQUdBLElBQU1XLFVBQVUsR0FBR0QsWUFBWSxLQUFLbkIsZUFBakIsR0FDakIsS0FBS3FCLGFBQUwsRUFEaUIsR0FDTSxDQUR6QjtNQUdBLEtBQUtULFFBQUwsR0FBZ0IsRUFBaEI7TUFDQSxLQUFLQyxRQUFMLEdBQWdCLEVBQWhCO01BRUEsS0FBS0UsYUFBTCxHQUFxQixLQUFLTyxnQkFBTCxFQUFyQjtNQUVBLElBQU1DLE9BQU8sR0FBRyxHQUFHNTBCLEtBQUgsQ0FBU3JLLElBQVQsQ0FBY2dDLFFBQVEsQ0FBQ3NJLGdCQUFULENBQTBCLEtBQUs4SixTQUEvQixDQUFkLENBQWhCO01BRUE2cUIsT0FBTyxDQUNKOWYsR0FESCxDQUNPLGlCQUFPLEVBQUk7UUFDZCxJQUFJMWUsTUFBSjtRQUNBLElBQU15K0IsY0FBYyxHQUFHOTlCLElBQUksQ0FBQ2Msc0JBQUwsQ0FBNEJDLE9BQTVCLENBQXZCO1FBRUEsSUFBSSs4QixjQUFKLEVBQW9CO1VBQ2xCeitCLE1BQU0sR0FBR3VCLFFBQVEsQ0FBQ1EsYUFBVCxDQUF1QjA4QixjQUF2QixDQUFUO1FBQ0Q7UUFFRCxJQUFJeitCLE1BQUosRUFBWTtVQUNWLElBQU0wK0IsU0FBUyxHQUFHMStCLE1BQU0sQ0FBQzhVLHFCQUFQLEVBQWxCO1VBQ0EsSUFBSTRwQixTQUFTLENBQUM5akIsS0FBVixJQUFtQjhqQixTQUFTLENBQUMvakIsTUFBakMsRUFBeUM7WUFDdkM7WUFDQSxPQUFPLENBQ0w1YSxxQkFBQyxDQUFDQyxNQUFELENBQUQsQ0FBVW8rQixZQUFWLElBQTBCdGtCLEdBQTFCLEdBQWdDdWtCLFVBRDNCLEVBRUxJLGNBRkssQ0FBUDtVQUlEO1FBQ0Y7UUFFRCxPQUFPLElBQVA7TUFDRCxDQXJCSCxFQXNCR2hyQixNQXRCSCxDQXNCVSxjQUFJO1FBQUEsT0FBSTRiLElBQUo7TUFBQSxDQXRCZCxFQXVCR3pRLElBdkJILENBdUJRLFVBQUNDLENBQUQsRUFBSUMsQ0FBSjtRQUFBLE9BQVVELENBQUMsQ0FBQyxDQUFELENBQUQsR0FBT0MsQ0FBQyxDQUFDLENBQUQsQ0FBbEI7TUFBQSxDQXZCUixFQXdCR3FDLE9BeEJILENBd0JXLGNBQUksRUFBSTtRQUNmOVIsTUFBSSxDQUFDd3VCLFFBQUwsQ0FBY2pxQixJQUFkLENBQW1CeWIsSUFBSSxDQUFDLENBQUQsQ0FBdkI7UUFDQWhnQixNQUFJLENBQUN5dUIsUUFBTCxDQUFjbHFCLElBQWQsQ0FBbUJ5YixJQUFJLENBQUMsQ0FBRCxDQUF2QjtNQUNELENBM0JIO0lBNEJEO1dBRURocEIsNkJBQVU7TUFDUnRHLHFCQUFDLENBQUN1RyxVQUFGLENBQWEsS0FBS1QsUUFBbEIsRUFBNEJaLFVBQTVCO01BQ0FsRixxQkFBQyxDQUFDLEtBQUs2OUIsY0FBTixDQUFELENBQXVCM3VCLEdBQXZCLENBQTJCL0osV0FBM0I7TUFFQSxLQUFLVyxRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBSyszQixjQUFMLEdBQXNCLElBQXRCO01BQ0EsS0FBS3J3QixPQUFMLEdBQWUsSUFBZjtNQUNBLEtBQUtvRyxTQUFMLEdBQWlCLElBQWpCO01BQ0EsS0FBS2txQixRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBS0MsUUFBTCxHQUFnQixJQUFoQjtNQUNBLEtBQUtDLGFBQUwsR0FBcUIsSUFBckI7TUFDQSxLQUFLQyxhQUFMLEdBQXFCLElBQXJCO0lBQ0Q7SUFBQTs7V0FHRHh3QixpQ0FBV3RLLE1BQVgsRUFBbUI7TUFDakJBLE1BQU0sa0JBQ0RpSixTQURDLEVBRUEsUUFBT2pKLE1BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE1BQTlCLEdBQXVDQSxNQUF2QyxHQUFnRCxFQUZoRCxDQUFOO01BS0EsSUFBSSxPQUFPQSxNQUFNLENBQUNsRCxNQUFkLEtBQXlCLFFBQXpCLElBQXFDVyxJQUFJLENBQUNtQyxTQUFMLENBQWVJLE1BQU0sQ0FBQ2xELE1BQXRCLENBQXpDLEVBQXdFO1FBQ3RFLElBQUlxVCxFQUFFLEdBQUd0VCxxQkFBQyxDQUFDbUQsTUFBTSxDQUFDbEQsTUFBUixDQUFELENBQWlCeVUsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBVDtRQUNBLElBQUksQ0FBQ3BCLEVBQUwsRUFBUztVQUNQQSxFQUFFLEdBQUcxUyxJQUFJLENBQUNRLE1BQUwsQ0FBWTRELE1BQVosQ0FBTDtVQUNBaEYscUJBQUMsQ0FBQ21ELE1BQU0sQ0FBQ2xELE1BQVIsQ0FBRCxDQUFpQnlVLElBQWpCLENBQXNCLElBQXRCLEVBQTRCcEIsRUFBNUI7UUFDRDtRQUVEblEsTUFBTSxDQUFDbEQsTUFBUCxTQUFvQnFULEVBQXBCO01BQ0Q7TUFFRDFTLElBQUksQ0FBQ3FDLGVBQUwsQ0FBcUIrQixNQUFyQixFQUEyQjdCLE1BQTNCLEVBQW1Dd0osYUFBbkM7TUFFQSxPQUFPeEosTUFBUDtJQUNEO1dBRURvN0IseUNBQWdCO01BQ2QsT0FBTyxLQUFLVixjQUFMLEtBQXdCbDBCLE1BQXhCLEdBQ0wsS0FBS2swQixjQUFMLENBQW9CZSxXQURmLEdBQzZCLEtBQUtmLGNBQUwsQ0FBb0Jqa0IsU0FEeEQ7SUFFRDtXQUVENGtCLCtDQUFtQjtNQUNqQixPQUFPLEtBQUtYLGNBQUwsQ0FBb0IvTCxZQUFwQixJQUFvQ3h3QixJQUFJLENBQUNvWixHQUFMLENBQ3pDbFosUUFBUSxDQUFDMFYsSUFBVCxDQUFjNGEsWUFEMkIsRUFFekN0d0IsUUFBUSxDQUFDeUMsZUFBVCxDQUF5QjZ0QixZQUZnQixDQUEzQztJQUlEO1dBRUQrTSwrQ0FBbUI7TUFDakIsT0FBTyxLQUFLaEIsY0FBTCxLQUF3QmwwQixNQUF4QixHQUNMQSxNQUFNLENBQUMwVCxXQURGLEdBQ2dCLEtBQUt3Z0IsY0FBTCxDQUFvQjlvQixxQkFBcEIsR0FBNEM2RixNQURuRTtJQUVEO1dBRURzakIsK0JBQVc7TUFDVCxJQUFNdGtCLFNBQVMsR0FBRyxLQUFLMmtCLGFBQUwsS0FBdUIsS0FBSy93QixPQUFMLENBQWE4UCxNQUF0RDtNQUNBLElBQU13VSxZQUFZLEdBQUcsS0FBSzBNLGdCQUFMLEVBQXJCO01BQ0EsSUFBTU0sU0FBUyxHQUFHLEtBQUt0eEIsT0FBTCxDQUFhOFAsTUFBYixHQUFzQndVLFlBQXRCLEdBQXFDLEtBQUsrTSxnQkFBTCxFQUF2RDtNQUVBLElBQUksS0FBS1osYUFBTCxLQUF1Qm5NLFlBQTNCLEVBQXlDO1FBQ3ZDLEtBQUtxTSxPQUFMO01BQ0Q7TUFFRCxJQUFJdmtCLFNBQVMsSUFBSWtsQixTQUFqQixFQUE0QjtRQUMxQixJQUFNNytCLE1BQU0sR0FBRyxLQUFLODlCLFFBQUwsQ0FBYyxLQUFLQSxRQUFMLENBQWM5ekIsTUFBZCxHQUF1QixDQUFyQyxDQUFmO1FBRUEsSUFBSSxLQUFLK3pCLGFBQUwsS0FBdUIvOUIsTUFBM0IsRUFBbUM7VUFDakMsS0FBSzgrQixTQUFMLENBQWU5K0IsTUFBZjtRQUNEO1FBRUQ7TUFDRDtNQUVELElBQUksS0FBSys5QixhQUFMLElBQXNCcGtCLFNBQVMsR0FBRyxLQUFLa2tCLFFBQUwsQ0FBYyxDQUFkLENBQWxDLElBQXNELEtBQUtBLFFBQUwsQ0FBYyxDQUFkLElBQW1CLENBQTdFLEVBQWdGO1FBQzlFLEtBQUtFLGFBQUwsR0FBcUIsSUFBckI7UUFDQSxLQUFLZ0IsTUFBTDtRQUNBO01BQ0Q7TUFFRCxLQUFLLElBQUlqMUIsQ0FBQyxHQUFHLEtBQUsrekIsUUFBTCxDQUFjN3pCLE1BQTNCLEVBQW1DRixDQUFDLEVBQXBDLEdBQXlDO1FBQ3ZDLElBQU1rMUIsY0FBYyxHQUFHLEtBQUtqQixhQUFMLEtBQXVCLEtBQUtELFFBQUwsQ0FBY2gwQixDQUFkLENBQXZCLElBQ25CNlAsU0FBUyxJQUFJLEtBQUtra0IsUUFBTCxDQUFjL3pCLENBQWQsQ0FETSxLQUVsQixPQUFPLEtBQUsrekIsUUFBTCxDQUFjL3pCLENBQUMsR0FBRyxDQUFsQixDQUFQLEtBQWdDLFdBQWhDLElBQ0c2UCxTQUFTLEdBQUcsS0FBS2trQixRQUFMLENBQWMvekIsQ0FBQyxHQUFHLENBQWxCLENBSEcsQ0FBdkI7UUFLQSxJQUFJazFCLGNBQUosRUFBb0I7VUFDbEIsS0FBS0YsU0FBTCxDQUFlLEtBQUtoQixRQUFMLENBQWNoMEIsQ0FBZCxDQUFmO1FBQ0Q7TUFDRjtJQUNGO1dBRURnMUIsK0JBQVU5K0IsTUFBVixFQUFrQjtNQUNoQixLQUFLKzlCLGFBQUwsR0FBcUIvOUIsTUFBckI7TUFFQSxLQUFLKytCLE1BQUw7TUFFQSxJQUFNRSxPQUFPLEdBQUcsS0FBS3RyQixTQUFMLENBQ2JuUixLQURhLENBQ1AsR0FETyxFQUVia2MsR0FGYSxDQUVULGtCQUFRO1FBQUEsT0FBTy9jLFFBQVAsdUJBQWdDM0IsTUFBaEMsWUFBNEMyQixRQUE1QyxnQkFBOEQzQixNQUE5RDtNQUFBLENBRkMsQ0FBaEI7TUFJQSxJQUFNay9CLEtBQUssR0FBR24vQixxQkFBQyxDQUFDLEdBQUc2SixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQm8xQixPQUFPLENBQUMzQyxJQUFSLENBQWEsR0FBYixDQUExQixDQUFkLENBQUQsQ0FBZjtNQUVBLElBQUk0QyxLQUFLLENBQUN0NEIsUUFBTixDQUFlaTJCLHdCQUFmLENBQUosRUFBOEM7UUFDNUNxQyxLQUFLLENBQUMxNEIsT0FBTixDQUFjKzJCLG1CQUFkLEVBQ0cvYyxJQURILENBQ1FpZCwwQkFEUixFQUVHbnNCLFFBRkgsQ0FFWTVKLG1CQUZaO1FBR0F3M0IsS0FBSyxDQUFDNXRCLFFBQU4sQ0FBZTVKLG1CQUFmO01BQ0QsQ0FMRCxNQUtPO1FBQ0w7UUFDQXczQixLQUFLLENBQUM1dEIsUUFBTixDQUFlNUosbUJBQWYsRUFGSztRQUlMOztRQUNBdzNCLEtBQUssQ0FBQ0MsT0FBTixDQUFjaEMseUJBQWQsRUFDRzl1QixJQURILENBQ1crdUIsa0JBRFgsVUFDa0NFLG1CQURsQyxFQUVHaHNCLFFBRkgsQ0FFWTVKLG1CQUZaLEVBTEs7O1FBU0x3M0IsS0FBSyxDQUFDQyxPQUFOLENBQWNoQyx5QkFBZCxFQUNHOXVCLElBREgsQ0FDUWd2QixrQkFEUixFQUVHaHNCLFFBRkgsQ0FFWStyQixrQkFGWixFQUdHOXJCLFFBSEgsQ0FHWTVKLG1CQUhaO01BSUQ7TUFFRDNILHFCQUFDLENBQUMsS0FBSzY5QixjQUFOLENBQUQsQ0FBdUJqN0IsT0FBdkIsQ0FBK0JtNkIsY0FBL0IsRUFBK0M7UUFDN0Nsc0IsYUFBYSxFQUFFNVE7TUFEOEIsQ0FBL0M7SUFHRDtXQUVEKytCLDJCQUFTO01BQ1AsR0FBR24xQixLQUFILENBQVNySyxJQUFULENBQWNnQyxRQUFRLENBQUNzSSxnQkFBVCxDQUEwQixLQUFLOEosU0FBL0IsQ0FBZCxFQUNHRixNQURILENBQ1UsY0FBSTtRQUFBLE9BQUk0RSxJQUFJLENBQUN2UCxTQUFMLENBQWVDLFFBQWYsQ0FBd0JyQixtQkFBeEIsQ0FBSjtNQUFBLENBRGQsRUFFR3laLE9BRkgsQ0FFVyxjQUFJO1FBQUEsT0FBSTlJLElBQUksQ0FBQ3ZQLFNBQUwsQ0FBZS9CLE1BQWYsQ0FBc0JXLG1CQUF0QixDQUFKO01BQUEsQ0FGZjtJQUdEO0lBQUE7O2NBR01WLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDO01BQzlCLE9BQU8sS0FBSytELElBQUwsQ0FBVSxZQUFZO1FBQzNCLElBQUlFLElBQUksR0FBR3BILHFCQUFDLENBQUMsSUFBRCxDQUFELENBQVFvSCxJQUFSLENBQWFsQyxVQUFiLENBQVg7UUFDQSxJQUFNc0ksT0FBTyxHQUFHLFFBQU9ySyxNQUFQLE1BQWtCLFFBQWxCLElBQThCQSxNQUE5QztRQUVBLElBQUksQ0FBQ2lFLElBQUwsRUFBVztVQUNUQSxJQUFJLEdBQUcsSUFBSXcyQixTQUFKLENBQWMsSUFBZCxFQUFvQnB3QixPQUFwQixDQUFQO1VBQ0F4TixxQkFBQyxDQUFDLElBQUQsQ0FBRCxDQUFRb0gsSUFBUixDQUFhbEMsVUFBYixFQUF1QmtDLElBQXZCO1FBQ0Q7UUFFRCxJQUFJLE9BQU9qRSxNQUFQLEtBQWtCLFFBQXRCLEVBQWdDO1VBQzlCLElBQUksT0FBT2lFLElBQUksQ0FBQ2pFLE1BQUQsQ0FBWCxLQUF3QixXQUE1QixFQUF5QztZQUN2QyxNQUFNLElBQUlxQixTQUFKLHdCQUFrQ3JCLE1BQWxDLFFBQU47VUFDRDtVQUVEaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFKO1FBQ0Q7TUFDRixDQWhCTSxDQUFQO0lBaUJEOzs7V0EvTUQsZUFBcUI7UUFDbkIsT0FBTzhCLFNBQVA7TUFDRDs7O1dBRUQsZUFBcUI7UUFDbkIsT0FBT21ILFNBQVA7TUFDRDs7OztFQTRNSDs7OztFQUlBcE0scUJBQUMsQ0FBQzJKLE1BQUQsQ0FBRCxDQUFVbkMsRUFBVixDQUFhTyxtQkFBYixFQUFrQyxZQUFNO0lBQ3RDLElBQU1zM0IsVUFBVSxHQUFHLEdBQUd4MUIsS0FBSCxDQUFTckssSUFBVCxDQUFjZ0MsUUFBUSxDQUFDc0ksZ0JBQVQsQ0FBMEJxekIsaUJBQTFCLENBQWQsQ0FBbkI7SUFDQSxJQUFNbUMsZ0JBQWdCLEdBQUdELFVBQVUsQ0FBQ3AxQixNQUFwQztJQUVBLEtBQUssSUFBSUYsQ0FBQyxHQUFHdTFCLGdCQUFiLEVBQStCdjFCLENBQUMsRUFBaEMsR0FBcUM7TUFDbkMsSUFBTXcxQixJQUFJLEdBQUd2L0IscUJBQUMsQ0FBQ3EvQixVQUFVLENBQUN0MUIsQ0FBRCxDQUFYLENBQWQ7TUFDQTZ6QixTQUFTLENBQUMzMkIsZ0JBQVYsQ0FBMkJ6SCxJQUEzQixDQUFnQysvQixJQUFoQyxFQUFzQ0EsSUFBSSxDQUFDbjRCLElBQUwsRUFBdEM7SUFDRDtFQUNGLENBUkQ7RUFVQTs7OztFQUlBcEgscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYTQ0QixTQUFTLENBQUMzMkIsZ0JBQXZCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5Qm0yQixTQUF6QjtFQUNBNTlCLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU91NEIsU0FBUyxDQUFDMzJCLGdCQUFqQjtFQUNELENBSEQ7O0VDeFNBOzs7O0VBSUEsSUFBTWpDLE1BQUksR0FBRyxLQUFiO0VBQ0EsSUFBTUMsU0FBTyxHQUFHLE9BQWhCO0VBQ0EsSUFBTUMsVUFBUSxHQUFHLFFBQWpCO0VBQ0EsSUFBTUMsV0FBUyxTQUFPRCxVQUF0QjtFQUNBLElBQU1FLFlBQVksR0FBRyxXQUFyQjtFQUNBLElBQU1DLG9CQUFrQixHQUFHckYscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsQ0FBM0I7RUFFQSxJQUFNdzZCLHdCQUF3QixHQUFHLGVBQWpDO0VBQ0EsSUFBTTczQixpQkFBaUIsR0FBRyxRQUExQjtFQUNBLElBQU0wa0IsbUJBQW1CLEdBQUcsVUFBNUI7RUFDQSxJQUFNOW1CLGlCQUFlLEdBQUcsTUFBeEI7RUFDQSxJQUFNQyxpQkFBZSxHQUFHLE1BQXhCO0VBRUEsSUFBTXdOLFlBQVUsWUFBVTdOLFdBQTFCO0VBQ0EsSUFBTThOLGNBQVksY0FBWTlOLFdBQTlCO0VBQ0EsSUFBTTJOLFlBQVUsWUFBVTNOLFdBQTFCO0VBQ0EsSUFBTTROLGFBQVcsYUFBVzVOLFdBQTVCO0VBQ0EsSUFBTVEsb0JBQW9CLGFBQVdSLFdBQVgsR0FBdUJDLFlBQWpEO0VBRUEsSUFBTW80QixpQkFBaUIsR0FBRyxXQUExQjtFQUNBLElBQU1KLHVCQUF1QixHQUFHLG1CQUFoQztFQUNBLElBQU0vMEIsZUFBZSxHQUFHLFNBQXhCO0VBQ0EsSUFBTW8zQixrQkFBa0IsR0FBRyxnQkFBM0I7RUFDQSxJQUFNdjNCLG9CQUFvQixHQUFHLGlFQUE3QjtFQUNBLElBQU13MUIsd0JBQXdCLEdBQUcsa0JBQWpDO0VBQ0EsSUFBTWdDLDhCQUE4QixHQUFHLDBCQUF2QztFQUVBOzs7O01BSU1DO0lBQ0osYUFBWWgrQixPQUFaLEVBQXFCO01BQ25CLEtBQUttRSxRQUFMLEdBQWdCbkUsT0FBaEI7SUFDRDs7OztJQU9EO1dBQ0F1Uyx1QkFBTztNQUFBO01BQ0wsSUFBSSxLQUFLcE8sUUFBTCxDQUFjeEIsVUFBZCxJQUNBLEtBQUt3QixRQUFMLENBQWN4QixVQUFkLENBQXlCdEIsUUFBekIsS0FBc0M0VixJQUFJLENBQUNxWixZQUQzQyxJQUVBanlCLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUFpQmUsUUFBakIsQ0FBMEJjLGlCQUExQixDQUZBLElBR0EzSCxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJlLFFBQWpCLENBQTBCd2xCLG1CQUExQixDQUhKLEVBR29EO1FBQ2xEO01BQ0Q7TUFFRCxJQUFJcHNCLE1BQUo7TUFDQSxJQUFJMi9CLFFBQUo7TUFDQSxJQUFNQyxXQUFXLEdBQUc3L0IscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCVyxPQUFqQixDQUF5QjIyQix1QkFBekIsRUFBa0QsQ0FBbEQsQ0FBcEI7TUFDQSxJQUFNeDdCLFFBQVEsR0FBR2hCLElBQUksQ0FBQ2Msc0JBQUwsQ0FBNEIsS0FBS29FLFFBQWpDLENBQWpCO01BRUEsSUFBSSs1QixXQUFKLEVBQWlCO1FBQ2YsSUFBTUMsWUFBWSxHQUFHRCxXQUFXLENBQUM5b0IsUUFBWixLQUF5QixJQUF6QixJQUFpQzhvQixXQUFXLENBQUM5b0IsUUFBWixLQUF5QixJQUExRCxHQUFpRTBvQixrQkFBakUsR0FBc0ZwM0IsZUFBM0c7UUFDQXUzQixRQUFRLEdBQUc1L0IscUJBQUMsQ0FBQysvQixTQUFGLENBQVkvL0IscUJBQUMsQ0FBQzYvQixXQUFELENBQUQsQ0FBZXBmLElBQWYsQ0FBb0JxZixZQUFwQixDQUFaLENBQVg7UUFDQUYsUUFBUSxHQUFHQSxRQUFRLENBQUNBLFFBQVEsQ0FBQzMxQixNQUFULEdBQWtCLENBQW5CLENBQW5CO01BQ0Q7TUFFRCxJQUFNeWtCLFNBQVMsR0FBRzF1QixxQkFBQyxDQUFDMkcsS0FBRixDQUFRcU0sWUFBUixFQUFvQjtRQUNwQ25DLGFBQWEsRUFBRSxLQUFLL0s7TUFEZ0IsQ0FBcEIsQ0FBbEI7TUFJQSxJQUFNdW9CLFNBQVMsR0FBR3J1QixxQkFBQyxDQUFDMkcsS0FBRixDQUFRbU0sWUFBUixFQUFvQjtRQUNwQ2pDLGFBQWEsRUFBRSt1QjtNQURxQixDQUFwQixDQUFsQjtNQUlBLElBQUlBLFFBQUosRUFBYztRQUNaNS9CLHFCQUFDLENBQUM0L0IsUUFBRCxDQUFELENBQVloOUIsT0FBWixDQUFvQjhyQixTQUFwQjtNQUNEO01BRUQxdUIscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJ5ckIsU0FBekI7TUFFQSxJQUFJQSxTQUFTLENBQUNqb0Isa0JBQVYsTUFDQXNvQixTQUFTLENBQUN0b0Isa0JBQVYsRUFESixFQUNvQztRQUNsQztNQUNEO01BRUQsSUFBSXhFLFFBQUosRUFBYztRQUNaM0IsTUFBTSxHQUFHdUIsUUFBUSxDQUFDUSxhQUFULENBQXVCSixRQUF2QixDQUFUO01BQ0Q7TUFFRCxLQUFLbTlCLFNBQUwsQ0FDRSxLQUFLajVCLFFBRFAsRUFFRSs1QixXQUZGO01BS0EsSUFBTWpyQixRQUFRLEdBQUcsU0FBWEEsUUFBVyxHQUFNO1FBQ3JCLElBQU1vckIsV0FBVyxHQUFHaGdDLHFCQUFDLENBQUMyRyxLQUFGLENBQVFzTSxjQUFSLEVBQXNCO1VBQ3hDcEMsYUFBYSxFQUFFOVAsS0FBSSxDQUFDK0U7UUFEb0IsQ0FBdEIsQ0FBcEI7UUFJQSxJQUFNc3NCLFVBQVUsR0FBR3B5QixxQkFBQyxDQUFDMkcsS0FBRixDQUFRb00sYUFBUixFQUFxQjtVQUN0Q2xDLGFBQWEsRUFBRSt1QjtRQUR1QixDQUFyQixDQUFuQjtRQUlBNS9CLHFCQUFDLENBQUM0L0IsUUFBRCxDQUFELENBQVloOUIsT0FBWixDQUFvQm85QixXQUFwQjtRQUNBaGdDLHFCQUFDLENBQUNlLEtBQUksQ0FBQytFLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCd3ZCLFVBQXpCO01BQ0QsQ0FYRDtNQWFBLElBQUlueUIsTUFBSixFQUFZO1FBQ1YsS0FBSzgrQixTQUFMLENBQWU5K0IsTUFBZixFQUF1QkEsTUFBTSxDQUFDcUUsVUFBOUIsRUFBMENzUSxRQUExQztNQUNELENBRkQsTUFFTztRQUNMQSxRQUFRO01BQ1Q7SUFDRjtXQUVEdE8sNkJBQVU7TUFDUnRHLHFCQUFDLENBQUN1RyxVQUFGLENBQWEsS0FBS1QsUUFBbEIsRUFBNEJaLFVBQTVCO01BQ0EsS0FBS1ksUUFBTCxHQUFnQixJQUFoQjtJQUNEO0lBQUE7O1dBR0RpNUIsK0JBQVVwOUIsT0FBVixFQUFtQisyQixTQUFuQixFQUE4QnBWLFFBQTlCLEVBQXdDO01BQUE7TUFDdEMsSUFBTTJjLGNBQWMsR0FBR3ZILFNBQVMsS0FBS0EsU0FBUyxDQUFDM2hCLFFBQVYsS0FBdUIsSUFBdkIsSUFBK0IyaEIsU0FBUyxDQUFDM2hCLFFBQVYsS0FBdUIsSUFBM0QsQ0FBVCxHQUNyQi9XLHFCQUFDLENBQUMwNEIsU0FBRCxDQUFELENBQWFqWSxJQUFiLENBQWtCZ2Ysa0JBQWxCLENBRHFCLEdBRXJCei9CLHFCQUFDLENBQUMwNEIsU0FBRCxDQUFELENBQWFwbkIsUUFBYixDQUFzQmpKLGVBQXRCLENBRkY7TUFJQSxJQUFNNjNCLE1BQU0sR0FBR0QsY0FBYyxDQUFDLENBQUQsQ0FBN0I7TUFDQSxJQUFNL3FCLGVBQWUsR0FBR29PLFFBQVEsSUFBSzRjLE1BQU0sSUFBSWxnQyxxQkFBQyxDQUFDa2dDLE1BQUQsQ0FBRCxDQUFVcjVCLFFBQVYsQ0FBbUJ0QixpQkFBbkIsQ0FBL0M7TUFDQSxJQUFNcVAsUUFBUSxHQUFHLFNBQVhBLFFBQVc7UUFBQSxPQUFNdEYsTUFBSSxDQUFDNndCLG1CQUFMLENBQ3JCeCtCLE9BRHFCLEVBRXJCdStCLE1BRnFCLEVBR3JCNWMsUUFIcUIsQ0FBTjtNQUFBLENBQWpCO01BTUEsSUFBSTRjLE1BQU0sSUFBSWhyQixlQUFkLEVBQStCO1FBQzdCLElBQU0vUyxrQkFBa0IsR0FBR3ZCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDZytCLE1BQXRDLENBQTNCO1FBRUFsZ0MscUJBQUMsQ0FBQ2tnQyxNQUFELENBQUQsQ0FDR3Q1QixXQURILENBQ2VwQixpQkFEZixFQUVHN0UsR0FGSCxDQUVPQyxJQUFJLENBQUMxQixjQUZaLEVBRTRCMFYsUUFGNUIsRUFHRzFULG9CQUhILENBR3dCaUIsa0JBSHhCO01BSUQsQ0FQRCxNQU9PO1FBQ0x5UyxRQUFRO01BQ1Q7SUFDRjtXQUVEdXJCLG1EQUFvQngrQixPQUFwQixFQUE2QnUrQixNQUE3QixFQUFxQzVjLFFBQXJDLEVBQStDO01BQzdDLElBQUk0YyxNQUFKLEVBQVk7UUFDVmxnQyxxQkFBQyxDQUFDa2dDLE1BQUQsQ0FBRCxDQUFVdDVCLFdBQVYsQ0FBc0JlLGlCQUF0QjtRQUVBLElBQU15NEIsYUFBYSxHQUFHcGdDLHFCQUFDLENBQUNrZ0MsTUFBTSxDQUFDNTdCLFVBQVIsQ0FBRCxDQUFxQm1jLElBQXJCLENBQ3BCaWYsOEJBRG9CLEVBRXBCLENBRm9CLENBQXRCO1FBSUEsSUFBSVUsYUFBSixFQUFtQjtVQUNqQnBnQyxxQkFBQyxDQUFDb2dDLGFBQUQsQ0FBRCxDQUFpQng1QixXQUFqQixDQUE2QmUsaUJBQTdCO1FBQ0Q7UUFFRCxJQUFJdTRCLE1BQU0sQ0FBQ3IrQixZQUFQLENBQW9CLE1BQXBCLE1BQWdDLEtBQXBDLEVBQTJDO1VBQ3pDcStCLE1BQU0sQ0FBQzkyQixZQUFQLENBQW9CLGVBQXBCLEVBQXFDLEtBQXJDO1FBQ0Q7TUFDRjtNQUVEcEoscUJBQUMsQ0FBQzJCLE9BQUQsQ0FBRCxDQUFXNFAsUUFBWCxDQUFvQjVKLGlCQUFwQjtNQUNBLElBQUloRyxPQUFPLENBQUNFLFlBQVIsQ0FBcUIsTUFBckIsTUFBaUMsS0FBckMsRUFBNEM7UUFDMUNGLE9BQU8sQ0FBQ3lILFlBQVIsQ0FBcUIsZUFBckIsRUFBc0MsSUFBdEM7TUFDRDtNQUVEeEksSUFBSSxDQUFDOEIsTUFBTCxDQUFZZixPQUFaO01BRUEsSUFBSUEsT0FBTyxDQUFDb0gsU0FBUixDQUFrQkMsUUFBbEIsQ0FBMkJ6RCxpQkFBM0IsQ0FBSixFQUFpRDtRQUMvQzVELE9BQU8sQ0FBQ29ILFNBQVIsQ0FBa0JtQixHQUFsQixDQUFzQjFFLGlCQUF0QjtNQUNEO01BRUQsSUFBSWdCLE1BQU0sR0FBRzdFLE9BQU8sQ0FBQzJDLFVBQXJCO01BQ0EsSUFBSWtDLE1BQU0sSUFBSUEsTUFBTSxDQUFDdVEsUUFBUCxLQUFvQixJQUFsQyxFQUF3QztRQUN0Q3ZRLE1BQU0sR0FBR0EsTUFBTSxDQUFDbEMsVUFBaEI7TUFDRDtNQUVELElBQUlrQyxNQUFNLElBQUl4RyxxQkFBQyxDQUFDd0csTUFBRCxDQUFELENBQVVLLFFBQVYsQ0FBbUIyNEIsd0JBQW5CLENBQWQsRUFBNEQ7UUFDMUQsSUFBTWEsZUFBZSxHQUFHcmdDLHFCQUFDLENBQUMyQixPQUFELENBQUQsQ0FBVzhFLE9BQVgsQ0FBbUIrMkIsaUJBQW5CLEVBQXNDLENBQXRDLENBQXhCO1FBRUEsSUFBSTZDLGVBQUosRUFBcUI7VUFDbkIsSUFBTUMsa0JBQWtCLEdBQUcsR0FBR3oyQixLQUFILENBQVNySyxJQUFULENBQWM2Z0MsZUFBZSxDQUFDdjJCLGdCQUFoQixDQUFpQzR6Qix3QkFBakMsQ0FBZCxDQUEzQjtVQUVBMTlCLHFCQUFDLENBQUNzZ0Msa0JBQUQsQ0FBRCxDQUFzQi91QixRQUF0QixDQUErQjVKLGlCQUEvQjtRQUNEO1FBRURoRyxPQUFPLENBQUN5SCxZQUFSLENBQXFCLGVBQXJCLEVBQXNDLElBQXRDO01BQ0Q7TUFFRCxJQUFJa2EsUUFBSixFQUFjO1FBQ1pBLFFBQVE7TUFDVDtJQUNGO0lBQUE7O1FBR01yYyxtQkFBUCwwQkFBd0I5RCxNQUF4QixFQUFnQztNQUM5QixPQUFPLEtBQUsrRCxJQUFMLENBQVUsWUFBWTtRQUMzQixJQUFNcTVCLEtBQUssR0FBR3ZnQyxxQkFBQyxDQUFDLElBQUQsQ0FBZjtRQUNBLElBQUlvSCxJQUFJLEdBQUdtNUIsS0FBSyxDQUFDbjVCLElBQU4sQ0FBV2xDLFVBQVgsQ0FBWDtRQUVBLElBQUksQ0FBQ2tDLElBQUwsRUFBVztVQUNUQSxJQUFJLEdBQUcsSUFBSXU0QixHQUFKLENBQVEsSUFBUixDQUFQO1VBQ0FZLEtBQUssQ0FBQ241QixJQUFOLENBQVdsQyxVQUFYLEVBQXFCa0MsSUFBckI7UUFDRDtRQUVELElBQUksT0FBT2pFLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDOUIsSUFBSSxPQUFPaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFYLEtBQXdCLFdBQTVCLEVBQXlDO1lBQ3ZDLE1BQU0sSUFBSXFCLFNBQUosd0JBQWtDckIsTUFBbEMsUUFBTjtVQUNEO1VBRURpRSxJQUFJLENBQUNqRSxNQUFELENBQUo7UUFDRDtNQUNGLENBaEJNLENBQVA7SUFpQkQ7OztXQTVLRCxlQUFxQjtRQUNuQixPQUFPOEIsU0FBUDtNQUNEOzs7O0VBNktIOzs7O0VBSUFqRixxQkFBQyxDQUFDd0IsUUFBRCxDQUFELENBQ0dnRyxFQURILENBQ003QixvQkFETixFQUM0QnVDLG9CQUQ1QixFQUNrRCxVQUFVbkksS0FBVixFQUFpQjtJQUMvREEsS0FBSyxDQUFDd0gsY0FBTjtJQUNBbzRCLEdBQUcsQ0FBQzE0QixnQkFBSixDQUFxQnpILElBQXJCLENBQTBCUSxxQkFBQyxDQUFDLElBQUQsQ0FBM0IsRUFBbUMsTUFBbkM7RUFDRCxDQUpIO0VBTUE7Ozs7RUFJQUEscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELE1BQUwsSUFBYTI2QixHQUFHLENBQUMxNEIsZ0JBQWpCO0VBQ0FqSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxFQUFXeUMsV0FBWCxHQUF5Qms0QixHQUF6QjtFQUNBMy9CLHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxNQUFMLEVBQVcwQyxVQUFYLEdBQXdCLFlBQU07SUFDNUIxSCxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsTUFBTCxJQUFhSyxvQkFBYjtJQUNBLE9BQU9zNkIsR0FBRyxDQUFDMTRCLGdCQUFYO0VBQ0QsQ0FIRDs7RUN4T0E7Ozs7RUFJQSxJQUFNakMsSUFBSSxHQUFHLE9BQWI7RUFDQSxJQUFNQyxPQUFPLEdBQUcsT0FBaEI7RUFDQSxJQUFNQyxRQUFRLEdBQUcsVUFBakI7RUFDQSxJQUFNQyxTQUFTLFNBQU9ELFFBQXRCO0VBQ0EsSUFBTUcsa0JBQWtCLEdBQUdyRixxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsSUFBTCxDQUEzQjtFQUVBLElBQU1PLGVBQWUsR0FBRyxNQUF4QjtFQUNBLElBQU1pN0IsZUFBZSxHQUFHLE1BQXhCO0VBQ0EsSUFBTWg3QixlQUFlLEdBQUcsTUFBeEI7RUFDQSxJQUFNaTdCLGtCQUFrQixHQUFHLFNBQTNCO0VBRUEsSUFBTTFRLG1CQUFtQixxQkFBbUI1cUIsU0FBNUM7RUFDQSxJQUFNNk4sVUFBVSxZQUFVN04sU0FBMUI7RUFDQSxJQUFNOE4sWUFBWSxjQUFZOU4sU0FBOUI7RUFDQSxJQUFNMk4sVUFBVSxZQUFVM04sU0FBMUI7RUFDQSxJQUFNNE4sV0FBVyxhQUFXNU4sU0FBNUI7RUFFQSxJQUFNa3JCLHFCQUFxQixHQUFHLHdCQUE5QjtFQUVBLElBQU1qa0IsT0FBTyxHQUFHO0lBQ2Rrc0IsU0FBUyxFQUFFLElBREc7SUFFZG9JLFFBQVEsRUFBRSxJQUZJO0lBR2RqSSxLQUFLLEVBQUU7RUFITyxDQUFoQjtFQU1BLElBQU05ckIsV0FBVyxHQUFHO0lBQ2xCMnJCLFNBQVMsRUFBRSxTQURPO0lBRWxCb0ksUUFBUSxFQUFFLFNBRlE7SUFHbEJqSSxLQUFLLEVBQUU7RUFIVyxDQUFwQjtFQU1BOzs7O01BSU1rSTtJQUNKLGVBQVloL0IsT0FBWixFQUFxQndCLE1BQXJCLEVBQTZCO01BQzNCLEtBQUsyQyxRQUFMLEdBQWdCbkUsT0FBaEI7TUFDQSxLQUFLNkwsT0FBTCxHQUFlLEtBQUtDLFVBQUwsQ0FBZ0J0SyxNQUFoQixDQUFmO01BQ0EsS0FBS3UyQixRQUFMLEdBQWdCLElBQWhCO01BQ0EsS0FBS0ksYUFBTDtJQUNEOzs7O0lBZUQ7V0FDQTVsQix1QkFBTztNQUFBO01BQ0wsSUFBTW1hLFNBQVMsR0FBR3J1QixxQkFBQyxDQUFDMkcsS0FBRixDQUFRbU0sVUFBUixDQUFsQjtNQUVBOVMscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJ5ckIsU0FBekI7TUFDQSxJQUFJQSxTQUFTLENBQUNqb0Isa0JBQVYsRUFBSixFQUFvQztRQUNsQztNQUNEO01BRUQsS0FBS3c2QixhQUFMO01BRUEsSUFBSSxLQUFLcHpCLE9BQUwsQ0FBYThxQixTQUFqQixFQUE0QjtRQUMxQixLQUFLeHlCLFFBQUwsQ0FBY2lELFNBQWQsQ0FBd0JtQixHQUF4QixDQUE0QjNFLGVBQTVCO01BQ0Q7TUFFRCxJQUFNcVAsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBTTtRQUNyQjdULEtBQUksQ0FBQytFLFFBQUwsQ0FBY2lELFNBQWQsQ0FBd0IvQixNQUF4QixDQUErQnk1QixrQkFBL0I7UUFDQTEvQixLQUFJLENBQUMrRSxRQUFMLENBQWNpRCxTQUFkLENBQXdCbUIsR0FBeEIsQ0FBNEIxRSxlQUE1QjtRQUVBeEYscUJBQUMsQ0FBQ2UsS0FBSSxDQUFDK0UsUUFBTixDQUFELENBQWlCbEQsT0FBakIsQ0FBeUJtUSxXQUF6QjtRQUVBLElBQUloUyxLQUFJLENBQUN5TSxPQUFMLENBQWFrekIsUUFBakIsRUFBMkI7VUFDekIzL0IsS0FBSSxDQUFDMjRCLFFBQUwsR0FBZ0I3NEIsVUFBVSxDQUFDLFlBQU07WUFDL0JFLEtBQUksQ0FBQ2tULElBQUw7VUFDRCxDQUZ5QixFQUV2QmxULEtBQUksQ0FBQ3lNLE9BQUwsQ0FBYWlyQixLQUZVLENBQTFCO1FBR0Q7TUFDRixDQVhEO01BYUEsS0FBSzN5QixRQUFMLENBQWNpRCxTQUFkLENBQXdCL0IsTUFBeEIsQ0FBK0J3NUIsZUFBL0I7TUFDQTUvQixJQUFJLENBQUM4QixNQUFMLENBQVksS0FBS29ELFFBQWpCO01BQ0EsS0FBS0EsUUFBTCxDQUFjaUQsU0FBZCxDQUF3Qm1CLEdBQXhCLENBQTRCdTJCLGtCQUE1QjtNQUNBLElBQUksS0FBS2p6QixPQUFMLENBQWE4cUIsU0FBakIsRUFBNEI7UUFDMUIsSUFBTW4yQixrQkFBa0IsR0FBR3ZCLElBQUksQ0FBQ3NCLGdDQUFMLENBQXNDLEtBQUs0RCxRQUEzQyxDQUEzQjtRQUVBOUYscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQ0duRixHQURILENBQ09DLElBQUksQ0FBQzFCLGNBRFosRUFDNEIwVixRQUQ1QixFQUVHMVQsb0JBRkgsQ0FFd0JpQixrQkFGeEI7TUFHRCxDQU5ELE1BTU87UUFDTHlTLFFBQVE7TUFDVDtJQUNGO1dBRURYLHVCQUFPO01BQ0wsSUFBSSxDQUFDLEtBQUtuTyxRQUFMLENBQWNpRCxTQUFkLENBQXdCQyxRQUF4QixDQUFpQ3hELGVBQWpDLENBQUwsRUFBd0Q7UUFDdEQ7TUFDRDtNQUVELElBQU1rcEIsU0FBUyxHQUFHMXVCLHFCQUFDLENBQUMyRyxLQUFGLENBQVFxTSxVQUFSLENBQWxCO01BRUFoVCxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJsRCxPQUFqQixDQUF5QjhyQixTQUF6QjtNQUNBLElBQUlBLFNBQVMsQ0FBQ3RvQixrQkFBVixFQUFKLEVBQW9DO1FBQ2xDO01BQ0Q7TUFFRCxLQUFLeTZCLE1BQUw7SUFDRDtXQUVEdjZCLDZCQUFVO01BQ1IsS0FBS3M2QixhQUFMO01BRUEsSUFBSSxLQUFLOTZCLFFBQUwsQ0FBY2lELFNBQWQsQ0FBd0JDLFFBQXhCLENBQWlDeEQsZUFBakMsQ0FBSixFQUF1RDtRQUNyRCxLQUFLTSxRQUFMLENBQWNpRCxTQUFkLENBQXdCL0IsTUFBeEIsQ0FBK0J4QixlQUEvQjtNQUNEO01BRUR4RixxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJvSixHQUFqQixDQUFxQjZnQixtQkFBckI7TUFFQS92QixxQkFBQyxDQUFDdUcsVUFBRixDQUFhLEtBQUtULFFBQWxCLEVBQTRCWixRQUE1QjtNQUNBLEtBQUtZLFFBQUwsR0FBZ0IsSUFBaEI7TUFDQSxLQUFLMEgsT0FBTCxHQUFlLElBQWY7SUFDRDtJQUFBOztXQUdEQyxpQ0FBV3RLLE1BQVgsRUFBbUI7TUFDakJBLE1BQU0sa0JBQ0RpSixPQURDLEVBRURwTSxxQkFBQyxDQUFDLEtBQUs4RixRQUFOLENBQUQsQ0FBaUJzQixJQUFqQixFQUZDLEVBR0EsUUFBT2pFLE1BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE1BQTlCLEdBQXVDQSxNQUF2QyxHQUFnRCxFQUhoRCxDQUFOO01BTUF2QyxJQUFJLENBQUNxQyxlQUFMLENBQ0UrQixJQURGLEVBRUU3QixNQUZGLEVBR0UsS0FBS3lyQixXQUFMLENBQWlCamlCLFdBSG5CO01BTUEsT0FBT3hKLE1BQVA7SUFDRDtXQUVEMjJCLHlDQUFnQjtNQUFBO01BQ2Q5NUIscUJBQUMsQ0FBQyxLQUFLOEYsUUFBTixDQUFELENBQWlCMEIsRUFBakIsQ0FBb0J1b0IsbUJBQXBCLEVBQXlDTSxxQkFBekMsRUFBZ0U7UUFBQSxPQUFNL2dCLE1BQUksQ0FBQzJFLElBQUwsRUFBTjtNQUFBLENBQWhFO0lBQ0Q7V0FFRDRzQiwyQkFBUztNQUFBO01BQ1AsSUFBTWpzQixRQUFRLEdBQUcsU0FBWEEsUUFBVyxHQUFNO1FBQ3JCbEYsTUFBSSxDQUFDNUosUUFBTCxDQUFjaUQsU0FBZCxDQUF3Qm1CLEdBQXhCLENBQTRCczJCLGVBQTVCO1FBQ0F4Z0MscUJBQUMsQ0FBQzBQLE1BQUksQ0FBQzVKLFFBQU4sQ0FBRCxDQUFpQmxELE9BQWpCLENBQXlCcVEsWUFBekI7TUFDRCxDQUhEO01BS0EsS0FBS25OLFFBQUwsQ0FBY2lELFNBQWQsQ0FBd0IvQixNQUF4QixDQUErQnhCLGVBQS9CO01BQ0EsSUFBSSxLQUFLZ0ksT0FBTCxDQUFhOHFCLFNBQWpCLEVBQTRCO1FBQzFCLElBQU1uMkIsa0JBQWtCLEdBQUd2QixJQUFJLENBQUNzQixnQ0FBTCxDQUFzQyxLQUFLNEQsUUFBM0MsQ0FBM0I7UUFFQTlGLHFCQUFDLENBQUMsS0FBSzhGLFFBQU4sQ0FBRCxDQUNHbkYsR0FESCxDQUNPQyxJQUFJLENBQUMxQixjQURaLEVBQzRCMFYsUUFENUIsRUFFRzFULG9CQUZILENBRXdCaUIsa0JBRnhCO01BR0QsQ0FORCxNQU1PO1FBQ0x5UyxRQUFRO01BQ1Q7SUFDRjtXQUVEZ3NCLHlDQUFnQjtNQUNkM3dCLFlBQVksQ0FBQyxLQUFLeXBCLFFBQU4sQ0FBWjtNQUNBLEtBQUtBLFFBQUwsR0FBZ0IsSUFBaEI7SUFDRDtJQUFBOztVQUdNenlCLG1CQUFQLDBCQUF3QjlELE1BQXhCLEVBQWdDO01BQzlCLE9BQU8sS0FBSytELElBQUwsQ0FBVSxZQUFZO1FBQzNCLElBQU1DLFFBQVEsR0FBR25ILHFCQUFDLENBQUMsSUFBRCxDQUFsQjtRQUNBLElBQUlvSCxJQUFJLEdBQUdELFFBQVEsQ0FBQ0MsSUFBVCxDQUFjbEMsUUFBZCxDQUFYO1FBQ0EsSUFBTXNJLE9BQU8sR0FBRyxRQUFPckssTUFBUCxNQUFrQixRQUFsQixJQUE4QkEsTUFBOUM7UUFFQSxJQUFJLENBQUNpRSxJQUFMLEVBQVc7VUFDVEEsSUFBSSxHQUFHLElBQUl1NUIsS0FBSixDQUFVLElBQVYsRUFBZ0JuekIsT0FBaEIsQ0FBUDtVQUNBckcsUUFBUSxDQUFDQyxJQUFULENBQWNsQyxRQUFkLEVBQXdCa0MsSUFBeEI7UUFDRDtRQUVELElBQUksT0FBT2pFLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7VUFDOUIsSUFBSSxPQUFPaUUsSUFBSSxDQUFDakUsTUFBRCxDQUFYLEtBQXdCLFdBQTVCLEVBQXlDO1lBQ3ZDLE1BQU0sSUFBSXFCLFNBQUosd0JBQWtDckIsTUFBbEMsUUFBTjtVQUNEO1VBRURpRSxJQUFJLENBQUNqRSxNQUFELENBQUosQ0FBYSxJQUFiO1FBQ0Q7TUFDRixDQWpCTSxDQUFQO0lBa0JEOzs7V0FuSkQsZUFBcUI7UUFDbkIsT0FBTzhCLE9BQVA7TUFDRDs7O1dBRUQsZUFBeUI7UUFDdkIsT0FBTzBILFdBQVA7TUFDRDs7O1dBRUQsZUFBcUI7UUFDbkIsT0FBT1AsT0FBUDtNQUNEOzs7O0VBNElIOzs7O0VBSUFwTSxxQkFBQyxDQUFDaUIsRUFBRixDQUFLK0QsSUFBTCxJQUFhMjdCLEtBQUssQ0FBQzE1QixnQkFBbkI7RUFDQWpILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxJQUFMLEVBQVd5QyxXQUFYLEdBQXlCazVCLEtBQXpCO0VBQ0EzZ0MscUJBQUMsQ0FBQ2lCLEVBQUYsQ0FBSytELElBQUwsRUFBVzBDLFVBQVgsR0FBd0IsWUFBTTtJQUM1QjFILHFCQUFDLENBQUNpQixFQUFGLENBQUsrRCxJQUFMLElBQWFLLGtCQUFiO0lBQ0EsT0FBT3M3QixLQUFLLENBQUMxNUIsZ0JBQWI7RUFDRCxDQUhEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy91dGlsLmpzPzA3YTUiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9hbGVydC5qcz84NzQzIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvYnV0dG9uLmpzP2NhMWEiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9jYXJvdXNlbC5qcz85MDQwIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvY29sbGFwc2UuanM/NWU3YiIsIndlYnBhY2s6Ly8vLi4vLi4vbm9kZV9tb2R1bGVzL3BvcHBlci5qcy9kaXN0L2VzbS9wb3BwZXIuanM/NzBmZCIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL2Ryb3Bkb3duLmpzPzU4NzYiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9tb2RhbC5qcz8xMjg3Iiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdG9vbHMvc2FuaXRpemVyLmpzP2I4ZjkiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy90b29sdGlwLmpzPzg5M2UiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9wb3BvdmVyLmpzP2IzZDUiLCJ3ZWJwYWNrOi8vLy4uLy4uL2pzL3NyYy9zY3JvbGxzcHkuanM/YzgyNyIsIndlYnBhY2s6Ly8vLi4vLi4vanMvc3JjL3RhYi5qcz80NWEyIiwid2VicGFjazovLy8uLi8uLi9qcy9zcmMvdG9hc3QuanM/YTJmZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IHV0aWwuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5cbi8qKlxuICogUHJpdmF0ZSBUcmFuc2l0aW9uRW5kIEhlbHBlcnNcbiAqL1xuXG5jb25zdCBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJ1xuY29uc3QgTUFYX1VJRCA9IDEwMDAwMDBcbmNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMFxuXG4vLyBTaG91dG91dCBBbmd1c0Nyb2xsIChodHRwczovL2dvby5nbC9weHdRR3ApXG5mdW5jdGlvbiB0b1R5cGUob2JqKSB7XG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYCR7b2JqfWBcbiAgfVxuXG4gIHJldHVybiB7fS50b1N0cmluZy5jYWxsKG9iaikubWF0Y2goL1xccyhbYS16XSspL2kpWzFdLnRvTG93ZXJDYXNlKClcbn1cblxuZnVuY3Rpb24gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpIHtcbiAgcmV0dXJuIHtcbiAgICBiaW5kVHlwZTogVFJBTlNJVElPTl9FTkQsXG4gICAgZGVsZWdhdGVUeXBlOiBUUkFOU0lUSU9OX0VORCxcbiAgICBoYW5kbGUoZXZlbnQpIHtcbiAgICAgIGlmICgkKGV2ZW50LnRhcmdldCkuaXModGhpcykpIHtcbiAgICAgICAgcmV0dXJuIGV2ZW50LmhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBwcmVmZXItcmVzdC1wYXJhbXNcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0cmFuc2l0aW9uRW5kRW11bGF0b3IoZHVyYXRpb24pIHtcbiAgbGV0IGNhbGxlZCA9IGZhbHNlXG5cbiAgJCh0aGlzKS5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgKCkgPT4ge1xuICAgIGNhbGxlZCA9IHRydWVcbiAgfSlcblxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICBpZiAoIWNhbGxlZCkge1xuICAgICAgVXRpbC50cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzKVxuICAgIH1cbiAgfSwgZHVyYXRpb24pXG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuZnVuY3Rpb24gc2V0VHJhbnNpdGlvbkVuZFN1cHBvcnQoKSB7XG4gICQuZm4uZW11bGF0ZVRyYW5zaXRpb25FbmQgPSB0cmFuc2l0aW9uRW5kRW11bGF0b3JcbiAgJC5ldmVudC5zcGVjaWFsW1V0aWwuVFJBTlNJVElPTl9FTkRdID0gZ2V0U3BlY2lhbFRyYW5zaXRpb25FbmRFdmVudCgpXG59XG5cbi8qKlxuICogUHVibGljIFV0aWwgQVBJXG4gKi9cblxuY29uc3QgVXRpbCA9IHtcbiAgVFJBTlNJVElPTl9FTkQ6ICdic1RyYW5zaXRpb25FbmQnLFxuXG4gIGdldFVJRChwcmVmaXgpIHtcbiAgICBkbyB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tYml0d2lzZVxuICAgICAgcHJlZml4ICs9IH5+KE1hdGgucmFuZG9tKCkgKiBNQVhfVUlEKSAvLyBcIn5+XCIgYWN0cyBsaWtlIGEgZmFzdGVyIE1hdGguZmxvb3IoKSBoZXJlXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSlcblxuICAgIHJldHVybiBwcmVmaXhcbiAgfSxcblxuICBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgc2VsZWN0b3IgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQnKVxuXG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XG4gICAgICBjb25zdCBocmVmQXR0ciA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHIgJiYgaHJlZkF0dHIgIT09ICcjJyA/IGhyZWZBdHRyLnRyaW0oKSA6ICcnXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbFxuICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9LFxuXG4gIGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgLy8gR2V0IHRyYW5zaXRpb24tZHVyYXRpb24gb2YgdGhlIGVsZW1lbnRcbiAgICBsZXQgdHJhbnNpdGlvbkR1cmF0aW9uID0gJChlbGVtZW50KS5jc3MoJ3RyYW5zaXRpb24tZHVyYXRpb24nKVxuICAgIGxldCB0cmFuc2l0aW9uRGVsYXkgPSAkKGVsZW1lbnQpLmNzcygndHJhbnNpdGlvbi1kZWxheScpXG5cbiAgICBjb25zdCBmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiA9IHBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gcGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpXG5cbiAgICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXG4gICAgaWYgKCFmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiAmJiAhZmxvYXRUcmFuc2l0aW9uRGVsYXkpIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuXG4gICAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdXG4gICAgdHJhbnNpdGlvbkRlbGF5ID0gdHJhbnNpdGlvbkRlbGF5LnNwbGl0KCcsJylbMF1cblxuICAgIHJldHVybiAocGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgcGFyc2VGbG9hdCh0cmFuc2l0aW9uRGVsYXkpKSAqIE1JTExJU0VDT05EU19NVUxUSVBMSUVSXG4gIH0sXG5cbiAgcmVmbG93KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRIZWlnaHRcbiAgfSxcblxuICB0cmlnZ2VyVHJhbnNpdGlvbkVuZChlbGVtZW50KSB7XG4gICAgJChlbGVtZW50KS50cmlnZ2VyKFRSQU5TSVRJT05fRU5EKVxuICB9LFxuXG4gIHN1cHBvcnRzVHJhbnNpdGlvbkVuZCgpIHtcbiAgICByZXR1cm4gQm9vbGVhbihUUkFOU0lUSU9OX0VORClcbiAgfSxcblxuICBpc0VsZW1lbnQob2JqKSB7XG4gICAgcmV0dXJuIChvYmpbMF0gfHwgb2JqKS5ub2RlVHlwZVxuICB9LFxuXG4gIHR5cGVDaGVja0NvbmZpZyhjb21wb25lbnROYW1lLCBjb25maWcsIGNvbmZpZ1R5cGVzKSB7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBjb25maWdUeXBlcykge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maWdUeXBlcywgcHJvcGVydHkpKSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkVHlwZXMgPSBjb25maWdUeXBlc1twcm9wZXJ0eV1cbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IHZhbHVlICYmIFV0aWwuaXNFbGVtZW50KHZhbHVlKSA/XG4gICAgICAgICAgJ2VsZW1lbnQnIDogdG9UeXBlKHZhbHVlKVxuXG4gICAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgJHtjb21wb25lbnROYW1lLnRvVXBwZXJDYXNlKCl9OiBgICtcbiAgICAgICAgICAgIGBPcHRpb24gXCIke3Byb3BlcnR5fVwiIHByb3ZpZGVkIHR5cGUgXCIke3ZhbHVlVHlwZX1cIiBgICtcbiAgICAgICAgICAgIGBidXQgZXhwZWN0ZWQgdHlwZSBcIiR7ZXhwZWN0ZWRUeXBlc31cIi5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGZpbmRTaGFkb3dSb290KGVsZW1lbnQpIHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgLy8gQ2FuIGZpbmQgdGhlIHNoYWRvdyByb290IG90aGVyd2lzZSBpdCdsbCByZXR1cm4gdGhlIGRvY3VtZW50XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zdCByb290ID0gZWxlbWVudC5nZXRSb290Tm9kZSgpXG4gICAgICByZXR1cm4gcm9vdCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QgPyByb290IDogbnVsbFxuICAgIH1cblxuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgU2hhZG93Um9vdCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnRcbiAgICB9XG5cbiAgICAvLyB3aGVuIHdlIGRvbid0IGZpbmQgYSBzaGFkb3cgcm9vdFxuICAgIGlmICghZWxlbWVudC5wYXJlbnROb2RlKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIHJldHVybiBVdGlsLmZpbmRTaGFkb3dSb290KGVsZW1lbnQucGFyZW50Tm9kZSlcbiAgfSxcblxuICBqUXVlcnlEZXRlY3Rpb24oKSB7XG4gICAgaWYgKHR5cGVvZiAkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBKYXZhU2NyaXB0IHJlcXVpcmVzIGpRdWVyeS4galF1ZXJ5IG11c3QgYmUgaW5jbHVkZWQgYmVmb3JlIEJvb3RzdHJhcFxcJ3MgSmF2YVNjcmlwdC4nKVxuICAgIH1cblxuICAgIGNvbnN0IHZlcnNpb24gPSAkLmZuLmpxdWVyeS5zcGxpdCgnICcpWzBdLnNwbGl0KCcuJylcbiAgICBjb25zdCBtaW5NYWpvciA9IDFcbiAgICBjb25zdCBsdE1ham9yID0gMlxuICAgIGNvbnN0IG1pbk1pbm9yID0gOVxuICAgIGNvbnN0IG1pblBhdGNoID0gMVxuICAgIGNvbnN0IG1heE1ham9yID0gNFxuXG4gICAgaWYgKHZlcnNpb25bMF0gPCBsdE1ham9yICYmIHZlcnNpb25bMV0gPCBtaW5NaW5vciB8fCB2ZXJzaW9uWzBdID09PSBtaW5NYWpvciAmJiB2ZXJzaW9uWzFdID09PSBtaW5NaW5vciAmJiB2ZXJzaW9uWzJdIDwgbWluUGF0Y2ggfHwgdmVyc2lvblswXSA+PSBtYXhNYWpvcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdCb290c3RyYXBcXCdzIEphdmFTY3JpcHQgcmVxdWlyZXMgYXQgbGVhc3QgalF1ZXJ5IHYxLjkuMSBidXQgbGVzcyB0aGFuIHY0LjAuMCcpXG4gICAgfVxuICB9XG59XG5cblV0aWwualF1ZXJ5RGV0ZWN0aW9uKClcbnNldFRyYW5zaXRpb25FbmRTdXBwb3J0KClcblxuZXhwb3J0IGRlZmF1bHQgVXRpbFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjEpOiBhbGVydC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ2FsZXJ0J1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmFsZXJ0J1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5cbmNvbnN0IENMQVNTX05BTUVfQUxFUlQgPSAnYWxlcnQnXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuXG5jb25zdCBFVkVOVF9DTE9TRSA9IGBjbG9zZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMT1NFRCA9IGBjbG9zZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgU0VMRUNUT1JfRElTTUlTUyA9ICdbZGF0YS1kaXNtaXNzPVwiYWxlcnRcIl0nXG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEFsZXJ0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCkge1xuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgLy8gUHVibGljXG4gIGNsb3NlKGVsZW1lbnQpIHtcbiAgICBsZXQgcm9vdEVsZW1lbnQgPSB0aGlzLl9lbGVtZW50XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHJvb3RFbGVtZW50ID0gdGhpcy5fZ2V0Um9vdEVsZW1lbnQoZWxlbWVudClcbiAgICB9XG5cbiAgICBjb25zdCBjdXN0b21FdmVudCA9IHRoaXMuX3RyaWdnZXJDbG9zZUV2ZW50KHJvb3RFbGVtZW50KVxuXG4gICAgaWYgKGN1c3RvbUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9yZW1vdmVFbGVtZW50KHJvb3RFbGVtZW50KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldFJvb3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KVxuICAgIGxldCBwYXJlbnQgPSBmYWxzZVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICBwYXJlbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIGlmICghcGFyZW50KSB7XG4gICAgICBwYXJlbnQgPSAkKGVsZW1lbnQpLmNsb3Nlc3QoYC4ke0NMQVNTX05BTUVfQUxFUlR9YClbMF1cbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50XG4gIH1cblxuICBfdHJpZ2dlckNsb3NlRXZlbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IGNsb3NlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0NMT1NFKVxuXG4gICAgJChlbGVtZW50KS50cmlnZ2VyKGNsb3NlRXZlbnQpXG4gICAgcmV0dXJuIGNsb3NlRXZlbnRcbiAgfVxuXG4gIF9yZW1vdmVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICghJChlbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50KVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChlbGVtZW50KVxuXG4gICAgJChlbGVtZW50KVxuICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBldmVudCA9PiB0aGlzLl9kZXN0cm95RWxlbWVudChlbGVtZW50LCBldmVudCkpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICB9XG5cbiAgX2Rlc3Ryb3lFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAkKGVsZW1lbnQpXG4gICAgICAuZGV0YWNoKClcbiAgICAgIC50cmlnZ2VyKEVWRU5UX0NMT1NFRClcbiAgICAgIC5yZW1vdmUoKVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IEFsZXJ0KHRoaXMpXG4gICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcgPT09ICdjbG9zZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHN0YXRpYyBfaGFuZGxlRGlzbWlzcyhhbGVydEluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgIH1cblxuICAgICAgYWxlcnRJbnN0YW5jZS5jbG9zZSh0aGlzKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gKi9cblxuJChkb2N1bWVudCkub24oXG4gIEVWRU5UX0NMSUNLX0RBVEFfQVBJLFxuICBTRUxFQ1RPUl9ESVNNSVNTLFxuICBBbGVydC5faGFuZGxlRGlzbWlzcyhuZXcgQWxlcnQoKSlcbilcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gQWxlcnQuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IEFsZXJ0XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIEFsZXJ0Ll9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQWxlcnRcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4xKTogYnV0dG9uLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnYnV0dG9uJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmJ1dHRvbidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5jb25zdCBDTEFTU19OQU1FX0JVVFRPTiA9ICdidG4nXG5jb25zdCBDTEFTU19OQU1FX0ZPQ1VTID0gJ2ZvY3VzJ1xuXG5jb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSA9IGBjbGljayR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcbmNvbnN0IEVWRU5UX0ZPQ1VTX0JMVVJfREFUQV9BUEkgPSBgZm9jdXMke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX0gYCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGBibHVyJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRV9DQVJST1QgPSAnW2RhdGEtdG9nZ2xlXj1cImJ1dHRvblwiXSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFUyA9ICdbZGF0YS10b2dnbGU9XCJidXR0b25zXCJdJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uXCJdJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVTX0JVVFRPTlMgPSAnW2RhdGEtdG9nZ2xlPVwiYnV0dG9uc1wiXSAuYnRuJ1xuY29uc3QgU0VMRUNUT1JfSU5QVVQgPSAnaW5wdXQ6bm90KFt0eXBlPVwiaGlkZGVuXCJdKSdcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfQlVUVE9OID0gJy5idG4nXG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIEJ1dHRvbiB7XG4gIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuc2hvdWxkQXZvaWRUcmlnZ2VyQ2hhbmdlID0gZmFsc2VcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIGxldCB0cmlnZ2VyQ2hhbmdlRXZlbnQgPSB0cnVlXG4gICAgbGV0IGFkZEFyaWFQcmVzc2VkID0gdHJ1ZVxuICAgIGNvbnN0IHJvb3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RBVEFfVE9HR0xFUylbMF1cblxuICAgIGlmIChyb290RWxlbWVudCkge1xuICAgICAgY29uc3QgaW5wdXQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5QVVQpXG5cbiAgICAgIGlmIChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ3JhZGlvJykge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGVja2VkICYmIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSkge1xuICAgICAgICAgICAgdHJpZ2dlckNoYW5nZUV2ZW50ID0gZmFsc2VcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRWxlbWVudCA9IHJvb3RFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFKVxuXG4gICAgICAgICAgICBpZiAoYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAkKGFjdGl2ZUVsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmlnZ2VyQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICAvLyBpZiBpdCdzIG5vdCBhIHJhZGlvIGJ1dHRvbiBvciBjaGVja2JveCBkb24ndCBhZGQgYSBwb2ludGxlc3MvaW52YWxpZCBjaGVja2VkIHByb3BlcnR5IHRvIHRoZSBpbnB1dFxuICAgICAgICAgIGlmIChpbnB1dC50eXBlID09PSAnY2hlY2tib3gnIHx8IGlucHV0LnR5cGUgPT09ICdyYWRpbycpIHtcbiAgICAgICAgICAgIGlucHV0LmNoZWNrZWQgPSAhdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCF0aGlzLnNob3VsZEF2b2lkVHJpZ2dlckNoYW5nZSkge1xuICAgICAgICAgICAgJChpbnB1dCkudHJpZ2dlcignY2hhbmdlJylcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpbnB1dC5mb2N1cygpXG4gICAgICAgIGFkZEFyaWFQcmVzc2VkID0gZmFsc2VcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoISh0aGlzLl9lbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkpIHtcbiAgICAgIGlmIChhZGRBcmlhUHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgIXRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSlcbiAgICAgIH1cblxuICAgICAgaWYgKHRyaWdnZXJDaGFuZ2VFdmVudCkge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnLCBhdm9pZFRyaWdnZXJDaGFuZ2UpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICRlbGVtZW50ID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBCdXR0b24odGhpcylcbiAgICAgICAgJGVsZW1lbnQuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgZGF0YS5zaG91bGRBdm9pZFRyaWdnZXJDaGFuZ2UgPSBhdm9pZFRyaWdnZXJDaGFuZ2VcblxuICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFX0NBUlJPVCwgZXZlbnQgPT4ge1xuICAgIGxldCBidXR0b24gPSBldmVudC50YXJnZXRcbiAgICBjb25zdCBpbml0aWFsQnV0dG9uID0gYnV0dG9uXG5cbiAgICBpZiAoISQoYnV0dG9uKS5oYXNDbGFzcyhDTEFTU19OQU1FX0JVVFRPTikpIHtcbiAgICAgIGJ1dHRvbiA9ICQoYnV0dG9uKS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF1cbiAgICB9XG5cbiAgICBpZiAoIWJ1dHRvbiB8fCBidXR0b24uaGFzQXR0cmlidXRlKCdkaXNhYmxlZCcpIHx8IGJ1dHRvbi5jbGFzc0xpc3QuY29udGFpbnMoJ2Rpc2FibGVkJykpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCkgLy8gd29yayBhcm91bmQgRmlyZWZveCBidWcgIzE1NDA5OTVcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaW5wdXRCdG4gPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVClcblxuICAgICAgaWYgKGlucHV0QnRuICYmIChpbnB1dEJ0bi5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgfHwgaW5wdXRCdG4uY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSkge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3ggYnVnICMxNTQwOTk1XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdGlhbEJ1dHRvbi50YWdOYW1lID09PSAnSU5QVVQnIHx8IGJ1dHRvbi50YWdOYW1lICE9PSAnTEFCRUwnKSB7XG4gICAgICAgIEJ1dHRvbi5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJChidXR0b24pLCAndG9nZ2xlJywgaW5pdGlhbEJ1dHRvbi50YWdOYW1lID09PSAnSU5QVVQnKVxuICAgICAgfVxuICAgIH1cbiAgfSlcbiAgLm9uKEVWRU5UX0ZPQ1VTX0JMVVJfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFX0NBUlJPVCwgZXZlbnQgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9ICQoZXZlbnQudGFyZ2V0KS5jbG9zZXN0KFNFTEVDVE9SX0JVVFRPTilbMF1cbiAgICAkKGJ1dHRvbikudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9GT0NVUywgL15mb2N1cyhpbik/JC8udGVzdChldmVudC50eXBlKSlcbiAgfSlcblxuJCh3aW5kb3cpLm9uKEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgLy8gZW5zdXJlIGNvcnJlY3QgYWN0aXZlIGNsYXNzIGlzIHNldCB0byBtYXRjaCB0aGUgY29udHJvbHMnIGFjdHVhbCB2YWx1ZXMvc3RhdGVzXG5cbiAgLy8gZmluZCBhbGwgY2hlY2tib3hlcy9yZWFkaW8gYnV0dG9ucyBpbnNpZGUgZGF0YS10b2dnbGUgZ3JvdXBzXG4gIGxldCBidXR0b25zID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TKSlcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGJ1dHRvbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCBidXR0b24gPSBidXR0b25zW2ldXG4gICAgY29uc3QgaW5wdXQgPSBidXR0b24ucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9JTlBVVClcbiAgICBpZiAoaW5wdXQuY2hlY2tlZCB8fCBpbnB1dC5oYXNBdHRyaWJ1dGUoJ2NoZWNrZWQnKSkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH1cbiAgfVxuXG4gIC8vIGZpbmQgYWxsIGJ1dHRvbiB0b2dnbGVzXG4gIGJ1dHRvbnMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9UT0dHTEUpKVxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gYnV0dG9ucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGJ1dHRvbnNbaV1cbiAgICBpZiAoYnV0dG9uLmdldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJykgPT09ICd0cnVlJykge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH1cbiAgfVxufSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBCdXR0b25cbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gQnV0dG9uLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQnV0dG9uXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IGNhcm91c2VsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnY2Fyb3VzZWwnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4xJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMuY2Fyb3VzZWwnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cbmNvbnN0IEFSUk9XX0xFRlRfS0VZQ09ERSA9IDM3IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIGxlZnQgYXJyb3cga2V5XG5jb25zdCBBUlJPV19SSUdIVF9LRVlDT0RFID0gMzkgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgcmlnaHQgYXJyb3cga2V5XG5jb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwIC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuY29uc3QgU1dJUEVfVEhSRVNIT0xEID0gNDBcblxuY29uc3QgQ0xBU1NfTkFNRV9DQVJPVVNFTCA9ICdjYXJvdXNlbCdcbmNvbnN0IENMQVNTX05BTUVfQUNUSVZFID0gJ2FjdGl2ZSdcbmNvbnN0IENMQVNTX05BTUVfU0xJREUgPSAnc2xpZGUnXG5jb25zdCBDTEFTU19OQU1FX1JJR0hUID0gJ2Nhcm91c2VsLWl0ZW0tcmlnaHQnXG5jb25zdCBDTEFTU19OQU1FX0xFRlQgPSAnY2Fyb3VzZWwtaXRlbS1sZWZ0J1xuY29uc3QgQ0xBU1NfTkFNRV9ORVhUID0gJ2Nhcm91c2VsLWl0ZW0tbmV4dCdcbmNvbnN0IENMQVNTX05BTUVfUFJFViA9ICdjYXJvdXNlbC1pdGVtLXByZXYnXG5jb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCdcblxuY29uc3QgRElSRUNUSU9OX05FWFQgPSAnbmV4dCdcbmNvbnN0IERJUkVDVElPTl9QUkVWID0gJ3ByZXYnXG5jb25zdCBESVJFQ1RJT05fTEVGVCA9ICdsZWZ0J1xuY29uc3QgRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0J1xuXG5jb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NMSUQgPSBgc2xpZCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0tFWURPV04gPSBga2V5ZG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFRU5URVIgPSBgbW91c2VlbnRlciR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFTEVBVkUgPSBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1RPVUNIU1RBUlQgPSBgdG91Y2hzdGFydCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9UT1VDSEVORCA9IGB0b3VjaGVuZCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1BPSU5URVJET1dOID0gYHBvaW50ZXJkb3duJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSAnLmFjdGl2ZS5jYXJvdXNlbC1pdGVtJ1xuY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSdcbmNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZydcbmNvbnN0IFNFTEVDVE9SX05FWFRfUFJFViA9ICcuY2Fyb3VzZWwtaXRlbS1uZXh0LCAuY2Fyb3VzZWwtaXRlbS1wcmV2J1xuY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycydcbmNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtc2xpZGVdLCBbZGF0YS1zbGlkZS10b10nXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtcmlkZT1cImNhcm91c2VsXCJdJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBpbnRlcnZhbDogNTAwMCxcbiAga2V5Ym9hcmQ6IHRydWUsXG4gIHNsaWRlOiBmYWxzZSxcbiAgcGF1c2U6ICdob3ZlcicsXG4gIHdyYXA6IHRydWUsXG4gIHRvdWNoOiB0cnVlXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBpbnRlcnZhbDogJyhudW1iZXJ8Ym9vbGVhbiknLFxuICBrZXlib2FyZDogJ2Jvb2xlYW4nLFxuICBzbGlkZTogJyhib29sZWFufHN0cmluZyknLFxuICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICB3cmFwOiAnYm9vbGVhbicsXG4gIHRvdWNoOiAnYm9vbGVhbidcbn1cblxuY29uc3QgUG9pbnRlclR5cGUgPSB7XG4gIFRPVUNIOiAndG91Y2gnLFxuICBQRU46ICdwZW4nXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENhcm91c2VsIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5faXRlbXMgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlXG4gICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcbiAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGxcbiAgICB0aGlzLnRvdWNoU3RhcnRYID0gMFxuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwXG5cbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfSU5ESUNBVE9SUylcbiAgICB0aGlzLl90b3VjaFN1cHBvcnRlZCA9ICdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fCBuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwXG4gICAgdGhpcy5fcG9pbnRlckV2ZW50ID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50IHx8IHdpbmRvdy5NU1BvaW50ZXJFdmVudClcblxuICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICBuZXh0KCkge1xuICAgIGlmICghdGhpcy5faXNTbGlkaW5nKSB7XG4gICAgICB0aGlzLl9zbGlkZShESVJFQ1RJT05fTkVYVClcbiAgICB9XG4gIH1cblxuICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMuX2VsZW1lbnQpXG4gICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcbiAgICBpZiAoIWRvY3VtZW50LmhpZGRlbiAmJlxuICAgICAgKCRlbGVtZW50LmlzKCc6dmlzaWJsZScpICYmICRlbGVtZW50LmNzcygndmlzaWJpbGl0eScpICE9PSAnaGlkZGVuJykpIHtcbiAgICAgIHRoaXMubmV4dCgpXG4gICAgfVxuICB9XG5cbiAgcHJldigpIHtcbiAgICBpZiAoIXRoaXMuX2lzU2xpZGluZykge1xuICAgICAgdGhpcy5fc2xpZGUoRElSRUNUSU9OX1BSRVYpXG4gICAgfVxuICB9XG5cbiAgcGF1c2UoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX05FWFRfUFJFVikpIHtcbiAgICAgIFV0aWwudHJpZ2dlclRyYW5zaXRpb25FbmQodGhpcy5fZWxlbWVudClcbiAgICAgIHRoaXMuY3ljbGUodHJ1ZSlcbiAgICB9XG5cbiAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgIHRoaXMuX2ludGVydmFsID0gbnVsbFxuICB9XG5cbiAgY3ljbGUoZXZlbnQpIHtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICB0aGlzLl9pc1BhdXNlZCA9IGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKVxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy5pbnRlcnZhbCAmJiAhdGhpcy5faXNQYXVzZWQpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZUludGVydmFsKClcblxuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChcbiAgICAgICAgKGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA/IHRoaXMubmV4dFdoZW5WaXNpYmxlIDogdGhpcy5uZXh0KS5iaW5kKHRoaXMpLFxuICAgICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIClcbiAgICB9XG4gIH1cblxuICB0byhpbmRleCkge1xuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfQUNUSVZFX0lURU0pXG5cbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleCh0aGlzLl9hY3RpdmVFbGVtZW50KVxuXG4gICAgaWYgKGluZGV4ID4gdGhpcy5faXRlbXMubGVuZ3RoIC0gMSB8fCBpbmRleCA8IDApIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub25lKEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZUluZGV4ID09PSBpbmRleCkge1xuICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB0aGlzLmN5Y2xlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGluZGV4ID4gYWN0aXZlSW5kZXggP1xuICAgICAgRElSRUNUSU9OX05FWFQgOlxuICAgICAgRElSRUNUSU9OX1BSRVZcblxuICAgIHRoaXMuX3NsaWRlKGRpcmVjdGlvbiwgdGhpcy5faXRlbXNbaW5kZXhdKVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuXG4gICAgdGhpcy5faXRlbXMgPSBudWxsXG4gICAgdGhpcy5fY29uZmlnID0gbnVsbFxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsXG4gICAgdGhpcy5faXNQYXVzZWQgPSBudWxsXG4gICAgdGhpcy5faXNTbGlkaW5nID0gbnVsbFxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9oYW5kbGVTd2lwZSgpIHtcbiAgICBjb25zdCBhYnNEZWx0YXggPSBNYXRoLmFicyh0aGlzLnRvdWNoRGVsdGFYKVxuXG4gICAgaWYgKGFic0RlbHRheCA8PSBTV0lQRV9USFJFU0hPTEQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRheCAvIHRoaXMudG91Y2hEZWx0YVhcblxuICAgIHRoaXMudG91Y2hEZWx0YVggPSAwXG5cbiAgICAvLyBzd2lwZSBsZWZ0XG4gICAgaWYgKGRpcmVjdGlvbiA+IDApIHtcbiAgICAgIHRoaXMucHJldigpXG4gICAgfVxuXG4gICAgLy8gc3dpcGUgcmlnaHRcbiAgICBpZiAoZGlyZWN0aW9uIDwgMCkge1xuICAgICAgdGhpcy5uZXh0KClcbiAgICB9XG4gIH1cblxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9LRVlET1dOLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlID09PSAnaG92ZXInKSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbihFVkVOVF9NT1VTRUVOVEVSLCBldmVudCA9PiB0aGlzLnBhdXNlKGV2ZW50KSlcbiAgICAgICAgLm9uKEVWRU5UX01PVVNFTEVBVkUsIGV2ZW50ID0+IHRoaXMuY3ljbGUoZXZlbnQpKVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9jb25maWcudG91Y2gpIHtcbiAgICAgIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKVxuICAgIH1cbiAgfVxuXG4gIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xuICAgIGlmICghdGhpcy5fdG91Y2hTdXBwb3J0ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHN0YXJ0ID0gZXZlbnQgPT4ge1xuICAgICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCAmJiBQb2ludGVyVHlwZVtldmVudC5vcmlnaW5hbEV2ZW50LnBvaW50ZXJUeXBlLnRvVXBwZXJDYXNlKCldKSB7XG4gICAgICAgIHRoaXMudG91Y2hTdGFydFggPSBldmVudC5vcmlnaW5hbEV2ZW50LmNsaWVudFhcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3BvaW50ZXJFdmVudCkge1xuICAgICAgICB0aGlzLnRvdWNoU3RhcnRYID0gZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWzBdLmNsaWVudFhcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBtb3ZlID0gZXZlbnQgPT4ge1xuICAgICAgLy8gZW5zdXJlIHN3aXBpbmcgd2l0aCBvbmUgdG91Y2ggYW5kIG5vdCBwaW5jaGluZ1xuICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyAmJiBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/XG4gICAgICAgIDAgOlxuICAgICAgICBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXNbMF0uY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICB9XG5cbiAgICBjb25zdCBlbmQgPSBldmVudCA9PiB7XG4gICAgICBpZiAodGhpcy5fcG9pbnRlckV2ZW50ICYmIFBvaW50ZXJUeXBlW2V2ZW50Lm9yaWdpbmFsRXZlbnQucG9pbnRlclR5cGUudG9VcHBlckNhc2UoKV0pIHtcbiAgICAgICAgdGhpcy50b3VjaERlbHRhWCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQuY2xpZW50WCAtIHRoaXMudG91Y2hTdGFydFhcbiAgICAgIH1cblxuICAgICAgdGhpcy5faGFuZGxlU3dpcGUoKVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICAvLyBJZiBpdCdzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2UsIG1vdXNlZW50ZXIvbGVhdmUgYXJlIGZpcmVkIGFzXG4gICAgICAgIC8vIHBhcnQgb2YgdGhlIG1vdXNlIGNvbXBhdGliaWxpdHkgZXZlbnRzIG9uIGZpcnN0IHRhcCAtIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xuICAgICAgICAvLyBoZXJlLCB3ZSBsaXN0ZW4gZm9yIHRvdWNoZW5kLCBleHBsaWNpdGx5IHBhdXNlIHRoZSBjYXJvdXNlbFxuICAgICAgICAvLyAoYXMgaWYgaXQncyB0aGUgc2Vjb25kIHRpbWUgd2UgdGFwIG9uIGl0LCBtb3VzZWVudGVyIGNvbXBhdCBldmVudFxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XG4gICAgICAgIC8vIGV2ZW50cyB0byBmaXJlKSB3ZSBleHBsaWNpdGx5IHJlc3RhcnQgY3ljbGluZ1xuXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50b3VjaFRpbWVvdXQpXG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnRvdWNoVGltZW91dCA9IHNldFRpbWVvdXQoZXZlbnQgPT4gdGhpcy5jeWNsZShldmVudCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgJCh0aGlzLl9lbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSVRFTV9JTUcpKVxuICAgICAgLm9uKEVWRU5UX0RSQUdfU1RBUlQsIGUgPT4gZS5wcmV2ZW50RGVmYXVsdCgpKVxuXG4gICAgaWYgKHRoaXMuX3BvaW50ZXJFdmVudCkge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSRE9XTiwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9QT0lOVEVSVVAsIGV2ZW50ID0+IGVuZChldmVudCkpXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQpXG4gICAgfSBlbHNlIHtcbiAgICAgICQodGhpcy5fZWxlbWVudCkub24oRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gc3RhcnQoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9UT1VDSE1PVkUsIGV2ZW50ID0+IG1vdmUoZXZlbnQpKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gZW5kKGV2ZW50KSlcbiAgICB9XG4gIH1cblxuICBfa2V5ZG93bihldmVudCkge1xuICAgIGlmICgvaW5wdXR8dGV4dGFyZWEvaS50ZXN0KGV2ZW50LnRhcmdldC50YWdOYW1lKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChldmVudC53aGljaCkge1xuICAgICAgY2FzZSBBUlJPV19MRUZUX0tFWUNPREU6XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdGhpcy5wcmV2KClcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgQVJST1dfUklHSFRfS0VZQ09ERTpcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICB0aGlzLm5leHQoKVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICB9XG4gIH1cblxuICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICB0aGlzLl9pdGVtcyA9IGVsZW1lbnQgJiYgZWxlbWVudC5wYXJlbnROb2RlID9cbiAgICAgIFtdLnNsaWNlLmNhbGwoZWxlbWVudC5wYXJlbnROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfSVRFTSkpIDpcbiAgICAgIFtdXG4gICAgcmV0dXJuIHRoaXMuX2l0ZW1zLmluZGV4T2YoZWxlbWVudClcbiAgfVxuXG4gIF9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KSB7XG4gICAgY29uc3QgaXNOZXh0RGlyZWN0aW9uID0gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTkVYVFxuICAgIGNvbnN0IGlzUHJldkRpcmVjdGlvbiA9IGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX1BSRVZcbiAgICBjb25zdCBhY3RpdmVJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IGxhc3RJdGVtSW5kZXggPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxXG4gICAgY29uc3QgaXNHb2luZ1RvV3JhcCA9IGlzUHJldkRpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gMCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTmV4dERpcmVjdGlvbiAmJiBhY3RpdmVJbmRleCA9PT0gbGFzdEl0ZW1JbmRleFxuXG4gICAgaWYgKGlzR29pbmdUb1dyYXAgJiYgIXRoaXMuX2NvbmZpZy53cmFwKSB7XG4gICAgICByZXR1cm4gYWN0aXZlRWxlbWVudFxuICAgIH1cblxuICAgIGNvbnN0IGRlbHRhID0gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fUFJFViA/IC0xIDogMVxuICAgIGNvbnN0IGl0ZW1JbmRleCA9IChhY3RpdmVJbmRleCArIGRlbHRhKSAlIHRoaXMuX2l0ZW1zLmxlbmd0aFxuXG4gICAgcmV0dXJuIGl0ZW1JbmRleCA9PT0gLTEgP1xuICAgICAgdGhpcy5faXRlbXNbdGhpcy5faXRlbXMubGVuZ3RoIC0gMV0gOiB0aGlzLl9pdGVtc1tpdGVtSW5kZXhdXG4gIH1cblxuICBfdHJpZ2dlclNsaWRlRXZlbnQocmVsYXRlZFRhcmdldCwgZXZlbnREaXJlY3Rpb25OYW1lKSB7XG4gICAgY29uc3QgdGFyZ2V0SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgocmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBmcm9tSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0FDVElWRV9JVEVNKSlcbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9TTElERSwge1xuICAgICAgcmVsYXRlZFRhcmdldCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogZnJvbUluZGV4LFxuICAgICAgdG86IHRhcmdldEluZGV4XG4gICAgfSlcblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkZUV2ZW50KVxuXG4gICAgcmV0dXJuIHNsaWRlRXZlbnRcbiAgfVxuXG4gIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGluZGljYXRvcnMgPSBbXS5zbGljZS5jYWxsKHRoaXMuX2luZGljYXRvcnNFbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfQUNUSVZFKSlcbiAgICAgICQoaW5kaWNhdG9ycykucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG5cbiAgICAgIGNvbnN0IG5leHRJbmRpY2F0b3IgPSB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudC5jaGlsZHJlbltcbiAgICAgICAgdGhpcy5fZ2V0SXRlbUluZGV4KGVsZW1lbnQpXG4gICAgICBdXG5cbiAgICAgIGlmIChuZXh0SW5kaWNhdG9yKSB7XG4gICAgICAgICQobmV4dEluZGljYXRvcikuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX3VwZGF0ZUludGVydmFsKCkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9BQ1RJVkVfSVRFTSlcblxuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudEludGVydmFsID0gcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW50ZXJ2YWwnKSwgMTApXG5cbiAgICBpZiAoZWxlbWVudEludGVydmFsKSB7XG4gICAgICB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsID0gdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuaW50ZXJ2YWxcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsIHx8IHRoaXMuX2NvbmZpZy5pbnRlcnZhbFxuICAgIH1cbiAgfVxuXG4gIF9zbGlkZShkaXJlY3Rpb24sIGVsZW1lbnQpIHtcbiAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZWxlbWVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0FDVElWRV9JVEVNKVxuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRJbmRleCA9IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBhY3RpdmVFbGVtZW50ICYmXG4gICAgICB0aGlzLl9nZXRJdGVtQnlEaXJlY3Rpb24oZGlyZWN0aW9uLCBhY3RpdmVFbGVtZW50KVxuICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpXG4gICAgY29uc3QgaXNDeWNsaW5nID0gQm9vbGVhbih0aGlzLl9pbnRlcnZhbClcblxuICAgIGxldCBkaXJlY3Rpb25hbENsYXNzTmFtZVxuICAgIGxldCBvcmRlckNsYXNzTmFtZVxuICAgIGxldCBldmVudERpcmVjdGlvbk5hbWVcblxuICAgIGlmIChkaXJlY3Rpb24gPT09IERJUkVDVElPTl9ORVhUKSB7XG4gICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZSA9IENMQVNTX05BTUVfTEVGVFxuICAgICAgb3JkZXJDbGFzc05hbWUgPSBDTEFTU19OQU1FX05FWFRcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERJUkVDVElPTl9MRUZUXG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9SSUdIVFxuICAgICAgb3JkZXJDbGFzc05hbWUgPSBDTEFTU19OQU1FX1BSRVZcbiAgICAgIGV2ZW50RGlyZWN0aW9uTmFtZSA9IERJUkVDVElPTl9SSUdIVFxuICAgIH1cblxuICAgIGlmIChuZXh0RWxlbWVudCAmJiAkKG5leHRFbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0FDVElWRSkpIHtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBzbGlkZUV2ZW50ID0gdGhpcy5fdHJpZ2dlclNsaWRlRXZlbnQobmV4dEVsZW1lbnQsIGV2ZW50RGlyZWN0aW9uTmFtZSlcbiAgICBpZiAoc2xpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgLy8gU29tZSB3ZWlyZG5lc3MgaXMgaGFwcGVuaW5nLCBzbyB3ZSBiYWlsXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9pc1NsaWRpbmcgPSB0cnVlXG5cbiAgICBpZiAoaXNDeWNsaW5nKSB7XG4gICAgICB0aGlzLnBhdXNlKClcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50KVxuICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudFxuXG4gICAgY29uc3Qgc2xpZEV2ZW50ID0gJC5FdmVudChFVkVOVF9TTElELCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgIGRpcmVjdGlvbjogZXZlbnREaXJlY3Rpb25OYW1lLFxuICAgICAgZnJvbTogYWN0aXZlRWxlbWVudEluZGV4LFxuICAgICAgdG86IG5leHRFbGVtZW50SW5kZXhcbiAgICB9KVxuXG4gICAgaWYgKCQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TTElERSkpIHtcbiAgICAgICQobmV4dEVsZW1lbnQpLmFkZENsYXNzKG9yZGVyQ2xhc3NOYW1lKVxuXG4gICAgICBVdGlsLnJlZmxvdyhuZXh0RWxlbWVudClcblxuICAgICAgJChhY3RpdmVFbGVtZW50KS5hZGRDbGFzcyhkaXJlY3Rpb25hbENsYXNzTmFtZSlcbiAgICAgICQobmV4dEVsZW1lbnQpLmFkZENsYXNzKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKVxuXG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KGFjdGl2ZUVsZW1lbnQpXG5cbiAgICAgICQoYWN0aXZlRWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgICAgICAgJChuZXh0RWxlbWVudClcbiAgICAgICAgICAgIC5yZW1vdmVDbGFzcyhgJHtkaXJlY3Rpb25hbENsYXNzTmFtZX0gJHtvcmRlckNsYXNzTmFtZX1gKVxuICAgICAgICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICAgICAgJChhY3RpdmVFbGVtZW50KS5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0FDVElWRX0gJHtvcmRlckNsYXNzTmFtZX0gJHtkaXJlY3Rpb25hbENsYXNzTmFtZX1gKVxuXG4gICAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcblxuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNsaWRFdmVudCksIDApXG4gICAgICAgIH0pXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgICQoYWN0aXZlRWxlbWVudCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAkKG5leHRFbGVtZW50KS5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcblxuICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2VcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzbGlkRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgdGhpcy5jeWNsZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBsZXQgX2NvbmZpZyA9IHtcbiAgICAgICAgLi4uRGVmYXVsdCxcbiAgICAgICAgLi4uJCh0aGlzKS5kYXRhKClcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIF9jb25maWcgPSB7XG4gICAgICAgICAgLi4uX2NvbmZpZyxcbiAgICAgICAgICAuLi5jb25maWdcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBhY3Rpb24gPSB0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyA/IGNvbmZpZyA6IF9jb25maWcuc2xpZGVcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgQ2Fyb3VzZWwodGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZGF0YS50byhjb25maWcpXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVthY3Rpb25dID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7YWN0aW9ufVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbYWN0aW9uXSgpXG4gICAgICB9IGVsc2UgaWYgKF9jb25maWcuaW50ZXJ2YWwgJiYgX2NvbmZpZy5yaWRlKSB7XG4gICAgICAgIGRhdGEucGF1c2UoKVxuICAgICAgICBkYXRhLmN5Y2xlKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIF9kYXRhQXBpQ2xpY2tIYW5kbGVyKGV2ZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcblxuICAgIGlmICghc2VsZWN0b3IpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRhcmdldCA9ICQoc2VsZWN0b3IpWzBdXG5cbiAgICBpZiAoIXRhcmdldCB8fCAhJCh0YXJnZXQpLmhhc0NsYXNzKENMQVNTX05BTUVfQ0FST1VTRUwpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAuLi4kKHRhcmdldCkuZGF0YSgpLFxuICAgICAgLi4uJCh0aGlzKS5kYXRhKClcbiAgICB9XG4gICAgY29uc3Qgc2xpZGVJbmRleCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdkYXRhLXNsaWRlLXRvJylcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICBjb25maWcuaW50ZXJ2YWwgPSBmYWxzZVxuICAgIH1cblxuICAgIENhcm91c2VsLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRhcmdldCksIGNvbmZpZylcblxuICAgIGlmIChzbGlkZUluZGV4KSB7XG4gICAgICAkKHRhcmdldCkuZGF0YShEQVRBX0tFWSkudG8oc2xpZGVJbmRleClcbiAgICB9XG5cbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBDYXJvdXNlbC5fZGF0YUFwaUNsaWNrSGFuZGxlcilcblxuJCh3aW5kb3cpLm9uKEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgY29uc3QgY2Fyb3VzZWxzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfUklERSkpXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjYXJvdXNlbHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBjb25zdCAkY2Fyb3VzZWwgPSAkKGNhcm91c2Vsc1tpXSlcbiAgICBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJGNhcm91c2VsLCAkY2Fyb3VzZWwuZGF0YSgpKVxuICB9XG59KVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBDYXJvdXNlbC5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gQ2Fyb3VzZWxcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gQ2Fyb3VzZWwuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBDYXJvdXNlbFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjEpOiBjb2xsYXBzZS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ2NvbGxhcHNlJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLmNvbGxhcHNlJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5cbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRSA9ICdjb2xsYXBzZSdcbmNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJ1xuY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTRUQgPSAnY29sbGFwc2VkJ1xuXG5jb25zdCBESU1FTlNJT05fV0lEVEggPSAnd2lkdGgnXG5jb25zdCBESU1FTlNJT05fSEVJR0hUID0gJ2hlaWdodCdcblxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5cbmNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLnNob3csIC5jb2xsYXBzaW5nJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwiY29sbGFwc2VcIl0nXG5cbmNvbnN0IERlZmF1bHQgPSB7XG4gIHRvZ2dsZTogdHJ1ZSxcbiAgcGFyZW50OiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgdG9nZ2xlOiAnYm9vbGVhbicsXG4gIHBhcmVudDogJyhzdHJpbmd8ZWxlbWVudCknXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIENvbGxhcHNlIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpXG4gICAgdGhpcy5fdHJpZ2dlckFycmF5ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxuICAgICAgYFtkYXRhLXRvZ2dsZT1cImNvbGxhcHNlXCJdW2hyZWY9XCIjJHtlbGVtZW50LmlkfVwiXSxgICtcbiAgICAgIGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXRhcmdldD1cIiMke2VsZW1lbnQuaWR9XCJdYFxuICAgICkpXG5cbiAgICBjb25zdCB0b2dnbGVMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSlcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdG9nZ2xlTGlzdC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgY29uc3QgZWxlbSA9IHRvZ2dsZUxpc3RbaV1cbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW0pXG4gICAgICBjb25zdCBmaWx0ZXJFbGVtZW50ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAgICAgLmZpbHRlcihmb3VuZEVsZW0gPT4gZm91bmRFbGVtID09PSBlbGVtZW50KVxuXG4gICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3JcbiAgICAgICAgdGhpcy5fdHJpZ2dlckFycmF5LnB1c2goZWxlbSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50ID8gdGhpcy5fZ2V0UGFyZW50KCkgOiBudWxsXG5cbiAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0aGlzLl9lbGVtZW50LCB0aGlzLl90cmlnZ2VyQXJyYXkpXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9XG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKCkge1xuICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHRoaXMuaGlkZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2hvdygpXG4gICAgfVxuICB9XG5cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGxldCBhY3RpdmVzXG4gICAgbGV0IGFjdGl2ZXNEYXRhXG5cbiAgICBpZiAodGhpcy5fcGFyZW50KSB7XG4gICAgICBhY3RpdmVzID0gW10uc2xpY2UuY2FsbCh0aGlzLl9wYXJlbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9BQ1RJVkVTKSlcbiAgICAgICAgLmZpbHRlcihlbGVtID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFyZW50JykgPT09IHRoaXMuX2NvbmZpZy5wYXJlbnRcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZWxlbS5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DT0xMQVBTRSlcbiAgICAgICAgfSlcblxuICAgICAgaWYgKGFjdGl2ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGFjdGl2ZXMgPSBudWxsXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGFjdGl2ZXMpIHtcbiAgICAgIGFjdGl2ZXNEYXRhID0gJChhY3RpdmVzKS5ub3QodGhpcy5fc2VsZWN0b3IpLmRhdGEoREFUQV9LRVkpXG4gICAgICBpZiAoYWN0aXZlc0RhdGEgJiYgYWN0aXZlc0RhdGEuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzdGFydEV2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XKVxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzdGFydEV2ZW50KVxuICAgIGlmIChzdGFydEV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoYWN0aXZlcykge1xuICAgICAgQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQoYWN0aXZlcykubm90KHRoaXMuX3NlbGVjdG9yKSwgJ2hpZGUnKVxuICAgICAgaWYgKCFhY3RpdmVzRGF0YSkge1xuICAgICAgICAkKGFjdGl2ZXMpLmRhdGEoREFUQV9LRVksIG51bGwpXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX0NPTExBUFNFKVxuICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORylcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDBcblxuICAgIGlmICh0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAkKHRoaXMuX3RyaWdnZXJBcnJheSlcbiAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VEKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIHRydWUpXG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORylcbiAgICAgICAgLmFkZENsYXNzKGAke0NMQVNTX05BTUVfQ09MTEFQU0V9ICR7Q0xBU1NfTkFNRV9TSE9XfWApXG5cbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnXG5cbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcblxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX1NIT1dOKVxuICAgIH1cblxuICAgIGNvbnN0IGNhcGl0YWxpemVkRGltZW5zaW9uID0gZGltZW5zaW9uWzBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoMSlcbiAgICBjb25zdCBzY3JvbGxTaXplID0gYHNjcm9sbCR7Y2FwaXRhbGl6ZWREaW1lbnNpb259YFxuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudFtzY3JvbGxTaXplXX1weGBcbiAgfVxuXG4gIGhpZGUoKSB7XG4gICAgaWYgKHRoaXMuX2lzVHJhbnNpdGlvbmluZyB8fFxuICAgICAgISQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3Qgc3RhcnRFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSlcbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc3RhcnRFdmVudClcbiAgICBpZiAoc3RhcnRFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKClcblxuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IGAke3RoaXMuX2VsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZGltZW5zaW9uXX1weGBcblxuICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKVxuICAgICAgLnJlbW92ZUNsYXNzKGAke0NMQVNTX05BTUVfQ09MTEFQU0V9ICR7Q0xBU1NfTkFNRV9TSE9XfWApXG5cbiAgICBjb25zdCB0cmlnZ2VyQXJyYXlMZW5ndGggPSB0aGlzLl90cmlnZ2VyQXJyYXkubGVuZ3RoXG4gICAgaWYgKHRyaWdnZXJBcnJheUxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJpZ2dlckFycmF5TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJpZ2dlciA9IHRoaXMuX3RyaWdnZXJBcnJheVtpXVxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFV0aWwuZ2V0U2VsZWN0b3JGcm9tRWxlbWVudCh0cmlnZ2VyKVxuXG4gICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0ICRlbGVtID0gJChbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKSlcbiAgICAgICAgICBpZiAoISRlbGVtLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgICAgICQodHJpZ2dlcikuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9DT0xMQVBTRUQpXG4gICAgICAgICAgICAgIC5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRUcmFuc2l0aW9uaW5nKHRydWUpXG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhbnNpdGlvbmluZyhmYWxzZSlcbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0lORylcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQ09MTEFQU0UpXG4gICAgICAgIC50cmlnZ2VyKEVWRU5UX0hJRERFTilcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJ1xuICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICB9XG5cbiAgc2V0VHJhbnNpdGlvbmluZyhpc1RyYW5zaXRpb25pbmcpIHtcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBpc1RyYW5zaXRpb25pbmdcbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuXG4gICAgdGhpcy5fY29uZmlnID0gbnVsbFxuICAgIHRoaXMuX3BhcmVudCA9IG51bGxcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IG51bGxcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBudWxsXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKSAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKE5BTUUsIGNvbmZpZywgRGVmYXVsdFR5cGUpXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERpbWVuc2lvbigpIHtcbiAgICBjb25zdCBoYXNXaWR0aCA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoRElNRU5TSU9OX1dJRFRIKVxuICAgIHJldHVybiBoYXNXaWR0aCA/IERJTUVOU0lPTl9XSURUSCA6IERJTUVOU0lPTl9IRUlHSFRcbiAgfVxuXG4gIF9nZXRQYXJlbnQoKSB7XG4gICAgbGV0IHBhcmVudFxuXG4gICAgaWYgKFV0aWwuaXNFbGVtZW50KHRoaXMuX2NvbmZpZy5wYXJlbnQpKSB7XG4gICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50XG5cbiAgICAgIC8vIEl0J3MgYSBqUXVlcnkgb2JqZWN0XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5wYXJlbnQuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9jb25maWcucGFyZW50WzBdXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcmVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGhpcy5fY29uZmlnLnBhcmVudClcbiAgICB9XG5cbiAgICBjb25zdCBzZWxlY3RvciA9IGBbZGF0YS10b2dnbGU9XCJjb2xsYXBzZVwiXVtkYXRhLXBhcmVudD1cIiR7dGhpcy5fY29uZmlnLnBhcmVudH1cIl1gXG4gICAgY29uc3QgY2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcblxuICAgICQoY2hpbGRyZW4pLmVhY2goKGksIGVsZW1lbnQpID0+IHtcbiAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhcbiAgICAgICAgQ29sbGFwc2UuX2dldFRhcmdldEZyb21FbGVtZW50KGVsZW1lbnQpLFxuICAgICAgICBbZWxlbWVudF1cbiAgICAgIClcbiAgICB9KVxuXG4gICAgcmV0dXJuIHBhcmVudFxuICB9XG5cbiAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhlbGVtZW50LCB0cmlnZ2VyQXJyYXkpIHtcbiAgICBjb25zdCBpc09wZW4gPSAkKGVsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICh0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAkKHRyaWdnZXJBcnJheSlcbiAgICAgICAgLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKVxuICAgICAgICAuYXR0cignYXJpYS1leHBhbmRlZCcsIGlzT3BlbilcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIF9nZXRUYXJnZXRGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKSA6IG51bGxcbiAgfVxuXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgJGVsZW1lbnQgPSAkKHRoaXMpXG4gICAgICBsZXQgZGF0YSA9ICRlbGVtZW50LmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kZWxlbWVudC5kYXRhKCksXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhICYmIF9jb25maWcudG9nZ2xlICYmIHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICBfY29uZmlnLnRvZ2dsZSA9IGZhbHNlXG4gICAgICB9XG5cbiAgICAgIGlmICghZGF0YSkge1xuICAgICAgICBkYXRhID0gbmV3IENvbGxhcHNlKHRoaXMsIF9jb25maWcpXG4gICAgICAgICRlbGVtZW50LmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgaWYgKGV2ZW50LmN1cnJlbnRUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICB9XG5cbiAgY29uc3QgJHRyaWdnZXIgPSAkKHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMpXG4gIGNvbnN0IHNlbGVjdG9ycyA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpXG5cbiAgJChzZWxlY3RvcnMpLmVhY2goZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0ICR0YXJnZXQgPSAkKHRoaXMpXG4gICAgY29uc3QgZGF0YSA9ICR0YXJnZXQuZGF0YShEQVRBX0tFWSlcbiAgICBjb25zdCBjb25maWcgPSBkYXRhID8gJ3RvZ2dsZScgOiAkdHJpZ2dlci5kYXRhKClcbiAgICBDb2xsYXBzZS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHRhcmdldCwgY29uZmlnKVxuICB9KVxufSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gQ29sbGFwc2UuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IENvbGxhcHNlXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIENvbGxhcHNlLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgQ29sbGFwc2VcbiIsIi8qKiFcbiAqIEBmaWxlT3ZlcnZpZXcgS2lja2FzcyBsaWJyYXJ5IHRvIGNyZWF0ZSBhbmQgcGxhY2UgcG9wcGVycyBuZWFyIHRoZWlyIHJlZmVyZW5jZSBlbGVtZW50cy5cbiAqIEB2ZXJzaW9uIDEuMTYuMVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBGZWRlcmljbyBaaXZvbG8gYW5kIGNvbnRyaWJ1dG9yc1xuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAqIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICogU09GVFdBUkUuXG4gKi9cbnZhciBpc0Jyb3dzZXIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuXG52YXIgdGltZW91dER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICB2YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgIGlmIChpc0Jyb3dzZXIgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKGxvbmdlclRpbWVvdXRCcm93c2Vyc1tpXSkgPj0gMCkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9XG4gIHJldHVybiAwO1xufSgpO1xuXG5mdW5jdGlvbiBtaWNyb3Rhc2tEZWJvdW5jZShmbikge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIHdpbmRvdy5Qcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhbGxlZCA9IGZhbHNlO1xuICAgICAgZm4oKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNjaGVkdWxlZCkge1xuICAgICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0sIHRpbWVvdXREdXJhdGlvbik7XG4gICAgfVxuICB9O1xufVxuXG52YXIgc3VwcG9ydHNNaWNyb1Rhc2tzID0gaXNCcm93c2VyICYmIHdpbmRvdy5Qcm9taXNlO1xuXG4vKipcbiogQ3JlYXRlIGEgZGVib3VuY2VkIHZlcnNpb24gb2YgYSBtZXRob2QsIHRoYXQncyBhc3luY2hyb25vdXNseSBkZWZlcnJlZFxuKiBidXQgY2FsbGVkIGluIHRoZSBtaW5pbXVtIHRpbWUgcG9zc2libGUuXG4qXG4qIEBtZXRob2RcbiogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuKiBAYXJndW1lbnQge0Z1bmN0aW9ufSBmblxuKiBAcmV0dXJucyB7RnVuY3Rpb259XG4qL1xudmFyIGRlYm91bmNlID0gc3VwcG9ydHNNaWNyb1Rhc2tzID8gbWljcm90YXNrRGVib3VuY2UgOiB0YXNrRGVib3VuY2U7XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIHZhcmlhYmxlIGlzIGEgZnVuY3Rpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QW55fSBmdW5jdGlvblRvQ2hlY2sgLSB2YXJpYWJsZSB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGFuc3dlciB0bzogaXMgYSBmdW5jdGlvbj9cbiAqL1xuZnVuY3Rpb24gaXNGdW5jdGlvbihmdW5jdGlvblRvQ2hlY2spIHtcbiAgdmFyIGdldFR5cGUgPSB7fTtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9DaGVjayAmJiBnZXRUeXBlLnRvU3RyaW5nLmNhbGwoZnVuY3Rpb25Ub0NoZWNrKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbn1cblxuLyoqXG4gKiBHZXQgQ1NTIGNvbXB1dGVkIHByb3BlcnR5IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHByb3BlcnR5XG4gKi9cbmZ1bmN0aW9uIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50LCBwcm9wZXJ0eSkge1xuICBpZiAoZWxlbWVudC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuICB2YXIgd2luZG93ID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICB2YXIgY3NzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCwgbnVsbCk7XG4gIHJldHVybiBwcm9wZXJ0eSA/IGNzc1twcm9wZXJ0eV0gOiBjc3M7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyZW50Tm9kZSBvciB0aGUgaG9zdCBvZiB0aGUgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldFBhcmVudE5vZGUoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbiAgcmV0dXJuIGVsZW1lbnQucGFyZW50Tm9kZSB8fCBlbGVtZW50Lmhvc3Q7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgc2Nyb2xsaW5nIHBhcmVudCBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gc2Nyb2xsIHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAvLyBSZXR1cm4gYm9keSwgYGdldFNjcm9sbGAgd2lsbCB0YWtlIGNhcmUgdG8gZ2V0IHRoZSBjb3JyZWN0IGBzY3JvbGxUb3BgIGZyb20gaXRcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH1cblxuICBzd2l0Y2ggKGVsZW1lbnQubm9kZU5hbWUpIHtcbiAgICBjYXNlICdIVE1MJzpcbiAgICBjYXNlICdCT0RZJzpcbiAgICAgIHJldHVybiBlbGVtZW50Lm93bmVyRG9jdW1lbnQuYm9keTtcbiAgICBjYXNlICcjZG9jdW1lbnQnOlxuICAgICAgcmV0dXJuIGVsZW1lbnQuYm9keTtcbiAgfVxuXG4gIC8vIEZpcmVmb3ggd2FudCB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxuXG4gIHZhciBfZ2V0U3R5bGVDb21wdXRlZFByb3AgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWxlbWVudCksXG4gICAgICBvdmVyZmxvdyA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvdyxcbiAgICAgIG92ZXJmbG93WCA9IF9nZXRTdHlsZUNvbXB1dGVkUHJvcC5vdmVyZmxvd1gsXG4gICAgICBvdmVyZmxvd1kgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dZO1xuXG4gIGlmICgvKGF1dG98c2Nyb2xsfG92ZXJsYXkpLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKSkge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG5cbiAgcmV0dXJuIGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByZWZlcmVuY2Ugbm9kZSBvZiB0aGUgcmVmZXJlbmNlIG9iamVjdCwgb3IgdGhlIHJlZmVyZW5jZSBvYmplY3QgaXRzZWxmLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gcmVmZXJlbmNlIC0gdGhlIHJlZmVyZW5jZSBlbGVtZW50ICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpIHtcbiAgcmV0dXJuIHJlZmVyZW5jZSAmJiByZWZlcmVuY2UucmVmZXJlbmNlTm9kZSA/IHJlZmVyZW5jZS5yZWZlcmVuY2VOb2RlIDogcmVmZXJlbmNlO1xufVxuXG52YXIgaXNJRTExID0gaXNCcm93c2VyICYmICEhKHdpbmRvdy5NU0lucHV0TWV0aG9kQ29udGV4dCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUpO1xudmFyIGlzSUUxMCA9IGlzQnJvd3NlciAmJiAvTVNJRSAxMC8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHRoZSBicm93c2VyIGlzIEludGVybmV0IEV4cGxvcmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge051bWJlcn0gdmVyc2lvbiB0byBjaGVja1xuICogQHJldHVybnMge0Jvb2xlYW59IGlzSUVcbiAqL1xuZnVuY3Rpb24gaXNJRSh2ZXJzaW9uKSB7XG4gIGlmICh2ZXJzaW9uID09PSAxMSkge1xuICAgIHJldHVybiBpc0lFMTE7XG4gIH1cbiAgaWYgKHZlcnNpb24gPT09IDEwKSB7XG4gICAgcmV0dXJuIGlzSUUxMDtcbiAgfVxuICByZXR1cm4gaXNJRTExIHx8IGlzSUUxMDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBvZmZzZXQgcGFyZW50IG9mIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtFbGVtZW50fSBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldFBhcmVudChlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICB2YXIgbm9PZmZzZXRQYXJlbnQgPSBpc0lFKDEwKSA/IGRvY3VtZW50LmJvZHkgOiBudWxsO1xuXG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudCB8fCBudWxsO1xuICAvLyBTa2lwIGhpZGRlbiBlbGVtZW50cyB3aGljaCBkb24ndCBoYXZlIGFuIG9mZnNldFBhcmVudFxuICB3aGlsZSAob2Zmc2V0UGFyZW50ID09PSBub09mZnNldFBhcmVudCAmJiBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZykge1xuICAgIG9mZnNldFBhcmVudCA9IChlbGVtZW50ID0gZWxlbWVudC5uZXh0RWxlbWVudFNpYmxpbmcpLm9mZnNldFBhcmVudDtcbiAgfVxuXG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICByZXR1cm4gZWxlbWVudCA/IGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIH1cblxuICAvLyAub2Zmc2V0UGFyZW50IHdpbGwgcmV0dXJuIHRoZSBjbG9zZXN0IFRILCBURCBvciBUQUJMRSBpbiBjYXNlXG4gIC8vIG5vIG9mZnNldFBhcmVudCBpcyBwcmVzZW50LCBJIGhhdGUgdGhpcyBqb2IuLi5cbiAgaWYgKFsnVEgnLCAnVEQnLCAnVEFCTEUnXS5pbmRleE9mKG9mZnNldFBhcmVudC5ub2RlTmFtZSkgIT09IC0xICYmIGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShvZmZzZXRQYXJlbnQsICdwb3NpdGlvbicpID09PSAnc3RhdGljJykge1xuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQob2Zmc2V0UGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRQYXJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzT2Zmc2V0Q29udGFpbmVyKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbm9kZU5hbWUgPT09ICdIVE1MJyB8fCBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZCkgPT09IGVsZW1lbnQ7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIHJvb3Qgbm9kZSAoZG9jdW1lbnQsIHNoYWRvd0RPTSByb290KSBvZiB0aGUgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBub2RlXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gcm9vdCBub2RlXG4gKi9cbmZ1bmN0aW9uIGdldFJvb3Qobm9kZSkge1xuICBpZiAobm9kZS5wYXJlbnROb2RlICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdldFJvb3Qobm9kZS5wYXJlbnROb2RlKTtcbiAgfVxuXG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBvZmZzZXQgcGFyZW50IGNvbW1vbiB0byB0aGUgdHdvIHByb3ZpZGVkIG5vZGVzXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQxXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQyXG4gKiBAcmV0dXJucyB7RWxlbWVudH0gY29tbW9uIG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZWxlbWVudDIpIHtcbiAgLy8gVGhpcyBjaGVjayBpcyBuZWVkZWQgdG8gYXZvaWQgZXJyb3JzIGluIGNhc2Ugb25lIG9mIHRoZSBlbGVtZW50cyBpc24ndCBkZWZpbmVkIGZvciBhbnkgcmVhc29uXG4gIGlmICghZWxlbWVudDEgfHwgIWVsZW1lbnQxLm5vZGVUeXBlIHx8ICFlbGVtZW50MiB8fCAhZWxlbWVudDIubm9kZVR5cGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgLy8gSGVyZSB3ZSBtYWtlIHN1cmUgdG8gZ2l2ZSBhcyBcInN0YXJ0XCIgdGhlIGVsZW1lbnQgdGhhdCBjb21lcyBmaXJzdCBpbiB0aGUgRE9NXG4gIHZhciBvcmRlciA9IGVsZW1lbnQxLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGVsZW1lbnQyKSAmIE5vZGUuRE9DVU1FTlRfUE9TSVRJT05fRk9MTE9XSU5HO1xuICB2YXIgc3RhcnQgPSBvcmRlciA/IGVsZW1lbnQxIDogZWxlbWVudDI7XG4gIHZhciBlbmQgPSBvcmRlciA/IGVsZW1lbnQyIDogZWxlbWVudDE7XG5cbiAgLy8gR2V0IGNvbW1vbiBhbmNlc3RvciBjb250YWluZXJcbiAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgcmFuZ2Uuc2V0U3RhcnQoc3RhcnQsIDApO1xuICByYW5nZS5zZXRFbmQoZW5kLCAwKTtcbiAgdmFyIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyID0gcmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG5cbiAgLy8gQm90aCBub2RlcyBhcmUgaW5zaWRlICNkb2N1bWVudFxuXG4gIGlmIChlbGVtZW50MSAhPT0gY29tbW9uQW5jZXN0b3JDb250YWluZXIgJiYgZWxlbWVudDIgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyIHx8IHN0YXJ0LmNvbnRhaW5zKGVuZCkpIHtcbiAgICBpZiAoaXNPZmZzZXRDb250YWluZXIoY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gY29tbW9uQW5jZXN0b3JDb250YWluZXI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldE9mZnNldFBhcmVudChjb21tb25BbmNlc3RvckNvbnRhaW5lcik7XG4gIH1cblxuICAvLyBvbmUgb2YgdGhlIG5vZGVzIGlzIGluc2lkZSBzaGFkb3dET00sIGZpbmQgd2hpY2ggb25lXG4gIHZhciBlbGVtZW50MXJvb3QgPSBnZXRSb290KGVsZW1lbnQxKTtcbiAgaWYgKGVsZW1lbnQxcm9vdC5ob3N0KSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDFyb290Lmhvc3QsIGVsZW1lbnQyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmluZENvbW1vbk9mZnNldFBhcmVudChlbGVtZW50MSwgZ2V0Um9vdChlbGVtZW50MikuaG9zdCk7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgdmFsdWUgb2YgdGhlIGdpdmVuIGVsZW1lbnQgaW4gdGhlIGdpdmVuIHNpZGUgKHRvcCBhbmQgbGVmdClcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHNpZGUgYHRvcGAgb3IgYGxlZnRgXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbW91bnQgb2Ygc2Nyb2xsZWQgcGl4ZWxzXG4gKi9cbmZ1bmN0aW9uIGdldFNjcm9sbChlbGVtZW50KSB7XG4gIHZhciBzaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAndG9wJztcblxuICB2YXIgdXBwZXJTaWRlID0gc2lkZSA9PT0gJ3RvcCcgPyAnc2Nyb2xsVG9wJyA6ICdzY3JvbGxMZWZ0JztcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcblxuICBpZiAobm9kZU5hbWUgPT09ICdCT0RZJyB8fCBub2RlTmFtZSA9PT0gJ0hUTUwnKSB7XG4gICAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciBzY3JvbGxpbmdFbGVtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50LnNjcm9sbGluZ0VsZW1lbnQgfHwgaHRtbDtcbiAgICByZXR1cm4gc2Nyb2xsaW5nRWxlbWVudFt1cHBlclNpZGVdO1xuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnRbdXBwZXJTaWRlXTtcbn1cblxuLypcbiAqIFN1bSBvciBzdWJ0cmFjdCB0aGUgZWxlbWVudCBzY3JvbGwgdmFsdWVzIChsZWZ0IGFuZCB0b3ApIGZyb20gYSBnaXZlbiByZWN0IG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHJlY3QgLSBSZWN0IG9iamVjdCB5b3Ugd2FudCB0byBjaGFuZ2VcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZWxlbWVudCBmcm9tIHRoZSBmdW5jdGlvbiByZWFkcyB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHBhcmFtIHtCb29sZWFufSBzdWJ0cmFjdCAtIHNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIHN1YnRyYWN0IHRoZSBzY3JvbGwgdmFsdWVzXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY3QgLSBUaGUgbW9kaWZpZXIgcmVjdCBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5jbHVkZVNjcm9sbChyZWN0LCBlbGVtZW50KSB7XG4gIHZhciBzdWJ0cmFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG5cbiAgdmFyIHNjcm9sbFRvcCA9IGdldFNjcm9sbChlbGVtZW50LCAndG9wJyk7XG4gIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gIHZhciBtb2RpZmllciA9IHN1YnRyYWN0ID8gLTEgOiAxO1xuICByZWN0LnRvcCArPSBzY3JvbGxUb3AgKiBtb2RpZmllcjtcbiAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0ICogbW9kaWZpZXI7XG4gIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZXR1cm4gcmVjdDtcbn1cblxuLypcbiAqIEhlbHBlciB0byBkZXRlY3QgYm9yZGVycyBvZiBhIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Q1NTU3R5bGVEZWNsYXJhdGlvbn0gc3R5bGVzXG4gKiBSZXN1bHQgb2YgYGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eWAgb24gdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBheGlzIC0gYHhgIG9yIGB5YFxuICogQHJldHVybiB7bnVtYmVyfSBib3JkZXJzIC0gVGhlIGJvcmRlcnMgc2l6ZSBvZiB0aGUgZ2l2ZW4gYXhpc1xuICovXG5cbmZ1bmN0aW9uIGdldEJvcmRlcnNTaXplKHN0eWxlcywgYXhpcykge1xuICB2YXIgc2lkZUEgPSBheGlzID09PSAneCcgPyAnTGVmdCcgOiAnVG9wJztcbiAgdmFyIHNpZGVCID0gc2lkZUEgPT09ICdMZWZ0JyA/ICdSaWdodCcgOiAnQm90dG9tJztcblxuICByZXR1cm4gcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQSArICdXaWR0aCddKSArIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUIgKyAnV2lkdGgnXSk7XG59XG5cbmZ1bmN0aW9uIGdldFNpemUoYXhpcywgYm9keSwgaHRtbCwgY29tcHV0ZWRTdHlsZSkge1xuICByZXR1cm4gTWF0aC5tYXgoYm9keVsnb2Zmc2V0JyArIGF4aXNdLCBib2R5WydzY3JvbGwnICsgYXhpc10sIGh0bWxbJ2NsaWVudCcgKyBheGlzXSwgaHRtbFsnb2Zmc2V0JyArIGF4aXNdLCBodG1sWydzY3JvbGwnICsgYXhpc10sIGlzSUUoMTApID8gcGFyc2VJbnQoaHRtbFsnb2Zmc2V0JyArIGF4aXNdKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnVG9wJyA6ICdMZWZ0JyldKSArIHBhcnNlSW50KGNvbXB1dGVkU3R5bGVbJ21hcmdpbicgKyAoYXhpcyA9PT0gJ0hlaWdodCcgPyAnQm90dG9tJyA6ICdSaWdodCcpXSkgOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoZG9jdW1lbnQpIHtcbiAgdmFyIGJvZHkgPSBkb2N1bWVudC5ib2R5O1xuICB2YXIgaHRtbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgdmFyIGNvbXB1dGVkU3R5bGUgPSBpc0lFKDEwKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblxuICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn07XG5cbi8qKlxuICogR2l2ZW4gZWxlbWVudCBvZmZzZXRzLCBnZW5lcmF0ZSBhbiBvdXRwdXQgc2ltaWxhciB0byBnZXRCb3VuZGluZ0NsaWVudFJlY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvZmZzZXRzXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDbGllbnRSZWN0IGxpa2Ugb3V0cHV0XG4gKi9cbmZ1bmN0aW9uIGdldENsaWVudFJlY3Qob2Zmc2V0cykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIG9mZnNldHMsIHtcbiAgICByaWdodDogb2Zmc2V0cy5sZWZ0ICsgb2Zmc2V0cy53aWR0aCxcbiAgICBib3R0b206IG9mZnNldHMudG9wICsgb2Zmc2V0cy5oZWlnaHRcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IGJvdW5kaW5nIGNsaWVudCByZWN0IG9mIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge09iamVjdH0gY2xpZW50IHJlY3RcbiAqL1xuZnVuY3Rpb24gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQpIHtcbiAgdmFyIHJlY3QgPSB7fTtcblxuICAvLyBJRTEwIDEwIEZJWDogUGxlYXNlLCBkb24ndCBhc2ssIHRoZSBlbGVtZW50IGlzbid0XG4gIC8vIGNvbnNpZGVyZWQgaW4gRE9NIGluIHNvbWUgY2lyY3Vtc3RhbmNlcy4uLlxuICAvLyBUaGlzIGlzbid0IHJlcHJvZHVjaWJsZSBpbiBJRTEwIGNvbXBhdGliaWxpdHkgbW9kZSBvZiBJRTExXG4gIHRyeSB7XG4gICAgaWYgKGlzSUUoMTApKSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICAgICAgdmFyIHNjcm9sbExlZnQgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ2xlZnQnKTtcbiAgICAgIHJlY3QudG9wICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QubGVmdCArPSBzY3JvbGxMZWZ0O1xuICAgICAgcmVjdC5ib3R0b20gKz0gc2Nyb2xsVG9wO1xuICAgICAgcmVjdC5yaWdodCArPSBzY3JvbGxMZWZ0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgdmFyIHJlc3VsdCA9IHtcbiAgICBsZWZ0OiByZWN0LmxlZnQsXG4gICAgdG9wOiByZWN0LnRvcCxcbiAgICB3aWR0aDogcmVjdC5yaWdodCAtIHJlY3QubGVmdCxcbiAgICBoZWlnaHQ6IHJlY3QuYm90dG9tIC0gcmVjdC50b3BcbiAgfTtcblxuICAvLyBzdWJ0cmFjdCBzY3JvbGxiYXIgc2l6ZSBmcm9tIHNpemVzXG4gIHZhciBzaXplcyA9IGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJyA/IGdldFdpbmRvd1NpemVzKGVsZW1lbnQub3duZXJEb2N1bWVudCkgOiB7fTtcbiAgdmFyIHdpZHRoID0gc2l6ZXMud2lkdGggfHwgZWxlbWVudC5jbGllbnRXaWR0aCB8fCByZXN1bHQud2lkdGg7XG4gIHZhciBoZWlnaHQgPSBzaXplcy5oZWlnaHQgfHwgZWxlbWVudC5jbGllbnRIZWlnaHQgfHwgcmVzdWx0LmhlaWdodDtcblxuICB2YXIgaG9yaXpTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldFdpZHRoIC0gd2lkdGg7XG4gIHZhciB2ZXJ0U2Nyb2xsYmFyID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgLSBoZWlnaHQ7XG5cbiAgLy8gaWYgYW4gaHlwb3RoZXRpY2FsIHNjcm9sbGJhciBpcyBkZXRlY3RlZCwgd2UgbXVzdCBiZSBzdXJlIGl0J3Mgbm90IGEgYGJvcmRlcmBcbiAgLy8gd2UgbWFrZSB0aGlzIGNoZWNrIGNvbmRpdGlvbmFsIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gIGlmIChob3JpelNjcm9sbGJhciB8fCB2ZXJ0U2Nyb2xsYmFyKSB7XG4gICAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShlbGVtZW50KTtcbiAgICBob3JpelNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd4Jyk7XG4gICAgdmVydFNjcm9sbGJhciAtPSBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsICd5Jyk7XG5cbiAgICByZXN1bHQud2lkdGggLT0gaG9yaXpTY3JvbGxiYXI7XG4gICAgcmVzdWx0LmhlaWdodCAtPSB2ZXJ0U2Nyb2xsYmFyO1xuICB9XG5cbiAgcmV0dXJuIGdldENsaWVudFJlY3QocmVzdWx0KTtcbn1cblxuZnVuY3Rpb24gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGNoaWxkcmVuLCBwYXJlbnQpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBpc0lFMTAgPSBpc0lFKDEwKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCk7XG4gIHZhciBib3JkZXJMZWZ0V2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJMZWZ0V2lkdGgpO1xuXG4gIC8vIEluIGNhc2VzIHdoZXJlIHRoZSBwYXJlbnQgaXMgZml4ZWQsIHdlIG11c3QgaWdub3JlIG5lZ2F0aXZlIHNjcm9sbCBpbiBvZmZzZXQgY2FsY1xuICBpZiAoZml4ZWRQb3NpdGlvbiAmJiBpc0hUTUwpIHtcbiAgICBwYXJlbnRSZWN0LnRvcCA9IE1hdGgubWF4KHBhcmVudFJlY3QudG9wLCAwKTtcbiAgICBwYXJlbnRSZWN0LmxlZnQgPSBNYXRoLm1heChwYXJlbnRSZWN0LmxlZnQsIDApO1xuICB9XG4gIHZhciBvZmZzZXRzID0gZ2V0Q2xpZW50UmVjdCh7XG4gICAgdG9wOiBjaGlsZHJlblJlY3QudG9wIC0gcGFyZW50UmVjdC50b3AgLSBib3JkZXJUb3BXaWR0aCxcbiAgICBsZWZ0OiBjaGlsZHJlblJlY3QubGVmdCAtIHBhcmVudFJlY3QubGVmdCAtIGJvcmRlckxlZnRXaWR0aCxcbiAgICB3aWR0aDogY2hpbGRyZW5SZWN0LndpZHRoLFxuICAgIGhlaWdodDogY2hpbGRyZW5SZWN0LmhlaWdodFxuICB9KTtcbiAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSAwO1xuICBvZmZzZXRzLm1hcmdpbkxlZnQgPSAwO1xuXG4gIC8vIFN1YnRyYWN0IG1hcmdpbnMgb2YgZG9jdW1lbnRFbGVtZW50IGluIGNhc2UgaXQncyBiZWluZyB1c2VkIGFzIHBhcmVudFxuICAvLyB3ZSBkbyB0aGlzIG9ubHkgb24gSFRNTCBiZWNhdXNlIGl0J3MgdGhlIG9ubHkgZWxlbWVudCB0aGF0IGJlaGF2ZXNcbiAgLy8gZGlmZmVyZW50bHkgd2hlbiBtYXJnaW5zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGUgbWFyZ2lucyBhcmUgaW5jbHVkZWQgaW5cbiAgLy8gdGhlIGJveCBvZiB0aGUgZG9jdW1lbnRFbGVtZW50LCBpbiB0aGUgb3RoZXIgY2FzZXMgbm90LlxuICBpZiAoIWlzSUUxMCAmJiBpc0hUTUwpIHtcbiAgICB2YXIgbWFyZ2luVG9wID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luVG9wKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQpO1xuXG4gICAgb2Zmc2V0cy50b3AgLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5ib3R0b20gLT0gYm9yZGVyVG9wV2lkdGggLSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5sZWZ0IC09IGJvcmRlckxlZnRXaWR0aCAtIG1hcmdpbkxlZnQ7XG4gICAgb2Zmc2V0cy5yaWdodCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuXG4gICAgLy8gQXR0YWNoIG1hcmdpblRvcCBhbmQgbWFyZ2luTGVmdCBiZWNhdXNlIGluIHNvbWUgY2lyY3Vtc3RhbmNlcyB3ZSBtYXkgbmVlZCB0aGVtXG4gICAgb2Zmc2V0cy5tYXJnaW5Ub3AgPSBtYXJnaW5Ub3A7XG4gICAgb2Zmc2V0cy5tYXJnaW5MZWZ0ID0gbWFyZ2luTGVmdDtcbiAgfVxuXG4gIGlmIChpc0lFMTAgJiYgIWZpeGVkUG9zaXRpb24gPyBwYXJlbnQuY29udGFpbnMoc2Nyb2xsUGFyZW50KSA6IHBhcmVudCA9PT0gc2Nyb2xsUGFyZW50ICYmIHNjcm9sbFBhcmVudC5ub2RlTmFtZSAhPT0gJ0JPRFknKSB7XG4gICAgb2Zmc2V0cyA9IGluY2x1ZGVTY3JvbGwob2Zmc2V0cywgcGFyZW50KTtcbiAgfVxuXG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG5mdW5jdGlvbiBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUoZWxlbWVudCkge1xuICB2YXIgZXhjbHVkZVNjcm9sbCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gIWV4Y2x1ZGVTY3JvbGwgPyBnZXRTY3JvbGwoaHRtbCkgOiAwO1xuICB2YXIgc2Nyb2xsTGVmdCA9ICFleGNsdWRlU2Nyb2xsID8gZ2V0U2Nyb2xsKGh0bWwsICdsZWZ0JykgOiAwO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgdmFyIHBhcmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuICBpZiAoIXBhcmVudE5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQocGFyZW50Tm9kZSk7XG59XG5cbi8qKlxuICogRmluZHMgdGhlIGZpcnN0IHBhcmVudCBvZiBhbiBlbGVtZW50IHRoYXQgaGFzIGEgdHJhbnNmb3JtZWQgcHJvcGVydHkgZGVmaW5lZFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7RWxlbWVudH0gZmlyc3QgdHJhbnNmb3JtZWQgcGFyZW50IG9yIGRvY3VtZW50RWxlbWVudFxuICovXG5cbmZ1bmN0aW9uIGdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQoZWxlbWVudCkge1xuICAvLyBUaGlzIGNoZWNrIGlzIG5lZWRlZCB0byBhdm9pZCBlcnJvcnMgaW4gY2FzZSBvbmUgb2YgdGhlIGVsZW1lbnRzIGlzbid0IGRlZmluZWQgZm9yIGFueSByZWFzb25cbiAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LnBhcmVudEVsZW1lbnQgfHwgaXNJRSgpKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuICB2YXIgZWwgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gIHdoaWxlIChlbCAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZWwsICd0cmFuc2Zvcm0nKSA9PT0gJ25vbmUnKSB7XG4gICAgZWwgPSBlbC5wYXJlbnRFbGVtZW50O1xuICB9XG4gIHJldHVybiBlbCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gZml4ZWRQb3NpdGlvbiAtIElzIGluIGZpeGVkIHBvc2l0aW9uIG1vZGVcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBmaXhlZFBvc2l0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgJiYgYXJndW1lbnRzWzRdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNF0gOiBmYWxzZTtcblxuICAvLyBOT1RFOiAxIERPTSBhY2Nlc3MgaGVyZVxuXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcblxuICAvLyBIYW5kbGUgdmlld3BvcnQgY2FzZVxuICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICd2aWV3cG9ydCcpIHtcbiAgICBib3VuZGFyaWVzID0gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKG9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSGFuZGxlIG90aGVyIGNhc2VzIGJhc2VkIG9uIERPTSBlbGVtZW50IHVzZWQgYXMgYm91bmRhcmllc1xuICAgIHZhciBib3VuZGFyaWVzTm9kZSA9IHZvaWQgMDtcbiAgICBpZiAoYm91bmRhcmllc0VsZW1lbnQgPT09ICdzY3JvbGxQYXJlbnQnKSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGdldFNjcm9sbFBhcmVudChnZXRQYXJlbnROb2RlKHJlZmVyZW5jZSkpO1xuICAgICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3dpbmRvdycpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gcG9wcGVyLm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBib3VuZGFyaWVzTm9kZSA9IGJvdW5kYXJpZXNFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRzID0gZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlKGJvdW5kYXJpZXNOb2RlLCBvZmZzZXRQYXJlbnQsIGZpeGVkUG9zaXRpb24pO1xuXG4gICAgLy8gSW4gY2FzZSBvZiBIVE1MLCB3ZSBuZWVkIGEgZGlmZmVyZW50IGNvbXB1dGF0aW9uXG4gICAgaWYgKGJvdW5kYXJpZXNOb2RlLm5vZGVOYW1lID09PSAnSFRNTCcgJiYgIWlzRml4ZWQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgdmFyIF9nZXRXaW5kb3dTaXplcyA9IGdldFdpbmRvd1NpemVzKHBvcHBlci5vd25lckRvY3VtZW50KSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIHBhZGRpbmcgPSBwYWRkaW5nIHx8IDA7XG4gIHZhciBpc1BhZGRpbmdOdW1iZXIgPSB0eXBlb2YgcGFkZGluZyA9PT0gJ251bWJlcic7XG4gIGJvdW5kYXJpZXMubGVmdCArPSBpc1BhZGRpbmdOdW1iZXIgPyBwYWRkaW5nIDogcGFkZGluZy5sZWZ0IHx8IDA7XG4gIGJvdW5kYXJpZXMudG9wICs9IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnRvcCB8fCAwO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLnJpZ2h0IHx8IDA7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IGlzUGFkZGluZ051bWJlciA/IHBhZGRpbmcgOiBwYWRkaW5nLmJvdHRvbSB8fCAwO1xuXG4gIHJldHVybiBib3VuZGFyaWVzO1xufVxuXG5mdW5jdGlvbiBnZXRBcmVhKF9yZWYpIHtcbiAgdmFyIHdpZHRoID0gX3JlZi53aWR0aCxcbiAgICAgIGhlaWdodCA9IF9yZWYuaGVpZ2h0O1xuXG4gIHJldHVybiB3aWR0aCAqIGhlaWdodDtcbn1cblxuLyoqXG4gKiBVdGlsaXR5IHVzZWQgdG8gdHJhbnNmb3JtIHRoZSBgYXV0b2AgcGxhY2VtZW50IHRvIHRoZSBwbGFjZW1lbnQgd2l0aCBtb3JlXG4gKiBhdmFpbGFibGUgc3BhY2UuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlQXV0b1BsYWNlbWVudChwbGFjZW1lbnQsIHJlZlJlY3QsIHBvcHBlciwgcmVmZXJlbmNlLCBib3VuZGFyaWVzRWxlbWVudCkge1xuICB2YXIgcGFkZGluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiA1ICYmIGFyZ3VtZW50c1s1XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzVdIDogMDtcblxuICBpZiAocGxhY2VtZW50LmluZGV4T2YoJ2F1dG8nKSA9PT0gLTEpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50O1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKHBvcHBlciwgcmVmZXJlbmNlLCBwYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG5cbiAgdmFyIHJlY3RzID0ge1xuICAgIHRvcDoge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlZlJlY3QudG9wIC0gYm91bmRhcmllcy50b3BcbiAgICB9LFxuICAgIHJpZ2h0OiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy5yaWdodCAtIHJlZlJlY3QucmlnaHQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfSxcbiAgICBib3R0b206IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmJvdHRvbSAtIHJlZlJlY3QuYm90dG9tXG4gICAgfSxcbiAgICBsZWZ0OiB7XG4gICAgICB3aWR0aDogcmVmUmVjdC5sZWZ0IC0gYm91bmRhcmllcy5sZWZ0LFxuICAgICAgaGVpZ2h0OiBib3VuZGFyaWVzLmhlaWdodFxuICAgIH1cbiAgfTtcblxuICB2YXIgc29ydGVkQXJlYXMgPSBPYmplY3Qua2V5cyhyZWN0cykubWFwKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAga2V5OiBrZXlcbiAgICB9LCByZWN0c1trZXldLCB7XG4gICAgICBhcmVhOiBnZXRBcmVhKHJlY3RzW2tleV0pXG4gICAgfSk7XG4gIH0pLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi5hcmVhIC0gYS5hcmVhO1xuICB9KTtcblxuICB2YXIgZmlsdGVyZWRBcmVhcyA9IHNvcnRlZEFyZWFzLmZpbHRlcihmdW5jdGlvbiAoX3JlZjIpIHtcbiAgICB2YXIgd2lkdGggPSBfcmVmMi53aWR0aCxcbiAgICAgICAgaGVpZ2h0ID0gX3JlZjIuaGVpZ2h0O1xuICAgIHJldHVybiB3aWR0aCA+PSBwb3BwZXIuY2xpZW50V2lkdGggJiYgaGVpZ2h0ID49IHBvcHBlci5jbGllbnRIZWlnaHQ7XG4gIH0pO1xuXG4gIHZhciBjb21wdXRlZFBsYWNlbWVudCA9IGZpbHRlcmVkQXJlYXMubGVuZ3RoID4gMCA/IGZpbHRlcmVkQXJlYXNbMF0ua2V5IDogc29ydGVkQXJlYXNbMF0ua2V5O1xuXG4gIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcblxuICByZXR1cm4gY29tcHV0ZWRQbGFjZW1lbnQgKyAodmFyaWF0aW9uID8gJy0nICsgdmFyaWF0aW9uIDogJycpO1xufVxuXG4vKipcbiAqIEdldCBvZmZzZXRzIHRvIHRoZSByZWZlcmVuY2UgZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlciAtIHRoZSBwb3BwZXIgZWxlbWVudFxuICogQHBhcmFtIHtFbGVtZW50fSByZWZlcmVuY2UgLSB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgKHRoZSBwb3BwZXIgd2lsbCBiZSByZWxhdGl2ZSB0byB0aGlzKVxuICogQHBhcmFtIHtFbGVtZW50fSBmaXhlZFBvc2l0aW9uIC0gaXMgaW4gZml4ZWQgcG9zaXRpb24gbW9kZVxuICogQHJldHVybnMge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UmVmZXJlbmNlT2Zmc2V0cyhzdGF0ZSwgcG9wcGVyLCByZWZlcmVuY2UpIHtcbiAgdmFyIGZpeGVkUG9zaXRpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgdmFyIGNvbW1vbk9mZnNldFBhcmVudCA9IGZpeGVkUG9zaXRpb24gPyBnZXRGaXhlZFBvc2l0aW9uT2Zmc2V0UGFyZW50KHBvcHBlcikgOiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KHBvcHBlciwgZ2V0UmVmZXJlbmNlTm9kZShyZWZlcmVuY2UpKTtcbiAgcmV0dXJuIGdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZShyZWZlcmVuY2UsIGNvbW1vbk9mZnNldFBhcmVudCwgZml4ZWRQb3NpdGlvbik7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvdXRlciBzaXplcyBvZiB0aGUgZ2l2ZW4gZWxlbWVudCAob2Zmc2V0IHNpemUgKyBtYXJnaW5zKVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJucyB7T2JqZWN0fSBvYmplY3QgY29udGFpbmluZyB3aWR0aCBhbmQgaGVpZ2h0IHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJTaXplcyhlbGVtZW50KSB7XG4gIHZhciB3aW5kb3cgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gIHZhciBzdHlsZXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AgfHwgMCkgKyBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Cb3R0b20gfHwgMCk7XG4gIHZhciB5ID0gcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luTGVmdCB8fCAwKSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0IHx8IDApO1xuICB2YXIgcmVzdWx0ID0ge1xuICAgIHdpZHRoOiBlbGVtZW50Lm9mZnNldFdpZHRoICsgeSxcbiAgICBoZWlnaHQ6IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ICsgeFxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3Bwb3NpdGUgcGxhY2VtZW50IG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnRcbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50XG4gKi9cbmZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICB2YXIgaGFzaCA9IHsgbGVmdDogJ3JpZ2h0JywgcmlnaHQ6ICdsZWZ0JywgYm90dG9tOiAndG9wJywgdG9wOiAnYm90dG9tJyB9O1xuICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL2xlZnR8cmlnaHR8Ym90dG9tfHRvcC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgIHJldHVybiBoYXNoW21hdGNoZWRdO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgb2Zmc2V0cyB0byB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gcG9zaXRpb24gLSBDU1MgcG9zaXRpb24gdGhlIFBvcHBlciB3aWxsIGdldCBhcHBsaWVkXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWZlcmVuY2VPZmZzZXRzIC0gdGhlIHJlZmVyZW5jZSBvZmZzZXRzICh0aGUgcG9wcGVyIHdpbGwgYmUgcmVsYXRpdmUgdG8gdGhpcylcbiAqIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnQgLSBvbmUgb2YgdGhlIHZhbGlkIHBsYWNlbWVudCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzIC0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9mZnNldHMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXJcbiAqL1xuZnVuY3Rpb24gZ2V0UG9wcGVyT2Zmc2V0cyhwb3BwZXIsIHJlZmVyZW5jZU9mZnNldHMsIHBsYWNlbWVudCkge1xuICBwbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICAvLyBHZXQgcG9wcGVyIG5vZGUgc2l6ZXNcbiAgdmFyIHBvcHBlclJlY3QgPSBnZXRPdXRlclNpemVzKHBvcHBlcik7XG5cbiAgLy8gQWRkIHBvc2l0aW9uLCB3aWR0aCBhbmQgaGVpZ2h0IHRvIG91ciBvZmZzZXRzIG9iamVjdFxuICB2YXIgcG9wcGVyT2Zmc2V0cyA9IHtcbiAgICB3aWR0aDogcG9wcGVyUmVjdC53aWR0aCxcbiAgICBoZWlnaHQ6IHBvcHBlclJlY3QuaGVpZ2h0XG4gIH07XG5cbiAgLy8gZGVwZW5kaW5nIGJ5IHRoZSBwb3BwZXIgcGxhY2VtZW50IHdlIGhhdmUgdG8gY29tcHV0ZSBpdHMgb2Zmc2V0cyBzbGlnaHRseSBkaWZmZXJlbnRseVxuICB2YXIgaXNIb3JpeiA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG4gIHZhciBtYWluU2lkZSA9IGlzSG9yaXogPyAndG9wJyA6ICdsZWZ0JztcbiAgdmFyIHNlY29uZGFyeVNpZGUgPSBpc0hvcml6ID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBtZWFzdXJlbWVudCA9IGlzSG9yaXogPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzZWNvbmRhcnlNZWFzdXJlbWVudCA9ICFpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gIHBvcHBlck9mZnNldHNbbWFpblNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1ttYWluU2lkZV0gKyByZWZlcmVuY2VPZmZzZXRzW21lYXN1cmVtZW50XSAvIDIgLSBwb3BwZXJSZWN0W21lYXN1cmVtZW50XSAvIDI7XG4gIGlmIChwbGFjZW1lbnQgPT09IHNlY29uZGFyeVNpZGUpIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSAtIHBvcHBlclJlY3Rbc2Vjb25kYXJ5TWVhc3VyZW1lbnRdO1xuICB9IGVsc2Uge1xuICAgIHBvcHBlck9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gPSByZWZlcmVuY2VPZmZzZXRzW2dldE9wcG9zaXRlUGxhY2VtZW50KHNlY29uZGFyeVNpZGUpXTtcbiAgfVxuXG4gIHJldHVybiBwb3BwZXJPZmZzZXRzO1xufVxuXG4vKipcbiAqIE1pbWljcyB0aGUgYGZpbmRgIG1ldGhvZCBvZiBBcnJheVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyLCBwcm9wLCB2YWx1ZSkge1xuICAvLyB1c2UgbmF0aXZlIGZpbmRJbmRleCBpZiBzdXBwb3J0ZWRcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChmdW5jdGlvbiAoY3VyKSB7XG4gICAgICByZXR1cm4gY3VyW3Byb3BdID09PSB2YWx1ZTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHVzZSBgZmluZGAgKyBgaW5kZXhPZmAgaWYgYGZpbmRJbmRleGAgaXNuJ3Qgc3VwcG9ydGVkXG4gIHZhciBtYXRjaCA9IGZpbmQoYXJyLCBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9ialtwcm9wXSA9PT0gdmFsdWU7XG4gIH0pO1xuICByZXR1cm4gYXJyLmluZGV4T2YobWF0Y2gpO1xufVxuXG4vKipcbiAqIExvb3AgdHJvdWdoIHRoZSBsaXN0IG9mIG1vZGlmaWVycyBhbmQgcnVuIHRoZW0gaW4gb3JkZXIsXG4gKiBlYWNoIG9mIHRoZW0gd2lsbCB0aGVuIGVkaXQgdGhlIGRhdGEgb2JqZWN0LlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBlbmRzIC0gT3B0aW9uYWwgbW9kaWZpZXIgbmFtZSB1c2VkIGFzIHN0b3BwZXJcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fVxuICovXG5mdW5jdGlvbiBydW5Nb2RpZmllcnMobW9kaWZpZXJzLCBkYXRhLCBlbmRzKSB7XG4gIHZhciBtb2RpZmllcnNUb1J1biA9IGVuZHMgPT09IHVuZGVmaW5lZCA/IG1vZGlmaWVycyA6IG1vZGlmaWVycy5zbGljZSgwLCBmaW5kSW5kZXgobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgZGF0YS5wbGFjZW1lbnQgPSBjb21wdXRlQXV0b1BsYWNlbWVudCh0aGlzLm9wdGlvbnMucGxhY2VtZW50LCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UsIHRoaXMub3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIC8vIHN0b3JlIHRoZSBjb21wdXRlZCBwbGFjZW1lbnQgaW5zaWRlIGBvcmlnaW5hbFBsYWNlbWVudGBcbiAgZGF0YS5vcmlnaW5hbFBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuXG4gIGRhdGEucG9zaXRpb25GaXhlZCA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkO1xuXG4gIC8vIGNvbXB1dGUgdGhlIHBvcHBlciBvZmZzZXRzXG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRQb3BwZXJPZmZzZXRzKHRoaXMucG9wcGVyLCBkYXRhLm9mZnNldHMucmVmZXJlbmNlLCBkYXRhLnBsYWNlbWVudCk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9IHRoaXMub3B0aW9ucy5wb3NpdGlvbkZpeGVkID8gJ2ZpeGVkJyA6ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV07XG4gICAgdmFyIHRvQ2hlY2sgPSBwcmVmaXggPyAnJyArIHByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQuYm9keS5zdHlsZVt0b0NoZWNrXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiB0b0NoZWNrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBEZXN0cm95cyB0aGUgcG9wcGVyLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBkZXN0cm95KCkge1xuICB0aGlzLnN0YXRlLmlzRGVzdHJveWVkID0gdHJ1ZTtcblxuICAvLyB0b3VjaCBET00gb25seSBpZiBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgaXMgZW5hYmxlZFxuICBpZiAoaXNNb2RpZmllckVuYWJsZWQodGhpcy5tb2RpZmllcnMsICdhcHBseVN0eWxlJykpIHtcbiAgICB0aGlzLnBvcHBlci5yZW1vdmVBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50Jyk7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucmlnaHQgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5ib3R0b20gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS53aWxsQ2hhbmdlID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGVbZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKV0gPSAnJztcbiAgfVxuXG4gIHRoaXMuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG5cbiAgLy8gcmVtb3ZlIHRoZSBwb3BwZXIgaWYgdXNlciBleHBsaWNpdGx5IGFza2VkIGZvciB0aGUgZGVsZXRpb24gb24gZGVzdHJveVxuICAvLyBkbyBub3QgdXNlIGByZW1vdmVgIGJlY2F1c2UgSUUxMSBkb2Vzbid0IHN1cHBvcnQgaXRcbiAgaWYgKHRoaXMub3B0aW9ucy5yZW1vdmVPbkRlc3Ryb3kpIHtcbiAgICB0aGlzLnBvcHBlci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wcGVyKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHdpbmRvdyBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge1dpbmRvd31cbiAqL1xuZnVuY3Rpb24gZ2V0V2luZG93KGVsZW1lbnQpIHtcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIHJldHVybiBvd25lckRvY3VtZW50ID8gb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHdpbmRvdztcbn1cblxuZnVuY3Rpb24gYXR0YWNoVG9TY3JvbGxQYXJlbnRzKHNjcm9sbFBhcmVudCwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKSB7XG4gIHZhciBpc0JvZHkgPSBzY3JvbGxQYXJlbnQubm9kZU5hbWUgPT09ICdCT0RZJztcbiAgdmFyIHRhcmdldCA9IGlzQm9keSA/IHNjcm9sbFBhcmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogc2Nyb2xsUGFyZW50O1xuICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgY2FsbGJhY2ssIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcblxuICBpZiAoIWlzQm9keSkge1xuICAgIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhnZXRTY3JvbGxQYXJlbnQodGFyZ2V0LnBhcmVudE5vZGUpLCBldmVudCwgY2FsbGJhY2ssIHNjcm9sbFBhcmVudHMpO1xuICB9XG4gIHNjcm9sbFBhcmVudHMucHVzaCh0YXJnZXQpO1xufVxuXG4vKipcbiAqIFNldHVwIG5lZWRlZCBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2V0dXBFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIG9wdGlvbnMsIHN0YXRlLCB1cGRhdGVCb3VuZCkge1xuICAvLyBSZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gdXBkYXRlQm91bmQ7XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgLy8gU2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHZhciBzY3JvbGxFbGVtZW50ID0gZ2V0U2Nyb2xsUGFyZW50KHJlZmVyZW5jZSk7XG4gIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxFbGVtZW50LCAnc2Nyb2xsJywgc3RhdGUudXBkYXRlQm91bmQsIHN0YXRlLnNjcm9sbFBhcmVudHMpO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gc2Nyb2xsRWxlbWVudDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IHRydWU7XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG4vKipcbiAqIEl0IHdpbGwgYWRkIHJlc2l6ZS9zY3JvbGwgZXZlbnRzIGFuZCBzdGFydCByZWNhbGN1bGF0aW5nXG4gKiBwb3NpdGlvbiBvZiB0aGUgcG9wcGVyIGVsZW1lbnQgd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAoIXRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIHRoaXMuc3RhdGUgPSBzZXR1cEV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLm9wdGlvbnMsIHRoaXMuc3RhdGUsIHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICB9XG59XG5cbi8qKlxuICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyB1c2VkIHRvIHVwZGF0ZSB0aGUgcG9wcGVyIHBvc2l0aW9uXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVycyhyZWZlcmVuY2UsIHN0YXRlKSB7XG4gIC8vIFJlbW92ZSByZXNpemUgZXZlbnQgbGlzdGVuZXIgb24gd2luZG93XG4gIGdldFdpbmRvdyhyZWZlcmVuY2UpLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcblxuICAvLyBSZW1vdmUgc2Nyb2xsIGV2ZW50IGxpc3RlbmVyIG9uIHNjcm9sbCBwYXJlbnRzXG4gIHN0YXRlLnNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kKTtcbiAgfSk7XG5cbiAgLy8gUmVzZXQgc3RhdGVcbiAgc3RhdGUudXBkYXRlQm91bmQgPSBudWxsO1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzID0gW107XG4gIHN0YXRlLnNjcm9sbEVsZW1lbnQgPSBudWxsO1xuICBzdGF0ZS5ldmVudHNFbmFibGVkID0gZmFsc2U7XG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIHJlbW92ZSByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgd29uJ3QgcmVjYWxjdWxhdGUgcG9wcGVyIHBvc2l0aW9uXG4gKiB3aGVuIHRoZXkgYXJlIHRyaWdnZXJlZC4gSXQgYWxzbyB3b24ndCB0cmlnZ2VyIGBvblVwZGF0ZWAgY2FsbGJhY2sgYW55bW9yZSxcbiAqIHVubGVzcyB5b3UgY2FsbCBgdXBkYXRlYCBtZXRob2QgbWFudWFsbHkuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMuc2NoZWR1bGVVcGRhdGUpO1xuICAgIHRoaXMuc3RhdGUgPSByZW1vdmVFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5zdGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUZWxscyBpZiBhIGdpdmVuIGlucHV0IGlzIGEgbnVtYmVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0geyp9IGlucHV0IHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc051bWVyaWMobikge1xuICByZXR1cm4gbiAhPT0gJycgJiYgIWlzTmFOKHBhcnNlRmxvYXQobikpICYmIGlzRmluaXRlKG4pO1xufVxuXG4vKipcbiAqIFNldCB0aGUgc3R5bGUgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgc3R5bGUgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldFN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgT2JqZWN0LmtleXMoc3R5bGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHVuaXQgPSAnJztcbiAgICAvLyBhZGQgdW5pdCBpZiB0aGUgdmFsdWUgaXMgbnVtZXJpYyBhbmQgaXMgb25lIG9mIHRoZSBmb2xsb3dpbmdcbiAgICBpZiAoWyd3aWR0aCcsICdoZWlnaHQnLCAndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10uaW5kZXhPZihwcm9wKSAhPT0gLTEgJiYgaXNOdW1lcmljKHN0eWxlc1twcm9wXSkpIHtcbiAgICAgIHVuaXQgPSAncHgnO1xuICAgIH1cbiAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gc3R5bGVzW3Byb3BdICsgdW5pdDtcbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IHRoZSBhdHRyaWJ1dGVzIHRvIHRoZSBnaXZlbiBwb3BwZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudCAtIEVsZW1lbnQgdG8gYXBwbHkgdGhlIGF0dHJpYnV0ZXMgdG9cbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBzdHlsZXNcbiAqIE9iamVjdCB3aXRoIGEgbGlzdCBvZiBwcm9wZXJ0aWVzIGFuZCB2YWx1ZXMgd2hpY2ggd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWxlbWVudCwgYXR0cmlidXRlcykge1xuICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1twcm9wXTtcbiAgICBpZiAodmFsdWUgIT09IGZhbHNlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShwcm9wLCBhdHRyaWJ1dGVzW3Byb3BdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhLnN0eWxlcyAtIExpc3Qgb2Ygc3R5bGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuYXR0cmlidXRlcyAtIExpc3Qgb2YgYXR0cmlidXRlIHByb3BlcnRpZXMgLSB2YWx1ZXMgdG8gYXBwbHkgdG8gcG9wcGVyIGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBzYW1lIGRhdGEgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGFwcGx5U3R5bGUoZGF0YSkge1xuICAvLyBhbnkgcHJvcGVydHkgcHJlc2VudCBpbiBgZGF0YS5zdHlsZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyBpbiB0aGlzIHdheSB3ZSBjYW4gbWFrZSB0aGUgM3JkIHBhcnR5IG1vZGlmaWVycyBhZGQgY3VzdG9tIHN0eWxlcyB0byBpdFxuICAvLyBCZSBhd2FyZSwgbW9kaWZpZXJzIGNvdWxkIG92ZXJyaWRlIHRoZSBwcm9wZXJ0aWVzIGRlZmluZWQgaW4gdGhlIHByZXZpb3VzXG4gIC8vIGxpbmVzIG9mIHRoaXMgbW9kaWZpZXIhXG4gIHNldFN0eWxlcyhkYXRhLmluc3RhbmNlLnBvcHBlciwgZGF0YS5zdHlsZXMpO1xuXG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLmF0dHJpYnV0ZXNgIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLFxuICAvLyB0aGV5IHdpbGwgYmUgc2V0IGFzIEhUTUwgYXR0cmlidXRlcyBvZiB0aGUgZWxlbWVudFxuICBzZXRBdHRyaWJ1dGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmF0dHJpYnV0ZXMpO1xuXG4gIC8vIGlmIGFycm93RWxlbWVudCBpcyBkZWZpbmVkIGFuZCBhcnJvd1N0eWxlcyBoYXMgc29tZSBwcm9wZXJ0aWVzXG4gIGlmIChkYXRhLmFycm93RWxlbWVudCAmJiBPYmplY3Qua2V5cyhkYXRhLmFycm93U3R5bGVzKS5sZW5ndGgpIHtcbiAgICBzZXRTdHlsZXMoZGF0YS5hcnJvd0VsZW1lbnQsIGRhdGEuYXJyb3dTdHlsZXMpO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogU2V0IHRoZSB4LXBsYWNlbWVudCBhdHRyaWJ1dGUgYmVmb3JlIGV2ZXJ5dGhpbmcgZWxzZSBiZWNhdXNlIGl0IGNvdWxkIGJlIHVzZWRcbiAqIHRvIGFkZCBtYXJnaW5zIHRvIHRoZSBwb3BwZXIgbWFyZ2lucyBuZWVkcyB0byBiZSBjYWxjdWxhdGVkIHRvIGdldCB0aGVcbiAqIGNvcnJlY3QgcG9wcGVyIG9mZnNldHMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLm1vZGlmaWVyc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcmVmZXJlbmNlIC0gVGhlIHJlZmVyZW5jZSBlbGVtZW50IHVzZWQgdG8gcG9zaXRpb24gdGhlIHBvcHBlclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICB2YXIgcGxhY2VtZW50ID0gY29tcHV0ZUF1dG9QbGFjZW1lbnQob3B0aW9ucy5wbGFjZW1lbnQsIHJlZmVyZW5jZU9mZnNldHMsIHBvcHBlciwgcmVmZXJlbmNlLCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCBvcHRpb25zLm1vZGlmaWVycy5mbGlwLnBhZGRpbmcpO1xuXG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JywgcGxhY2VtZW50KTtcblxuICAvLyBBcHBseSBgcG9zaXRpb25gIHRvIHBvcHBlciBiZWZvcmUgYW55dGhpbmcgZWxzZSBiZWNhdXNlXG4gIC8vIHdpdGhvdXQgdGhlIHBvc2l0aW9uIGFwcGxpZWQgd2UgY2FuJ3QgZ3VhcmFudGVlIGNvcnJlY3QgY29tcHV0YXRpb25zXG4gIHNldFN0eWxlcyhwb3BwZXIsIHsgcG9zaXRpb246IG9wdGlvbnMucG9zaXRpb25GaXhlZCA/ICdmaXhlZCcgOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtCb29sZWFufSBzaG91bGRSb3VuZCAtIElmIHRoZSBvZmZzZXRzIHNob3VsZCBiZSByb3VuZGVkIGF0IGFsbFxuICogQHJldHVybnMge09iamVjdH0gVGhlIHBvcHBlcidzIHBvc2l0aW9uIG9mZnNldHMgcm91bmRlZFxuICpcbiAqIFRoZSB0YWxlIG9mIHBpeGVsLXBlcmZlY3QgcG9zaXRpb25pbmcuIEl0J3Mgc3RpbGwgbm90IDEwMCUgcGVyZmVjdCwgYnV0IGFzXG4gKiBnb29kIGFzIGl0IGNhbiBiZSB3aXRoaW4gcmVhc29uLlxuICogRGlzY3Vzc2lvbiBoZXJlOiBodHRwczovL2dpdGh1Yi5jb20vRmV6VnJhc3RhL3BvcHBlci5qcy9wdWxsLzcxNVxuICpcbiAqIExvdyBEUEkgc2NyZWVucyBjYXVzZSBhIHBvcHBlciB0byBiZSBibHVycnkgaWYgbm90IHVzaW5nIGZ1bGwgcGl4ZWxzIChTYWZhcmlcbiAqIGFzIHdlbGwgb24gSGlnaCBEUEkgc2NyZWVucykuXG4gKlxuICogRmlyZWZveCBwcmVmZXJzIG5vIHJvdW5kaW5nIGZvciBwb3NpdGlvbmluZyBhbmQgZG9lcyBub3QgaGF2ZSBibHVycmluZXNzIG9uXG4gKiBoaWdoIERQSSBzY3JlZW5zLlxuICpcbiAqIE9ubHkgaG9yaXpvbnRhbCBwbGFjZW1lbnQgYW5kIGxlZnQvcmlnaHQgdmFsdWVzIG5lZWQgdG8gYmUgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgc2hvdWxkUm91bmQpIHtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kLFxuICAgICAgZmxvb3IgPSBNYXRoLmZsb29yO1xuXG4gIHZhciBub1JvdW5kID0gZnVuY3Rpb24gbm9Sb3VuZCh2KSB7XG4gICAgcmV0dXJuIHY7XG4gIH07XG5cbiAgdmFyIHJlZmVyZW5jZVdpZHRoID0gcm91bmQocmVmZXJlbmNlLndpZHRoKTtcbiAgdmFyIHBvcHBlcldpZHRoID0gcm91bmQocG9wcGVyLndpZHRoKTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YoZGF0YS5wbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIGlzVmFyaWF0aW9uID0gZGF0YS5wbGFjZW1lbnQuaW5kZXhPZignLScpICE9PSAtMTtcbiAgdmFyIHNhbWVXaWR0aFBhcml0eSA9IHJlZmVyZW5jZVdpZHRoICUgMiA9PT0gcG9wcGVyV2lkdGggJSAyO1xuICB2YXIgYm90aE9kZFdpZHRoID0gcmVmZXJlbmNlV2lkdGggJSAyID09PSAxICYmIHBvcHBlcldpZHRoICUgMiA9PT0gMTtcblxuICB2YXIgaG9yaXpvbnRhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiBpc1ZlcnRpY2FsIHx8IGlzVmFyaWF0aW9uIHx8IHNhbWVXaWR0aFBhcml0eSA/IHJvdW5kIDogZmxvb3I7XG4gIHZhciB2ZXJ0aWNhbFRvSW50ZWdlciA9ICFzaG91bGRSb3VuZCA/IG5vUm91bmQgOiByb3VuZDtcblxuICByZXR1cm4ge1xuICAgIGxlZnQ6IGhvcml6b250YWxUb0ludGVnZXIoYm90aE9kZFdpZHRoICYmICFpc1ZhcmlhdGlvbiAmJiBzaG91bGRSb3VuZCA/IHBvcHBlci5sZWZ0IC0gMSA6IHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IHZlcnRpY2FsVG9JbnRlZ2VyKHBvcHBlci50b3ApLFxuICAgIGJvdHRvbTogdmVydGljYWxUb0ludGVnZXIocG9wcGVyLmJvdHRvbSksXG4gICAgcmlnaHQ6IGhvcml6b250YWxUb0ludGVnZXIocG9wcGVyLnJpZ2h0KVxuICB9O1xufVxuXG52YXIgaXNGaXJlZm94ID0gaXNCcm93c2VyICYmIC9GaXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gY29tcHV0ZVN0eWxlKGRhdGEsIG9wdGlvbnMpIHtcbiAgdmFyIHggPSBvcHRpb25zLngsXG4gICAgICB5ID0gb3B0aW9ucy55O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICAvLyBSZW1vdmUgdGhpcyBsZWdhY3kgc3VwcG9ydCBpbiBQb3BwZXIuanMgdjJcblxuICB2YXIgbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uID0gZmluZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09ICdhcHBseVN0eWxlJztcbiAgfSkuZ3B1QWNjZWxlcmF0aW9uO1xuICBpZiAobGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb25zb2xlLndhcm4oJ1dBUk5JTkc6IGBncHVBY2NlbGVyYXRpb25gIG9wdGlvbiBtb3ZlZCB0byBgY29tcHV0ZVN0eWxlYCBtb2RpZmllciBhbmQgd2lsbCBub3QgYmUgc3VwcG9ydGVkIGluIGZ1dHVyZSB2ZXJzaW9ucyBvZiBQb3BwZXIuanMhJyk7XG4gIH1cbiAgdmFyIGdwdUFjY2VsZXJhdGlvbiA9IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkID8gbGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIDogb3B0aW9ucy5ncHVBY2NlbGVyYXRpb247XG5cbiAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG4gIHZhciBvZmZzZXRQYXJlbnRSZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCk7XG5cbiAgLy8gU3R5bGVzXG4gIHZhciBzdHlsZXMgPSB7XG4gICAgcG9zaXRpb246IHBvcHBlci5wb3NpdGlvblxuICB9O1xuXG4gIHZhciBvZmZzZXRzID0gZ2V0Um91bmRlZE9mZnNldHMoZGF0YSwgd2luZG93LmRldmljZVBpeGVsUmF0aW8gPCAyIHx8ICFpc0ZpcmVmb3gpO1xuXG4gIHZhciBzaWRlQSA9IHggPT09ICdib3R0b20nID8gJ3RvcCcgOiAnYm90dG9tJztcbiAgdmFyIHNpZGVCID0geSA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICdyaWdodCc7XG5cbiAgLy8gaWYgZ3B1QWNjZWxlcmF0aW9uIGlzIHNldCB0byBgdHJ1ZWAgYW5kIHRyYW5zZm9ybSBpcyBzdXBwb3J0ZWQsXG4gIC8vICB3ZSB1c2UgYHRyYW5zbGF0ZTNkYCB0byBhcHBseSB0aGUgcG9zaXRpb24gdG8gdGhlIHBvcHBlciB3ZVxuICAvLyBhdXRvbWF0aWNhbGx5IHVzZSB0aGUgc3VwcG9ydGVkIHByZWZpeGVkIHZlcnNpb24gaWYgbmVlZGVkXG4gIHZhciBwcmVmaXhlZFByb3BlcnR5ID0gZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lKCd0cmFuc2Zvcm0nKTtcblxuICAvLyBub3csIGxldCdzIG1ha2UgYSBzdGVwIGJhY2sgYW5kIGxvb2sgYXQgdGhpcyBjb2RlIGNsb3NlbHkgKHd0Zj8pXG4gIC8vIElmIHRoZSBjb250ZW50IG9mIHRoZSBwb3BwZXIgZ3Jvd3Mgb25jZSBpdCdzIGJlZW4gcG9zaXRpb25lZCwgaXRcbiAgLy8gbWF5IGhhcHBlbiB0aGF0IHRoZSBwb3BwZXIgZ2V0cyBtaXNwbGFjZWQgYmVjYXVzZSBvZiB0aGUgbmV3IGNvbnRlbnRcbiAgLy8gb3ZlcmZsb3dpbmcgaXRzIHJlZmVyZW5jZSBlbGVtZW50XG4gIC8vIFRvIGF2b2lkIHRoaXMgcHJvYmxlbSwgd2UgcHJvdmlkZSB0d28gb3B0aW9ucyAoeCBhbmQgeSksIHdoaWNoIGFsbG93XG4gIC8vIHRoZSBjb25zdW1lciB0byBkZWZpbmUgdGhlIG9mZnNldCBvcmlnaW4uXG4gIC8vIElmIHdlIHBvc2l0aW9uIGEgcG9wcGVyIG9uIHRvcCBvZiBhIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSBjYW4gc2V0XG4gIC8vIGB4YCB0byBgdG9wYCB0byBtYWtlIHRoZSBwb3BwZXIgZ3JvdyB0b3dhcmRzIGl0cyB0b3AgaW5zdGVhZCBvZlxuICAvLyBpdHMgYm90dG9tLlxuICB2YXIgbGVmdCA9IHZvaWQgMCxcbiAgICAgIHRvcCA9IHZvaWQgMDtcbiAgaWYgKHNpZGVBID09PSAnYm90dG9tJykge1xuICAgIC8vIHdoZW4gb2Zmc2V0UGFyZW50IGlzIDxodG1sPiB0aGUgcG9zaXRpb25pbmcgaXMgcmVsYXRpdmUgdG8gdGhlIGJvdHRvbSBvZiB0aGUgc2NyZWVuIChleGNsdWRpbmcgdGhlIHNjcm9sbGJhcilcbiAgICAvLyBhbmQgbm90IHRoZSBib3R0b20gb2YgdGhlIGh0bWwgZWxlbWVudFxuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgICB9IGVsc2Uge1xuICAgICAgdG9wID0gLW9mZnNldFBhcmVudFJlY3QuaGVpZ2h0ICsgb2Zmc2V0cy5ib3R0b207XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRvcCA9IG9mZnNldHMudG9wO1xuICB9XG4gIGlmIChzaWRlQiA9PT0gJ3JpZ2h0Jykge1xuICAgIGlmIChvZmZzZXRQYXJlbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgICAgbGVmdCA9IC1vZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZWZ0ID0gb2Zmc2V0cy5sZWZ0O1xuICB9XG4gIGlmIChncHVBY2NlbGVyYXRpb24gJiYgcHJlZml4ZWRQcm9wZXJ0eSkge1xuICAgIHN0eWxlc1twcmVmaXhlZFByb3BlcnR5XSA9ICd0cmFuc2xhdGUzZCgnICsgbGVmdCArICdweCwgJyArIHRvcCArICdweCwgMCknO1xuICAgIHN0eWxlc1tzaWRlQV0gPSAwO1xuICAgIHN0eWxlc1tzaWRlQl0gPSAwO1xuICAgIHN0eWxlcy53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3Rod2VyaXNlLCB3ZSB1c2UgdGhlIHN0YW5kYXJkIGB0b3BgLCBgbGVmdGAsIGBib3R0b21gIGFuZCBgcmlnaHRgIHByb3BlcnRpZXNcbiAgICB2YXIgaW52ZXJ0VG9wID0gc2lkZUEgPT09ICdib3R0b20nID8gLTEgOiAxO1xuICAgIHZhciBpbnZlcnRMZWZ0ID0gc2lkZUIgPT09ICdyaWdodCcgPyAtMSA6IDE7XG4gICAgc3R5bGVzW3NpZGVBXSA9IHRvcCAqIGludmVydFRvcDtcbiAgICBzdHlsZXNbc2lkZUJdID0gbGVmdCAqIGludmVydExlZnQ7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSBzaWRlQSArICcsICcgKyBzaWRlQjtcbiAgfVxuXG4gIC8vIEF0dHJpYnV0ZXNcbiAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgJ3gtcGxhY2VtZW50JzogZGF0YS5wbGFjZW1lbnRcbiAgfTtcblxuICAvLyBVcGRhdGUgYGRhdGFgIGF0dHJpYnV0ZXMsIHN0eWxlcyBhbmQgYXJyb3dTdHlsZXNcbiAgZGF0YS5hdHRyaWJ1dGVzID0gX2V4dGVuZHMoe30sIGF0dHJpYnV0ZXMsIGRhdGEuYXR0cmlidXRlcyk7XG4gIGRhdGEuc3R5bGVzID0gX2V4dGVuZHMoe30sIHN0eWxlcywgZGF0YS5zdHlsZXMpO1xuICBkYXRhLmFycm93U3R5bGVzID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5hcnJvdywgZGF0YS5hcnJvd1N0eWxlcyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogSGVscGVyIHVzZWQgdG8ga25vdyBpZiB0aGUgZ2l2ZW4gbW9kaWZpZXIgZGVwZW5kcyBmcm9tIGFub3RoZXIgb25lLjxiciAvPlxuICogSXQgY2hlY2tzIGlmIHRoZSBuZWVkZWQgbW9kaWZpZXIgaXMgbGlzdGVkIGFuZCBlbmFibGVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzIC0gbGlzdCBvZiBtb2RpZmllcnNcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0aW5nTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGluZyBtb2RpZmllclxuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RlZE5hbWUgLSBuYW1lIG9mIHJlcXVlc3RlZCBtb2RpZmllclxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTW9kaWZpZXJSZXF1aXJlZChtb2RpZmllcnMsIHJlcXVlc3RpbmdOYW1lLCByZXF1ZXN0ZWROYW1lKSB7XG4gIHZhciByZXF1ZXN0aW5nID0gZmluZChtb2RpZmllcnMsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWU7XG4gICAgcmV0dXJuIG5hbWUgPT09IHJlcXVlc3RpbmdOYW1lO1xuICB9KTtcblxuICB2YXIgaXNSZXF1aXJlZCA9ICEhcmVxdWVzdGluZyAmJiBtb2RpZmllcnMuc29tZShmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gcmVxdWVzdGVkTmFtZSAmJiBtb2RpZmllci5lbmFibGVkICYmIG1vZGlmaWVyLm9yZGVyIDwgcmVxdWVzdGluZy5vcmRlcjtcbiAgfSk7XG5cbiAgaWYgKCFpc1JlcXVpcmVkKSB7XG4gICAgdmFyIF9yZXF1ZXN0aW5nID0gJ2AnICsgcmVxdWVzdGluZ05hbWUgKyAnYCc7XG4gICAgdmFyIHJlcXVlc3RlZCA9ICdgJyArIHJlcXVlc3RlZE5hbWUgKyAnYCc7XG4gICAgY29uc29sZS53YXJuKHJlcXVlc3RlZCArICcgbW9kaWZpZXIgaXMgcmVxdWlyZWQgYnkgJyArIF9yZXF1ZXN0aW5nICsgJyBtb2RpZmllciBpbiBvcmRlciB0byB3b3JrLCBiZSBzdXJlIHRvIGluY2x1ZGUgaXQgYmVmb3JlICcgKyBfcmVxdWVzdGluZyArICchJyk7XG4gIH1cbiAgcmV0dXJuIGlzUmVxdWlyZWQ7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBhcnJvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBfZGF0YSRvZmZzZXRzJGFycm93O1xuXG4gIC8vIGFycm93IGRlcGVuZHMgb24ga2VlcFRvZ2V0aGVyIGluIG9yZGVyIHRvIHdvcmtcbiAgaWYgKCFpc01vZGlmaWVyUmVxdWlyZWQoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsICdhcnJvdycsICdrZWVwVG9nZXRoZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGFycm93RWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudDtcblxuICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgYSBzdHJpbmcsIHN1cHBvc2UgaXQncyBhIENTUyBzZWxlY3RvclxuICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICBhcnJvd0VsZW1lbnQgPSBkYXRhLmluc3RhbmNlLnBvcHBlci5xdWVyeVNlbGVjdG9yKGFycm93RWxlbWVudCk7XG5cbiAgICAvLyBpZiBhcnJvd0VsZW1lbnQgaXMgbm90IGZvdW5kLCBkb24ndCBydW4gdGhlIG1vZGlmaWVyXG4gICAgaWYgKCFhcnJvd0VsZW1lbnQpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBpZiB0aGUgYXJyb3dFbGVtZW50IGlzbid0IGEgcXVlcnkgc2VsZWN0b3Igd2UgbXVzdCBjaGVjayB0aGF0IHRoZVxuICAgIC8vIHByb3ZpZGVkIERPTSBub2RlIGlzIGNoaWxkIG9mIGl0cyBwb3BwZXIgbm9kZVxuICAgIGlmICghZGF0YS5pbnN0YW5jZS5wb3BwZXIuY29udGFpbnMoYXJyb3dFbGVtZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgYXJyb3cuZWxlbWVudGAgbXVzdCBiZSBjaGlsZCBvZiBpdHMgcG9wcGVyIGVsZW1lbnQhJyk7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH1cblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBpc1ZlcnRpY2FsID0gWydsZWZ0JywgJ3JpZ2h0J10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgdmFyIHNpZGVDYXBpdGFsaXplZCA9IGlzVmVydGljYWwgPyAnVG9wJyA6ICdMZWZ0JztcbiAgdmFyIHNpZGUgPSBzaWRlQ2FwaXRhbGl6ZWQudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGFsdFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2xlZnQnIDogJ3RvcCc7XG4gIHZhciBvcFNpZGUgPSBpc1ZlcnRpY2FsID8gJ2JvdHRvbScgOiAncmlnaHQnO1xuICB2YXIgYXJyb3dFbGVtZW50U2l6ZSA9IGdldE91dGVyU2l6ZXMoYXJyb3dFbGVtZW50KVtsZW5dO1xuXG4gIC8vXG4gIC8vIGV4dGVuZHMga2VlcFRvZ2V0aGVyIGJlaGF2aW9yIG1ha2luZyBzdXJlIHRoZSBwb3BwZXIgYW5kIGl0c1xuICAvLyByZWZlcmVuY2UgaGF2ZSBlbm91Z2ggcGl4ZWxzIGluIGNvbmp1bmN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSk7XG4gIHZhciBwb3BwZXJCb3JkZXJTaWRlID0gcGFyc2VGbG9hdChjc3NbJ2JvcmRlcicgKyBzaWRlQ2FwaXRhbGl6ZWQgKyAnV2lkdGgnXSk7XG4gIHZhciBzaWRlVmFsdWUgPSBjZW50ZXIgLSBkYXRhLm9mZnNldHMucG9wcGVyW3NpZGVdIC0gcG9wcGVyTWFyZ2luU2lkZSAtIHBvcHBlckJvcmRlclNpZGU7XG5cbiAgLy8gcHJldmVudCBhcnJvd0VsZW1lbnQgZnJvbSBiZWluZyBwbGFjZWQgbm90IGNvbnRpZ3VvdXNseSB0byBpdHMgcG9wcGVyXG4gIHNpZGVWYWx1ZSA9IE1hdGgubWF4KE1hdGgubWluKHBvcHBlcltsZW5dIC0gYXJyb3dFbGVtZW50U2l6ZSwgc2lkZVZhbHVlKSwgMCk7XG5cbiAgZGF0YS5hcnJvd0VsZW1lbnQgPSBhcnJvd0VsZW1lbnQ7XG4gIGRhdGEub2Zmc2V0cy5hcnJvdyA9IChfZGF0YSRvZmZzZXRzJGFycm93ID0ge30sIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIHNpZGUsIE1hdGgucm91bmQoc2lkZVZhbHVlKSksIGRlZmluZVByb3BlcnR5KF9kYXRhJG9mZnNldHMkYXJyb3csIGFsdFNpZGUsICcnKSwgX2RhdGEkb2Zmc2V0cyRhcnJvdyk7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogR2V0IHRoZSBvcHBvc2l0ZSBwbGFjZW1lbnQgdmFyaWF0aW9uIG9mIHRoZSBnaXZlbiBvbmVcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgdmFyaWF0aW9uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudCB2YXJpYXRpb25cbiAqL1xuZnVuY3Rpb24gZ2V0T3Bwb3NpdGVWYXJpYXRpb24odmFyaWF0aW9uKSB7XG4gIGlmICh2YXJpYXRpb24gPT09ICdlbmQnKSB7XG4gICAgcmV0dXJuICdzdGFydCc7XG4gIH0gZWxzZSBpZiAodmFyaWF0aW9uID09PSAnc3RhcnQnKSB7XG4gICAgcmV0dXJuICdlbmQnO1xuICB9XG4gIHJldHVybiB2YXJpYXRpb247XG59XG5cbi8qKlxuICogTGlzdCBvZiBhY2NlcHRlZCBwbGFjZW1lbnRzIHRvIHVzZSBhcyB2YWx1ZXMgb2YgdGhlIGBwbGFjZW1lbnRgIG9wdGlvbi48YnIgLz5cbiAqIFZhbGlkIHBsYWNlbWVudHMgYXJlOlxuICogLSBgYXV0b2BcbiAqIC0gYHRvcGBcbiAqIC0gYHJpZ2h0YFxuICogLSBgYm90dG9tYFxuICogLSBgbGVmdGBcbiAqXG4gKiBFYWNoIHBsYWNlbWVudCBjYW4gaGF2ZSBhIHZhcmlhdGlvbiBmcm9tIHRoaXMgbGlzdDpcbiAqIC0gYC1zdGFydGBcbiAqIC0gYC1lbmRgXG4gKlxuICogVmFyaWF0aW9ucyBhcmUgaW50ZXJwcmV0ZWQgZWFzaWx5IGlmIHlvdSB0aGluayBvZiB0aGVtIGFzIHRoZSBsZWZ0IHRvIHJpZ2h0XG4gKiB3cml0dGVuIGxhbmd1YWdlcy4gSG9yaXpvbnRhbGx5IChgdG9wYCBhbmQgYGJvdHRvbWApLCBgc3RhcnRgIGlzIGxlZnQgYW5kIGBlbmRgXG4gKiBpcyByaWdodC48YnIgLz5cbiAqIFZlcnRpY2FsbHkgKGBsZWZ0YCBhbmQgYHJpZ2h0YCksIGBzdGFydGAgaXMgdG9wIGFuZCBgZW5kYCBpcyBib3R0b20uXG4gKlxuICogU29tZSB2YWxpZCBleGFtcGxlcyBhcmU6XG4gKiAtIGB0b3AtZW5kYCAob24gdG9wIG9mIHJlZmVyZW5jZSwgcmlnaHQgYWxpZ25lZClcbiAqIC0gYHJpZ2h0LXN0YXJ0YCAob24gcmlnaHQgb2YgcmVmZXJlbmNlLCB0b3AgYWxpZ25lZClcbiAqIC0gYGJvdHRvbWAgKG9uIGJvdHRvbSwgY2VudGVyZWQpXG4gKiAtIGBhdXRvLWVuZGAgKG9uIHRoZSBzaWRlIHdpdGggbW9yZSBzcGFjZSBhdmFpbGFibGUsIGFsaWdubWVudCBkZXBlbmRzIGJ5IHBsYWNlbWVudClcbiAqXG4gKiBAc3RhdGljXG4gKiBAdHlwZSB7QXJyYXl9XG4gKiBAZW51bSB7U3RyaW5nfVxuICogQHJlYWRvbmx5XG4gKiBAbWV0aG9kIHBsYWNlbWVudHNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIHBsYWNlbWVudHMgPSBbJ2F1dG8tc3RhcnQnLCAnYXV0bycsICdhdXRvLWVuZCcsICd0b3Atc3RhcnQnLCAndG9wJywgJ3RvcC1lbmQnLCAncmlnaHQtc3RhcnQnLCAncmlnaHQnLCAncmlnaHQtZW5kJywgJ2JvdHRvbS1lbmQnLCAnYm90dG9tJywgJ2JvdHRvbS1zdGFydCcsICdsZWZ0LWVuZCcsICdsZWZ0JywgJ2xlZnQtc3RhcnQnXTtcblxuLy8gR2V0IHJpZCBvZiBgYXV0b2AgYGF1dG8tc3RhcnRgIGFuZCBgYXV0by1lbmRgXG52YXIgdmFsaWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cy5zbGljZSgzKTtcblxuLyoqXG4gKiBHaXZlbiBhbiBpbml0aWFsIHBsYWNlbWVudCwgcmV0dXJucyBhbGwgdGhlIHN1YnNlcXVlbnQgcGxhY2VtZW50c1xuICogY2xvY2t3aXNlIChvciBjb3VudGVyLWNsb2Nrd2lzZSkuXG4gKlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCAtIEEgdmFsaWQgcGxhY2VtZW50IChpdCBhY2NlcHRzIHZhcmlhdGlvbnMpXG4gKiBAYXJndW1lbnQge0Jvb2xlYW59IGNvdW50ZXIgLSBTZXQgdG8gdHJ1ZSB0byB3YWxrIHRoZSBwbGFjZW1lbnRzIGNvdW50ZXJjbG9ja3dpc2VcbiAqIEByZXR1cm5zIHtBcnJheX0gcGxhY2VtZW50cyBpbmNsdWRpbmcgdGhlaXIgdmFyaWF0aW9uc1xuICovXG5mdW5jdGlvbiBjbG9ja3dpc2UocGxhY2VtZW50KSB7XG4gIHZhciBjb3VudGVyID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcblxuICB2YXIgaW5kZXggPSB2YWxpZFBsYWNlbWVudHMuaW5kZXhPZihwbGFjZW1lbnQpO1xuICB2YXIgYXJyID0gdmFsaWRQbGFjZW1lbnRzLnNsaWNlKGluZGV4ICsgMSkuY29uY2F0KHZhbGlkUGxhY2VtZW50cy5zbGljZSgwLCBpbmRleCkpO1xuICByZXR1cm4gY291bnRlciA/IGFyci5yZXZlcnNlKCkgOiBhcnI7XG59XG5cbnZhciBCRUhBVklPUlMgPSB7XG4gIEZMSVA6ICdmbGlwJyxcbiAgQ0xPQ0tXSVNFOiAnY2xvY2t3aXNlJyxcbiAgQ09VTlRFUkNMT0NLV0lTRTogJ2NvdW50ZXJjbG9ja3dpc2UnXG59O1xuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gZmxpcChkYXRhLCBvcHRpb25zKSB7XG4gIC8vIGlmIGBpbm5lcmAgbW9kaWZpZXIgaXMgZW5hYmxlZCwgd2UgY2FuJ3QgdXNlIHRoZSBgZmxpcGAgbW9kaWZpZXJcbiAgaWYgKGlzTW9kaWZpZXJFbmFibGVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaW5uZXInKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgaWYgKGRhdGEuZmxpcHBlZCAmJiBkYXRhLnBsYWNlbWVudCA9PT0gZGF0YS5vcmlnaW5hbFBsYWNlbWVudCkge1xuICAgIC8vIHNlZW1zIGxpa2UgZmxpcCBpcyB0cnlpbmcgdG8gbG9vcCwgcHJvYmFibHkgdGhlcmUncyBub3QgZW5vdWdoIHNwYWNlIG9uIGFueSBvZiB0aGUgZmxpcHBhYmxlIHNpZGVzXG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQsIGRhdGEucG9zaXRpb25GaXhlZCk7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBwbGFjZW1lbnRPcHBvc2l0ZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIHZhciB2YXJpYXRpb24gPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzFdIHx8ICcnO1xuXG4gIHZhciBmbGlwT3JkZXIgPSBbXTtcblxuICBzd2l0Y2ggKG9wdGlvbnMuYmVoYXZpb3IpIHtcbiAgICBjYXNlIEJFSEFWSU9SUy5GTElQOlxuICAgICAgZmxpcE9yZGVyID0gW3BsYWNlbWVudCwgcGxhY2VtZW50T3Bwb3NpdGVdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBCRUhBVklPUlMuQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DT1VOVEVSQ0xPQ0tXSVNFOlxuICAgICAgZmxpcE9yZGVyID0gY2xvY2t3aXNlKHBsYWNlbWVudCwgdHJ1ZSk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgZmxpcE9yZGVyID0gb3B0aW9ucy5iZWhhdmlvcjtcbiAgfVxuXG4gIGZsaXBPcmRlci5mb3JFYWNoKGZ1bmN0aW9uIChzdGVwLCBpbmRleCkge1xuICAgIGlmIChwbGFjZW1lbnQgIT09IHN0ZXAgfHwgZmxpcE9yZGVyLmxlbmd0aCA9PT0gaW5kZXggKyAxKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICAgIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcbiAgICB2YXIgcmVmT2Zmc2V0cyA9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgICAvLyB1c2luZyBmbG9vciBiZWNhdXNlIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyBtYXkgY29udGFpbiBkZWNpbWFscyB3ZSBhcmUgbm90IGdvaW5nIHRvIGNvbnNpZGVyIGhlcmVcbiAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xuICAgIHZhciBvdmVybGFwc1JlZiA9IHBsYWNlbWVudCA9PT0gJ2xlZnQnICYmIGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IocmVmT2Zmc2V0cy5sZWZ0KSB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5sZWZ0KSA8IGZsb29yKHJlZk9mZnNldHMucmlnaHQpIHx8IHBsYWNlbWVudCA9PT0gJ3RvcCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IocmVmT2Zmc2V0cy50b3ApIHx8IHBsYWNlbWVudCA9PT0gJ2JvdHRvbScgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy50b3ApIDwgZmxvb3IocmVmT2Zmc2V0cy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0xlZnQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IoYm91bmRhcmllcy5sZWZ0KTtcbiAgICB2YXIgb3ZlcmZsb3dzUmlnaHQgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnJpZ2h0KSA+IGZsb29yKGJvdW5kYXJpZXMucmlnaHQpO1xuICAgIHZhciBvdmVyZmxvd3NUb3AgPSBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihib3VuZGFyaWVzLnRvcCk7XG4gICAgdmFyIG92ZXJmbG93c0JvdHRvbSA9IGZsb29yKHBvcHBlck9mZnNldHMuYm90dG9tKSA+IGZsb29yKGJvdW5kYXJpZXMuYm90dG9tKTtcblxuICAgIHZhciBvdmVyZmxvd3NCb3VuZGFyaWVzID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBwbGFjZW1lbnQgPT09ICdyaWdodCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBvdmVyZmxvd3NUb3AgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBvdmVyZmxvd3NCb3R0b207XG5cbiAgICAvLyBmbGlwIHRoZSB2YXJpYXRpb24gaWYgcmVxdWlyZWRcbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgICAvLyBmbGlwcyB2YXJpYXRpb24gaWYgcmVmZXJlbmNlIGVsZW1lbnQgb3ZlcmZsb3dzIGJvdW5kYXJpZXNcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbkJ5UmVmID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IGlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnZW5kJyAmJiBvdmVyZmxvd3NSaWdodCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzVG9wIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzQm90dG9tKTtcblxuICAgIC8vIGZsaXBzIHZhcmlhdGlvbiBpZiBwb3BwZXIgY29udGVudCBvdmVyZmxvd3MgYm91bmRhcmllc1xuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50ID0gISFvcHRpb25zLmZsaXBWYXJpYXRpb25zQnlDb250ZW50ICYmIChpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ3N0YXJ0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzQm90dG9tIHx8ICFpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzVG9wKTtcblxuICAgIHZhciBmbGlwcGVkVmFyaWF0aW9uID0gZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIHx8IGZsaXBwZWRWYXJpYXRpb25CeUNvbnRlbnQ7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZChmcmFnbWVudHMsIGZ1bmN0aW9uIChmcmFnKSB7XG4gICAgcmV0dXJuIGZyYWcuc2VhcmNoKC8sfFxccy8pICE9PSAtMTtcbiAgfSkpO1xuXG4gIGlmIChmcmFnbWVudHNbZGl2aWRlcl0gJiYgZnJhZ21lbnRzW2RpdmlkZXJdLmluZGV4T2YoJywnKSA9PT0gLTEpIHtcbiAgICBjb25zb2xlLndhcm4oJ09mZnNldHMgc2VwYXJhdGVkIGJ5IHdoaXRlIHNwYWNlKHMpIGFyZSBkZXByZWNhdGVkLCB1c2UgYSBjb21tYSAoLCkgaW5zdGVhZC4nKTtcbiAgfVxuXG4gIC8vIElmIGRpdmlkZXIgaXMgZm91bmQsIHdlIGRpdmlkZSB0aGUgbGlzdCBvZiB2YWx1ZXMgYW5kIG9wZXJhbmRzIHRvIGRpdmlkZVxuICAvLyB0aGVtIGJ5IG9mc2V0IFggYW5kIFkuXG4gIHZhciBzcGxpdFJlZ2V4ID0gL1xccyosXFxzKnxcXHMrLztcbiAgdmFyIG9wcyA9IGRpdmlkZXIgIT09IC0xID8gW2ZyYWdtZW50cy5zbGljZSgwLCBkaXZpZGVyKS5jb25jYXQoW2ZyYWdtZW50c1tkaXZpZGVyXS5zcGxpdChzcGxpdFJlZ2V4KVswXV0pLCBbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzFdXS5jb25jYXQoZnJhZ21lbnRzLnNsaWNlKGRpdmlkZXIgKyAxKSldIDogW2ZyYWdtZW50c107XG5cbiAgLy8gQ29udmVydCB0aGUgdmFsdWVzIHdpdGggdW5pdHMgdG8gYWJzb2x1dGUgcGl4ZWxzIHRvIGFsbG93IG91ciBjb21wdXRhdGlvbnNcbiAgb3BzID0gb3BzLm1hcChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgLy8gTW9zdCBvZiB0aGUgdW5pdHMgcmVseSBvbiB0aGUgb3JpZW50YXRpb24gb2YgdGhlIHBvcHBlclxuICAgIHZhciBtZWFzdXJlbWVudCA9IChpbmRleCA9PT0gMSA/ICF1c2VIZWlnaHQgOiB1c2VIZWlnaHQpID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICAgIHZhciBtZXJnZVdpdGhQcmV2aW91cyA9IGZhbHNlO1xuICAgIHJldHVybiBvcFxuICAgIC8vIFRoaXMgYWdncmVnYXRlcyBhbnkgYCtgIG9yIGAtYCBzaWduIHRoYXQgYXJlbid0IGNvbnNpZGVyZWQgb3BlcmF0b3JzXG4gICAgLy8gZS5nLjogMTAgKyArNSA9PiBbMTAsICssICs1XVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIGlmIChhW2EubGVuZ3RoIC0gMV0gPT09ICcnICYmIFsnKycsICctJ10uaW5kZXhPZihiKSAhPT0gLTEpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdID0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH0gZWxzZSBpZiAobWVyZ2VXaXRoUHJldmlvdXMpIHtcbiAgICAgICAgYVthLmxlbmd0aCAtIDFdICs9IGI7XG4gICAgICAgIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuY29uY2F0KGIpO1xuICAgICAgfVxuICAgIH0sIFtdKVxuICAgIC8vIEhlcmUgd2UgY29udmVydCB0aGUgc3RyaW5nIHZhbHVlcyBpbnRvIG51bWJlciB2YWx1ZXMgKGluIHB4KVxuICAgIC5tYXAoZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHRvVmFsdWUoc3RyLCBtZWFzdXJlbWVudCwgcG9wcGVyT2Zmc2V0cywgcmVmZXJlbmNlT2Zmc2V0cyk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIExvb3AgdHJvdWdoIHRoZSBvZmZzZXRzIGFycmF5cyBhbmQgZXhlY3V0ZSB0aGUgb3BlcmF0aW9uc1xuICBvcHMuZm9yRWFjaChmdW5jdGlvbiAob3AsIGluZGV4KSB7XG4gICAgb3AuZm9yRWFjaChmdW5jdGlvbiAoZnJhZywgaW5kZXgyKSB7XG4gICAgICBpZiAoaXNOdW1lcmljKGZyYWcpKSB7XG4gICAgICAgIG9mZnNldHNbaW5kZXhdICs9IGZyYWcgKiAob3BbaW5kZXgyIC0gMV0gPT09ICctJyA/IC0xIDogMSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAYXJndW1lbnQge051bWJlcnxTdHJpbmd9IG9wdGlvbnMub2Zmc2V0PTBcbiAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBvZmZzZXQoZGF0YSwgX3JlZikge1xuICB2YXIgb2Zmc2V0ID0gX3JlZi5vZmZzZXQ7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudCxcbiAgICAgIF9kYXRhJG9mZnNldHMgPSBkYXRhLm9mZnNldHMsXG4gICAgICBwb3BwZXIgPSBfZGF0YSRvZmZzZXRzLnBvcHBlcixcbiAgICAgIHJlZmVyZW5jZSA9IF9kYXRhJG9mZnNldHMucmVmZXJlbmNlO1xuXG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgdmFyIG9mZnNldHMgPSB2b2lkIDA7XG4gIGlmIChpc051bWVyaWMoK29mZnNldCkpIHtcbiAgICBvZmZzZXRzID0gWytvZmZzZXQsIDBdO1xuICB9IGVsc2Uge1xuICAgIG9mZnNldHMgPSBwYXJzZU9mZnNldChvZmZzZXQsIHBvcHBlciwgcmVmZXJlbmNlLCBiYXNlUGxhY2VtZW50KTtcbiAgfVxuXG4gIGlmIChiYXNlUGxhY2VtZW50ID09PSAnbGVmdCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAncmlnaHQnKSB7XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMV07XG4gIH0gZWxzZSBpZiAoYmFzZVBsYWNlbWVudCA9PT0gJ3RvcCcpIHtcbiAgICBwb3BwZXIubGVmdCArPSBvZmZzZXRzWzBdO1xuICAgIHBvcHBlci50b3AgLT0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAnYm90dG9tJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCArPSBvZmZzZXRzWzFdO1xuICB9XG5cbiAgZGF0YS5wb3BwZXIgPSBwb3BwZXI7XG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgYm91bmRhcmllc0VsZW1lbnQgPSBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50IHx8IGdldE9mZnNldFBhcmVudChkYXRhLmluc3RhbmNlLnBvcHBlcik7XG5cbiAgLy8gSWYgb2Zmc2V0UGFyZW50IGlzIHRoZSByZWZlcmVuY2UgZWxlbWVudCwgd2UgcmVhbGx5IHdhbnQgdG9cbiAgLy8gZ28gb25lIHN0ZXAgdXAgYW5kIHVzZSB0aGUgbmV4dCBvZmZzZXRQYXJlbnQgYXMgcmVmZXJlbmNlIHRvXG4gIC8vIGF2b2lkIHRvIG1ha2UgdGhpcyBtb2RpZmllciBjb21wbGV0ZWx5IHVzZWxlc3MgYW5kIGxvb2sgbGlrZSBicm9rZW5cbiAgaWYgKGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlID09PSBib3VuZGFyaWVzRWxlbWVudCkge1xuICAgIGJvdW5kYXJpZXNFbGVtZW50ID0gZ2V0T2Zmc2V0UGFyZW50KGJvdW5kYXJpZXNFbGVtZW50KTtcbiAgfVxuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXNldHMgdGhlIHBvcHBlcidzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIGRvY3VtZW50IHNpemUgY2FuIGJlIGNhbGN1bGF0ZWQgZXhjbHVkaW5nXG4gIC8vIHRoZSBzaXplIG9mIHRoZSBwb3BwZXIgZWxlbWVudCBpdHNlbGZcbiAgdmFyIHRyYW5zZm9ybVByb3AgPSBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpO1xuICB2YXIgcG9wcGVyU3R5bGVzID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIuc3R5bGU7IC8vIGFzc2lnbm1lbnQgdG8gaGVscCBtaW5pZmljYXRpb25cbiAgdmFyIHRvcCA9IHBvcHBlclN0eWxlcy50b3AsXG4gICAgICBsZWZ0ID0gcG9wcGVyU3R5bGVzLmxlZnQsXG4gICAgICB0cmFuc2Zvcm0gPSBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF07XG5cbiAgcG9wcGVyU3R5bGVzLnRvcCA9ICcnO1xuICBwb3BwZXJTdHlsZXMubGVmdCA9ICcnO1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSAnJztcblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuaW5zdGFuY2UucmVmZXJlbmNlLCBvcHRpb25zLnBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50LCBkYXRhLnBvc2l0aW9uRml4ZWQpO1xuXG4gIC8vIE5PVEU6IERPTSBhY2Nlc3MgaGVyZVxuICAvLyByZXN0b3JlcyB0aGUgb3JpZ2luYWwgc3R5bGUgcHJvcGVydGllcyBhZnRlciB0aGUgb2Zmc2V0cyBoYXZlIGJlZW4gY29tcHV0ZWRcbiAgcG9wcGVyU3R5bGVzLnRvcCA9IHRvcDtcbiAgcG9wcGVyU3R5bGVzLmxlZnQgPSBsZWZ0O1xuICBwb3BwZXJTdHlsZXNbdHJhbnNmb3JtUHJvcF0gPSB0cmFuc2Zvcm07XG5cbiAgb3B0aW9ucy5ib3VuZGFyaWVzID0gYm91bmRhcmllcztcblxuICB2YXIgb3JkZXIgPSBvcHRpb25zLnByaW9yaXR5O1xuICB2YXIgcG9wcGVyID0gZGF0YS5vZmZzZXRzLnBvcHBlcjtcblxuICB2YXIgY2hlY2sgPSB7XG4gICAgcHJpbWFyeTogZnVuY3Rpb24gcHJpbWFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlcltwbGFjZW1lbnRdO1xuICAgICAgaWYgKHBvcHBlcltwbGFjZW1lbnRdIDwgYm91bmRhcmllc1twbGFjZW1lbnRdICYmICFvcHRpb25zLmVzY2FwZVdpdGhSZWZlcmVuY2UpIHtcbiAgICAgICAgdmFsdWUgPSBNYXRoLm1heChwb3BwZXJbcGxhY2VtZW50XSwgYm91bmRhcmllc1twbGFjZW1lbnRdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgcGxhY2VtZW50LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBzZWNvbmRhcnk6IGZ1bmN0aW9uIHNlY29uZGFyeShwbGFjZW1lbnQpIHtcbiAgICAgIHZhciBtYWluU2lkZSA9IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgICAgdmFyIHZhbHVlID0gcG9wcGVyW21haW5TaWRlXTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA+IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5taW4ocG9wcGVyW21haW5TaWRlXSwgYm91bmRhcmllc1twbGFjZW1lbnRdIC0gKHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyA/IHBvcHBlci53aWR0aCA6IHBvcHBlci5oZWlnaHQpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eSh7fSwgbWFpblNpZGUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG5cbiAgb3JkZXIuZm9yRWFjaChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgdmFyIHNpZGUgPSBbJ2xlZnQnLCAndG9wJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMSA/ICdwcmltYXJ5JyA6ICdzZWNvbmRhcnknO1xuICAgIHBvcHBlciA9IF9leHRlbmRzKHt9LCBwb3BwZXIsIGNoZWNrW3NpZGVdKHBsYWNlbWVudCkpO1xuICB9KTtcblxuICBkYXRhLm9mZnNldHMucG9wcGVyID0gcG9wcGVyO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBzaGlmdChkYXRhKSB7XG4gIHZhciBwbGFjZW1lbnQgPSBkYXRhLnBsYWNlbWVudDtcbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHNoaWZ0dmFyaWF0aW9uID0gcGxhY2VtZW50LnNwbGl0KCctJylbMV07XG5cbiAgLy8gaWYgc2hpZnQgc2hpZnR2YXJpYXRpb24gaXMgc3BlY2lmaWVkLCBydW4gdGhlIG1vZGlmaWVyXG4gIGlmIChzaGlmdHZhcmlhdGlvbikge1xuICAgIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZSxcbiAgICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXI7XG5cbiAgICB2YXIgaXNWZXJ0aWNhbCA9IFsnYm90dG9tJywgJ3RvcCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuICAgIHZhciBzaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICAgIHZhciBtZWFzdXJlbWVudCA9IGlzVmVydGljYWwgPyAnd2lkdGgnIDogJ2hlaWdodCc7XG5cbiAgICB2YXIgc2hpZnRPZmZzZXRzID0ge1xuICAgICAgc3RhcnQ6IGRlZmluZVByb3BlcnR5KHt9LCBzaWRlLCByZWZlcmVuY2Vbc2lkZV0pLFxuICAgICAgZW5kOiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW21lYXN1cmVtZW50XSAtIHBvcHBlclttZWFzdXJlbWVudF0pXG4gICAgfTtcblxuICAgIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBzaGlmdE9mZnNldHNbc2hpZnR2YXJpYXRpb25dKTtcbiAgfVxuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gaGlkZShkYXRhKSB7XG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnaGlkZScsICdwcmV2ZW50T3ZlcmZsb3cnKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIHJlZlJlY3QgPSBkYXRhLm9mZnNldHMucmVmZXJlbmNlO1xuICB2YXIgYm91bmQgPSBmaW5kKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0LWxlc3MsIGludGVycHJldGVkIGFzIHBpeGVsc1xuICAgKiAtIGAlYCBvciBgJXJgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gICAqIC0gYCVwYCwgcGVyY2VudGFnZSByZWxhdGl2ZSB0byB0aGUgbGVuZ3RoIG9mIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiAtIGB2d2AsIENTUyB2aWV3cG9ydCB3aWR0aCB1bml0XG4gICAqIC0gYHZoYCwgQ1NTIHZpZXdwb3J0IGhlaWdodCB1bml0XG4gICAqXG4gICAqIEZvciBsZW5ndGggaXMgaW50ZW5kZWQgdGhlIG1haW4gYXhpcyByZWxhdGl2ZSB0byB0aGUgcGxhY2VtZW50IG9mIHRoZSBwb3BwZXIuPGJyIC8+XG4gICAqIFRoaXMgbWVhbnMgdGhhdCBpZiB0aGUgcGxhY2VtZW50IGlzIGB0b3BgIG9yIGBib3R0b21gLCB0aGUgbGVuZ3RoIHdpbGwgYmUgdGhlXG4gICAqIGB3aWR0aGAuIEluIGNhc2Ugb2YgYGxlZnRgIG9yIGByaWdodGAsIGl0IHdpbGwgYmUgdGhlIGBoZWlnaHRgLlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gWW91IGNhbiByZWFkIG1vcmUgb24gdGhpcyBhdCB0aGlzIFtpc3N1ZV0oaHR0cHM6Ly9naXRodWIuY29tL0ZlelZyYXN0YS9wb3BwZXIuanMvaXNzdWVzLzM3MykuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEEgc2NlbmFyaW8gZXhpc3RzIHdoZXJlIHRoZSByZWZlcmVuY2UgaXRzZWxmIGlzIG5vdCB3aXRoaW4gdGhlIGJvdW5kYXJpZXMuPGJyIC8+XG4gICAqIFdlIGNhbiBzYXkgaXQgaGFzIFwiZXNjYXBlZCB0aGUgYm91bmRhcmllc1wiIOKAlCBvciBqdXN0IFwiZXNjYXBlZFwiLjxiciAvPlxuICAgKiBJbiB0aGlzIGNhc2Ugd2UgbmVlZCB0byBkZWNpZGUgd2hldGhlciB0aGUgcG9wcGVyIHNob3VsZCBlaXRoZXI6XG4gICAqXG4gICAqIC0gZGV0YWNoIGZyb20gdGhlIHJlZmVyZW5jZSBhbmQgcmVtYWluIFwidHJhcHBlZFwiIGluIHRoZSBib3VuZGFyaWVzLCBvclxuICAgKiAtIGlmIGl0IHNob3VsZCBpZ25vcmUgdGhlIGJvdW5kYXJ5IGFuZCBcImVzY2FwZSB3aXRoIGl0cyByZWZlcmVuY2VcIlxuICAgKlxuICAgKiBXaGVuIGBlc2NhcGVXaXRoUmVmZXJlbmNlYCBpcyBzZXQgdG9gdHJ1ZWAgYW5kIHJlZmVyZW5jZSBpcyBjb21wbGV0ZWx5XG4gICAqIG91dHNpZGUgaXRzIGJvdW5kYXJpZXMsIHRoZSBwb3BwZXIgd2lsbCBvdmVyZmxvdyAob3IgY29tcGxldGVseSBsZWF2ZSlcbiAgICogdGhlIGJvdW5kYXJpZXMgaW4gb3JkZXIgdG8gcmVtYWluIGF0dGFjaGVkIHRvIHRoZSBlZGdlIG9mIHRoZSByZWZlcmVuY2UuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MzAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAzMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBwcmV2ZW50T3ZlcmZsb3csXG4gICAgLyoqXG4gICAgICogQHByb3Age0FycmF5fSBbcHJpb3JpdHk9WydsZWZ0JywncmlnaHQnLCd0b3AnLCdib3R0b20nXV1cbiAgICAgKiBQb3BwZXIgd2lsbCB0cnkgdG8gcHJldmVudCBvdmVyZmxvdyBmb2xsb3dpbmcgdGhlc2UgcHJpb3JpdGllcyBieSBkZWZhdWx0LFxuICAgICAqIHRoZW4sIGl0IGNvdWxkIG92ZXJmbG93IG9uIHRoZSBsZWZ0IGFuZCBvbiB0b3Agb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwcmlvcml0eTogWydsZWZ0JywgJ3JpZ2h0JywgJ3RvcCcsICdib3R0b20nXSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7bnVtYmVyfSBwYWRkaW5nPTVcbiAgICAgKiBBbW91bnQgb2YgcGl4ZWwgdXNlZCB0byBkZWZpbmUgYSBtaW5pbXVtIGRpc3RhbmNlIGJldHdlZW4gdGhlIGJvdW5kYXJpZXNcbiAgICAgKiBhbmQgdGhlIHBvcHBlci4gVGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgYWx3YXlzIGhhcyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLiBDYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNoIG90aGVyXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXNwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gZW5zdXJlIHRoYXQgaXQgcG9pbnRzIHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcy4gWW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVuY3Rpb24gYXJlIG5lZWRlZC5cbiAgICpcbiAgICogSXQgaGFzIG5vIGVmZmVjdCBpZiBubyBgYXJyb3dFbGVtZW50YCBpcyBwcm92aWRlZC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFycm93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTUwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXJyb3csXG4gICAgLyoqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGVsZW1lbnQ9J1t4LWFycm93XScgLSBTZWxlY3RvciBvciBub2RlIHVzZWQgYXMgYXJyb3cgKi9cbiAgICBlbGVtZW50OiAnW3gtYXJyb3ddJ1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGZsaXAgdGhlIHBvcHBlcidzIHBsYWNlbWVudCB3aGVuIGl0IHN0YXJ0cyB0byBvdmVybGFwIGl0c1xuICAgKiByZWZlcmVuY2UgZWxlbWVudC5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKlxuICAgKiAqKk5PVEU6KiogdGhpcyBtb2RpZmllciB3aWxsIGludGVycnVwdCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUgYW5kIHdpbGxcbiAgICogcmVzdGFydCBpdCBpZiBpdCBkZXRlY3RzIHRoZSBuZWVkIHRvIGZsaXAgdGhlIHBsYWNlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGZsaXA6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA2MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBmbGlwLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8QXJyYXl9IGJlaGF2aW9yPSdmbGlwJ1xuICAgICAqIFRoZSBiZWhhdmlvciB1c2VkIHRvIGNoYW5nZSB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50LiBJdCBjYW4gYmUgb25lIG9mXG4gICAgICogYGZsaXBgLCBgY2xvY2t3aXNlYCwgYGNvdW50ZXJjbG9ja3dpc2VgIG9yIGFuIGFycmF5IHdpdGggYSBsaXN0IG9mIHZhbGlkXG4gICAgICogcGxhY2VtZW50cyAod2l0aCBvcHRpb25hbCB2YXJpYXRpb25zKVxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLlxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBga2VlcFRvZ2V0aGVyYCBpcyBlbmFibGVkKVxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAndmlld3BvcnQnLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBmbGlwVmFyaWF0aW9ucz1mYWxzZVxuICAgICAqIFRoZSBwb3BwZXIgd2lsbCBzd2l0Y2ggcGxhY2VtZW50IHZhcmlhdGlvbiBiZXR3ZWVuIGAtc3RhcnRgIGFuZCBgLWVuZGAgd2hlblxuICAgICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudCBvdmVybGFwcyBpdHMgYm91bmRhcmllcy5cbiAgICAgKlxuICAgICAqIFRoZSBvcmlnaW5hbCBwbGFjZW1lbnQgc2hvdWxkIGhhdmUgYSBzZXQgdmFyaWF0aW9uLlxuICAgICAqL1xuICAgIGZsaXBWYXJpYXRpb25zOiBmYWxzZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ9ZmFsc2VcbiAgICAgKiBUaGUgcG9wcGVyIHdpbGwgc3dpdGNoIHBsYWNlbWVudCB2YXJpYXRpb24gYmV0d2VlbiBgLXN0YXJ0YCBhbmQgYC1lbmRgIHdoZW5cbiAgICAgKiB0aGUgcG9wcGVyIGVsZW1lbnQgb3ZlcmxhcHMgaXRzIHJlZmVyZW5jZSBib3VuZGFyaWVzLlxuICAgICAqXG4gICAgICogVGhlIG9yaWdpbmFsIHBsYWNlbWVudCBzaG91bGQgaGF2ZSBhIHNldCB2YXJpYXRpb24uXG4gICAgICovXG4gICAgZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQ6IGZhbHNlXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gbWFrZSB0aGUgcG9wcGVyIGZsb3cgdG93YXJkIHRoZSBpbm5lciBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEJ5IGRlZmF1bHQsIHdoZW4gdGhpcyBtb2RpZmllciBpcyBkaXNhYmxlZCwgdGhlIHBvcHBlciB3aWxsIGJlIHBsYWNlZCBvdXRzaWRlXG4gICAqIHRoZSByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGlubmVyOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTcwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogNzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD1mYWxzZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogZmFsc2UsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBpbm5lclxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIGhpZGUgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXRzaWRlIG9mIHRoZVxuICAgKiBwb3BwZXIgYm91bmRhcmllcy4gSXQgd2lsbCBzZXQgYSBgeC1vdXQtb2YtYm91bmRhcmllc2AgYXR0cmlidXRlIHdoaWNoIGNhblxuICAgKiBiZSB1c2VkIHRvIGhpZGUgd2l0aCBhIENTUyBzZWxlY3RvciB0aGUgcG9wcGVyIHdoZW4gaXRzIHJlZmVyZW5jZSBpc1xuICAgKiBvdXQgb2YgYm91bmRhcmllcy5cbiAgICpcbiAgICogUmVxdWlyZXMgdGhlIGBwcmV2ZW50T3ZlcmZsb3dgIG1vZGlmaWVyIGJlZm9yZSBpdCBpbiBvcmRlciB0byB3b3JrLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgaGlkZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDgwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGhpZGVcbiAgfSxcblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHN0eWxlIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgZWxlbWVudCB0byBnZXRzXG4gICAqIHByb3Blcmx5IHBvc2l0aW9uZWQuXG4gICAqXG4gICAqIE5vdGUgdGhhdCB0aGlzIG1vZGlmaWVyIHdpbGwgbm90IHRvdWNoIHRoZSBET00sIGl0IGp1c3QgcHJlcGFyZXMgdGhlIHN0eWxlc1xuICAgKiBzbyB0aGF0IGBhcHBseVN0eWxlYCBtb2RpZmllciBjYW4gYXBwbHkgaXQuIFRoaXMgc2VwYXJhdGlvbiBpcyB1c2VmdWxcbiAgICogaW4gY2FzZSB5b3UgbmVlZCB0byByZXBsYWNlIGBhcHBseVN0eWxlYCB3aXRoIGEgY3VzdG9tIGltcGxlbWVudGF0aW9uLlxuICAgKlxuICAgKiBUaGlzIG1vZGlmaWVyIGhhcyBgODUwYCBhcyBgb3JkZXJgIHZhbHVlIHRvIG1haW50YWluIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgICogd2l0aCBwcmV2aW91cyB2ZXJzaW9ucyBvZiBQb3BwZXIuanMuIEV4cGVjdCB0aGUgbW9kaWZpZXJzIG9yZGVyaW5nIG1ldGhvZFxuICAgKiB0byBjaGFuZ2UgaW4gZnV0dXJlIG1ham9yIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5LlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgY29tcHV0ZVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTg1MCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogODUwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogY29tcHV0ZVN0eWxlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtCb29sZWFufSBncHVBY2NlbGVyYXRpb249dHJ1ZVxuICAgICAqIElmIHRydWUsIGl0IHVzZXMgdGhlIENTUyAzRCB0cmFuc2Zvcm1hdGlvbiB0byBwb3NpdGlvbiB0aGUgcG9wcGVyLlxuICAgICAqIE90aGVyd2lzZSwgaXQgd2lsbCB1c2UgdGhlIGB0b3BgIGFuZCBgbGVmdGAgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nYm90dG9tJ11cbiAgICAgKiBXaGVyZSB0byBhbmNob3IgdGhlIFggYXhpcyAoYGJvdHRvbWAgb3IgYHRvcGApLiBBS0EgWCBvZmZzZXQgb3JpZ2luLlxuICAgICAqIENoYW5nZSB0aGlzIGlmIHlvdXIgcG9wcGVyIHNob3VsZCBncm93IGluIGEgZGlyZWN0aW9uIGRpZmZlcmVudCBmcm9tIGBib3R0b21gXG4gICAgICovXG4gICAgeDogJ2JvdHRvbScsXG4gICAgLyoqXG4gICAgICogQHByb3Age3N0cmluZ30gW3g9J2xlZnQnXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWSBheGlzIChgbGVmdGAgb3IgYHJpZ2h0YCkuIEFLQSBZIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYHJpZ2h0YFxuICAgICAqL1xuICAgIHk6ICdyaWdodCdcbiAgfSxcblxuICAvKipcbiAgICogQXBwbGllcyB0aGUgY29tcHV0ZWQgc3R5bGVzIHRvIHRoZSBwb3BwZXIgZWxlbWVudC5cbiAgICpcbiAgICogQWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyBhcmUgbGltaXRlZCB0byB0aGlzIG1vZGlmaWVyLiBUaGlzIGlzIHVzZWZ1bCBpbiBjYXNlXG4gICAqIHlvdSB3YW50IHRvIGludGVncmF0ZSBQb3BwZXIuanMgaW5zaWRlIGEgZnJhbWV3b3JrIG9yIHZpZXcgbGlicmFyeSBhbmQgeW91XG4gICAqIHdhbnQgdG8gZGVsZWdhdGUgYWxsIHRoZSBET00gbWFuaXB1bGF0aW9ucyB0byBpdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IGlmIHlvdSBkaXNhYmxlIHRoaXMgbW9kaWZpZXIsIHlvdSBtdXN0IG1ha2Ugc3VyZSB0aGUgcG9wcGVyIGVsZW1lbnRcbiAgICogaGFzIGl0cyBwb3NpdGlvbiBzZXQgdG8gYGFic29sdXRlYCBiZWZvcmUgUG9wcGVyLmpzIGNhbiBkbyBpdHMgd29yayFcbiAgICpcbiAgICogSnVzdCBkaXNhYmxlIHRoaXMgbW9kaWZpZXIgYW5kIGRlZmluZSB5b3VyIG93biB0byBhY2hpZXZlIHRoZSBkZXNpcmVkIGVmZmVjdC5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGFwcGx5U3R5bGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9OTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA5MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcHBseVN0eWxlLFxuICAgIC8qKiBAcHJvcCB7RnVuY3Rpb259ICovXG4gICAgb25Mb2FkOiBhcHBseVN0eWxlT25Mb2FkLFxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIHNpbmNlIHZlcnNpb24gMS4xMC4wLCB0aGUgcHJvcGVydHkgbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXJcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM0QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXNcbiAgICAgKi9cbiAgICBncHVBY2NlbGVyYXRpb246IHVuZGVmaW5lZFxuICB9XG59O1xuXG4vKipcbiAqIFRoZSBgZGF0YU9iamVjdGAgaXMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYWxsIHRoZSBpbmZvcm1hdGlvbiB1c2VkIGJ5IFBvcHBlci5qcy5cbiAqIFRoaXMgb2JqZWN0IGlzIHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7SFRNTEVsZW1lbnR9IGRhdGEuYXJyb3dFbGVtZW50IE5vZGUgdXNlZCBhcyBhcnJvdyBieSBhcnJvdyBtb2RpZmllclxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuc3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLiBJdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYXJyb3dTdHlsZXMgQW55IENTUyBwcm9wZXJ0eSBkZWZpbmVkIGhlcmUgd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIgYXJyb3cuIEl0IGV4cGVjdHMgdGhlIEphdmFTY3JpcHQgbm9tZW5jbGF0dXJlIChlZy4gYG1hcmdpbkJvdHRvbWApXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5ib3VuZGFyaWVzIE9mZnNldHMgb2YgdGhlIHBvcHBlciBib3VuZGFyaWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzIFRoZSBtZWFzdXJlbWVudHMgb2YgcG9wcGVyLCByZWZlcmVuY2UgYW5kIGFycm93IGVsZW1lbnRzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLnBvcHBlciBgdG9wYCwgYGxlZnRgLCBgd2lkdGhgLCBgaGVpZ2h0YCB2YWx1ZXNcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucmVmZXJlbmNlIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5hcnJvd10gYHRvcGAgYW5kIGBsZWZ0YCBvZmZzZXRzLCBvbmx5IG9uZSBvZiB0aGVtIHdpbGwgYmUgZGlmZmVyZW50IGZyb20gMFxuICovXG5cbi8qKlxuICogRGVmYXVsdCBvcHRpb25zIHByb3ZpZGVkIHRvIFBvcHBlci5qcyBjb25zdHJ1Y3Rvci48YnIgLz5cbiAqIFRoZXNlIGNhbiBiZSBvdmVycmlkZGVuIHVzaW5nIHRoZSBgb3B0aW9uc2AgYXJndW1lbnQgb2YgUG9wcGVyLmpzLjxiciAvPlxuICogVG8gb3ZlcnJpZGUgYW4gb3B0aW9uLCBzaW1wbHkgcGFzcyBhbiBvYmplY3Qgd2l0aCB0aGUgc2FtZVxuICogc3RydWN0dXJlIG9mIHRoZSBgb3B0aW9uc2Agb2JqZWN0LCBhcyB0aGUgM3JkIGFyZ3VtZW50LiBGb3IgZXhhbXBsZTpcbiAqIGBgYFxuICogbmV3IFBvcHBlcihyZWYsIHBvcCwge1xuICogICBtb2RpZmllcnM6IHtcbiAqICAgICBwcmV2ZW50T3ZlcmZsb3c6IHsgZW5hYmxlZDogZmFsc2UgfVxuICogICB9XG4gKiB9KVxuICogYGBgXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHN0YXRpY1xuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG52YXIgRGVmYXVsdHMgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnQuXG4gICAqIEBwcm9wIHtQb3BwZXIucGxhY2VtZW50c30gcGxhY2VtZW50PSdib3R0b20nXG4gICAqL1xuICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuXG4gIC8qKlxuICAgKiBTZXQgdGhpcyB0byB0cnVlIGlmIHlvdSB3YW50IHBvcHBlciB0byBwb3NpdGlvbiBpdCBzZWxmIGluICdmaXhlZCcgbW9kZVxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gcG9zaXRpb25GaXhlZD1mYWxzZVxuICAgKi9cbiAgcG9zaXRpb25GaXhlZDogZmFsc2UsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkLlxuICAgKiBAcHJvcCB7Qm9vbGVhbn0gZXZlbnRzRW5hYmxlZD10cnVlXG4gICAqL1xuICBldmVudHNFbmFibGVkOiB0cnVlLFxuXG4gIC8qKlxuICAgKiBTZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBhdXRvbWF0aWNhbGx5IHJlbW92ZSB0aGUgcG9wcGVyIHdoZW5cbiAgICogeW91IGNhbGwgdGhlIGBkZXN0cm95YCBtZXRob2QuXG4gICAqIEBwcm9wIHtCb29sZWFufSByZW1vdmVPbkRlc3Ryb3k9ZmFsc2VcbiAgICovXG4gIHJlbW92ZU9uRGVzdHJveTogZmFsc2UsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCB3aGVuIHRoZSBwb3BwZXIgaXMgY3JlYXRlZC48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25DcmVhdGV9XG4gICAqL1xuICBvbkNyZWF0ZTogZnVuY3Rpb24gb25DcmVhdGUoKSB7fSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyB1cGRhdGVkLiBUaGlzIGNhbGxiYWNrIGlzIG5vdCBjYWxsZWRcbiAgICogb24gdGhlIGluaXRpYWxpemF0aW9uL2NyZWF0aW9uIG9mIHRoZSBwb3BwZXIsIGJ1dCBvbmx5IG9uIHN1YnNlcXVlbnRcbiAgICogdXBkYXRlcy48YnIgLz5cbiAgICogQnkgZGVmYXVsdCwgaXQgaXMgc2V0IHRvIG5vLW9wLjxiciAvPlxuICAgKiBBY2Nlc3MgUG9wcGVyLmpzIGluc3RhbmNlIHdpdGggYGRhdGEuaW5zdGFuY2VgLlxuICAgKiBAcHJvcCB7b25VcGRhdGV9XG4gICAqL1xuICBvblVwZGF0ZTogZnVuY3Rpb24gb25VcGRhdGUoKSB7fSxcblxuICAvKipcbiAgICogTGlzdCBvZiBtb2RpZmllcnMgdXNlZCB0byBtb2RpZnkgdGhlIG9mZnNldHMgYmVmb3JlIHRoZXkgYXJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlci5cbiAgICogVGhleSBwcm92aWRlIG1vc3Qgb2YgdGhlIGZ1bmN0aW9uYWxpdGllcyBvZiBQb3BwZXIuanMuXG4gICAqIEBwcm9wIHttb2RpZmllcnN9XG4gICAqL1xuICBtb2RpZmllcnM6IG1vZGlmaWVyc1xufTtcblxuLyoqXG4gKiBAY2FsbGJhY2sgb25DcmVhdGVcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICovXG5cbi8qKlxuICogQGNhbGxiYWNrIG9uVXBkYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vLyBVdGlsc1xuLy8gTWV0aG9kc1xudmFyIFBvcHBlciA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlLlxuICAgKiBAY2xhc3MgUG9wcGVyXG4gICAqIEBwYXJhbSB7RWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCAvIFhNTCBlbGVtZW50IHVzZWQgYXMgdGhlIHBvcHBlclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIFlvdXIgY3VzdG9tIG9wdGlvbnMgdG8gb3ZlcnJpZGUgdGhlIG9uZXMgZGVmaW5lZCBpbiBbRGVmYXVsdHNdKCNkZWZhdWx0cylcbiAgICogQHJldHVybiB7T2JqZWN0fSBpbnN0YW5jZSAtIFRoZSBnZW5lcmF0ZWQgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqL1xuICBmdW5jdGlvbiBQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIFBvcHBlcik7XG5cbiAgICB0aGlzLnNjaGVkdWxlVXBkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHJlcXVlc3RBbmltYXRpb25GcmFtZShfdGhpcy51cGRhdGUpO1xuICAgIH07XG5cbiAgICAvLyBtYWtlIHVwZGF0ZSgpIGRlYm91bmNlZCwgc28gdGhhdCBpdCBvbmx5IHJ1bnMgYXQgbW9zdCBvbmNlLXBlci10aWNrXG4gICAgdGhpcy51cGRhdGUgPSBkZWJvdW5jZSh0aGlzLnVwZGF0ZS5iaW5kKHRoaXMpKTtcblxuICAgIC8vIHdpdGgge30gd2UgY3JlYXRlIGEgbmV3IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIGluc2lkZSBpdFxuICAgIHRoaXMub3B0aW9ucyA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMsIG9wdGlvbnMpO1xuXG4gICAgLy8gaW5pdCBzdGF0ZVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBpc0Rlc3Ryb3llZDogZmFsc2UsXG4gICAgICBpc0NyZWF0ZWQ6IGZhbHNlLFxuICAgICAgc2Nyb2xsUGFyZW50czogW11cbiAgICB9O1xuXG4gICAgLy8gZ2V0IHJlZmVyZW5jZSBhbmQgcG9wcGVyIGVsZW1lbnRzIChhbGxvdyBqUXVlcnkgd3JhcHBlcnMpXG4gICAgdGhpcy5yZWZlcmVuY2UgPSByZWZlcmVuY2UgJiYgcmVmZXJlbmNlLmpxdWVyeSA/IHJlZmVyZW5jZVswXSA6IHJlZmVyZW5jZTtcbiAgICB0aGlzLnBvcHBlciA9IHBvcHBlciAmJiBwb3BwZXIuanF1ZXJ5ID8gcG9wcGVyWzBdIDogcG9wcGVyO1xuXG4gICAgLy8gRGVlcCBtZXJnZSBtb2RpZmllcnMgb3B0aW9uc1xuICAgIHRoaXMub3B0aW9ucy5tb2RpZmllcnMgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVycywgb3B0aW9ucy5tb2RpZmllcnMpKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA9IF9leHRlbmRzKHt9LCBQb3BwZXIuRGVmYXVsdHMubW9kaWZpZXJzW25hbWVdIHx8IHt9LCBvcHRpb25zLm1vZGlmaWVycyA/IG9wdGlvbnMubW9kaWZpZXJzW25hbWVdIDoge30pO1xuICAgIH0pO1xuXG4gICAgLy8gUmVmYWN0b3JpbmcgbW9kaWZpZXJzJyBsaXN0IChPYmplY3QgPT4gQXJyYXkpXG4gICAgdGhpcy5tb2RpZmllcnMgPSBPYmplY3Qua2V5cyh0aGlzLm9wdGlvbnMubW9kaWZpZXJzKS5tYXAoZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICAgIG5hbWU6IG5hbWVcbiAgICAgIH0sIF90aGlzLm9wdGlvbnMubW9kaWZpZXJzW25hbWVdKTtcbiAgICB9KVxuICAgIC8vIHNvcnQgdGhlIG1vZGlmaWVycyBieSBvcmRlclxuICAgIC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICByZXR1cm4gYS5vcmRlciAtIGIub3JkZXI7XG4gICAgfSk7XG5cbiAgICAvLyBtb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIHdoZW4gUG9wcGVyLmpzIGdldCBpbml0ZWRcbiAgICAvLyBzdWNoIGNvZGUgaXMgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgb2YgaXRzIG1vZGlmaWVyXG4gICAgLy8gdGhleSBjb3VsZCBhZGQgbmV3IHByb3BlcnRpZXMgdG8gdGhlaXIgb3B0aW9ucyBjb25maWd1cmF0aW9uXG4gICAgLy8gQkUgQVdBUkU6IGRvbid0IGFkZCBvcHRpb25zIHRvIGBvcHRpb25zLm1vZGlmaWVycy5uYW1lYCBidXQgdG8gYG1vZGlmaWVyT3B0aW9uc2AhXG4gICAgdGhpcy5tb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXJPcHRpb25zKSB7XG4gICAgICBpZiAobW9kaWZpZXJPcHRpb25zLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihtb2RpZmllck9wdGlvbnMub25Mb2FkKSkge1xuICAgICAgICBtb2RpZmllck9wdGlvbnMub25Mb2FkKF90aGlzLnJlZmVyZW5jZSwgX3RoaXMucG9wcGVyLCBfdGhpcy5vcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIF90aGlzLnN0YXRlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIGZpcmUgdGhlIGZpcnN0IHVwZGF0ZSB0byBwb3NpdGlvbiB0aGUgcG9wcGVyIGluIHRoZSByaWdodCBwbGFjZVxuICAgIHRoaXMudXBkYXRlKCk7XG5cbiAgICB2YXIgZXZlbnRzRW5hYmxlZCA9IHRoaXMub3B0aW9ucy5ldmVudHNFbmFibGVkO1xuICAgIGlmIChldmVudHNFbmFibGVkKSB7XG4gICAgICAvLyBzZXR1cCBldmVudCBsaXN0ZW5lcnMsIHRoZXkgd2lsbCB0YWtlIGNhcmUgb2YgdXBkYXRlIHRoZSBwb3NpdGlvbiBpbiBzcGVjaWZpYyBzaXR1YXRpb25zXG4gICAgICB0aGlzLmVuYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgdGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkID0gZXZlbnRzRW5hYmxlZDtcbiAgfVxuXG4gIC8vIFdlIGNhbid0IHVzZSBjbGFzcyBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBkb24ndCBnZXQgbGlzdGVkIGluIHRoZVxuICAvLyBjbGFzcyBwcm90b3R5cGUgYW5kIGJyZWFrIHN0dWZmIGxpa2UgU2lub24gc3R1YnNcblxuXG4gIGNyZWF0ZUNsYXNzKFBvcHBlciwgW3tcbiAgICBrZXk6ICd1cGRhdGUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGUkJDEoKSB7XG4gICAgICByZXR1cm4gdXBkYXRlLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3kkJDEoKSB7XG4gICAgICByZXR1cm4gZGVzdHJveS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2VuYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZW5hYmxlRXZlbnRMaXN0ZW5lcnMuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdkaXNhYmxlRXZlbnRMaXN0ZW5lcnMnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEoKSB7XG4gICAgICByZXR1cm4gZGlzYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGVzIGFuIHVwZGF0ZS4gSXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZS5cbiAgICAgKiBAbWV0aG9kIHNjaGVkdWxlVXBkYXRlXG4gICAgICogQG1lbWJlcm9mIFBvcHBlclxuICAgICAqL1xuXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwLlxuICogQG5hbWUgcmVmZXJlbmNlT2JqZWN0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBkYXRhLmdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzZXQgb2YgY29vcmRpbmF0ZXMgY29tcGF0aWJsZSB3aXRoIHRoZSBuYXRpdmUgYGdldEJvdW5kaW5nQ2xpZW50UmVjdGAgbWV0aG9kLlxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRhdGEuY2xpZW50V2lkdGhcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgd2lkdGggb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRIZWlnaHRcbiAqIEFuIEVTNiBnZXR0ZXIgdGhhdCB3aWxsIHJldHVybiB0aGUgaGVpZ2h0IG9mIHRoZSB2aXJ0dWFsIHJlZmVyZW5jZSBlbGVtZW50LlxuICovXG5cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzO1xuXG5leHBvcnQgZGVmYXVsdCBQb3BwZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3BwZXIuanMubWFwXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IGRyb3Bkb3duLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSA9ICdkcm9wZG93bidcbmNvbnN0IFZFUlNJT04gPSAnNC42LjEnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5kcm9wZG93bidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBEQVRBX0FQSV9LRVkgPSAnLmRhdGEtYXBpJ1xuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuY29uc3QgRVNDQVBFX0tFWUNPREUgPSAyNyAvLyBLZXlib2FyZEV2ZW50LndoaWNoIHZhbHVlIGZvciBFc2NhcGUgKEVzYykga2V5XG5jb25zdCBTUEFDRV9LRVlDT0RFID0gMzIgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3Igc3BhY2Uga2V5XG5jb25zdCBUQUJfS0VZQ09ERSA9IDkgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgdGFiIGtleVxuY29uc3QgQVJST1dfVVBfS0VZQ09ERSA9IDM4IC8vIEtleWJvYXJkRXZlbnQud2hpY2ggdmFsdWUgZm9yIHVwIGFycm93IGtleVxuY29uc3QgQVJST1dfRE9XTl9LRVlDT0RFID0gNDAgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgZG93biBhcnJvdyBrZXlcbmNvbnN0IFJJR0hUX01PVVNFX0JVVFRPTl9XSElDSCA9IDMgLy8gTW91c2VFdmVudC53aGljaCB2YWx1ZSBmb3IgdGhlIHJpZ2h0IGJ1dHRvbiAoYXNzdW1pbmcgYSByaWdodC1oYW5kZWQgbW91c2UpXG5jb25zdCBSRUdFWFBfS0VZRE9XTiA9IG5ldyBSZWdFeHAoYCR7QVJST1dfVVBfS0VZQ09ERX18JHtBUlJPV19ET1dOX0tFWUNPREV9fCR7RVNDQVBFX0tFWUNPREV9YClcblxuY29uc3QgQ0xBU1NfTkFNRV9ESVNBQkxFRCA9ICdkaXNhYmxlZCdcbmNvbnN0IENMQVNTX05BTUVfU0hPVyA9ICdzaG93J1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVAgPSAnZHJvcHVwJ1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QUklHSFQgPSAnZHJvcHJpZ2h0J1xuY29uc3QgQ0xBU1NfTkFNRV9EUk9QTEVGVCA9ICdkcm9wbGVmdCdcbmNvbnN0IENMQVNTX05BTUVfTUVOVVJJR0hUID0gJ2Ryb3Bkb3duLW1lbnUtcmlnaHQnXG5jb25zdCBDTEFTU19OQU1FX1BPU0lUSU9OX1NUQVRJQyA9ICdwb3NpdGlvbi1zdGF0aWMnXG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLID0gYGNsaWNrJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWX0ke0RBVEFfQVBJX0tFWX1gXG5jb25zdCBFVkVOVF9LRVlVUF9EQVRBX0FQSSA9IGBrZXl1cCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwiZHJvcGRvd25cIl0nXG5jb25zdCBTRUxFQ1RPUl9GT1JNX0NISUxEID0gJy5kcm9wZG93biBmb3JtJ1xuY29uc3QgU0VMRUNUT1JfTUVOVSA9ICcuZHJvcGRvd24tbWVudSdcbmNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnXG5jb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJ1xuXG5jb25zdCBQTEFDRU1FTlRfVE9QID0gJ3RvcC1zdGFydCdcbmNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSAndG9wLWVuZCdcbmNvbnN0IFBMQUNFTUVOVF9CT1RUT00gPSAnYm90dG9tLXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX0JPVFRPTUVORCA9ICdib3R0b20tZW5kJ1xuY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gJ3JpZ2h0LXN0YXJ0J1xuY29uc3QgUExBQ0VNRU5UX0xFRlQgPSAnbGVmdC1zdGFydCdcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgb2Zmc2V0OiAwLFxuICBmbGlwOiB0cnVlLFxuICBib3VuZGFyeTogJ3Njcm9sbFBhcmVudCcsXG4gIHJlZmVyZW5jZTogJ3RvZ2dsZScsXG4gIGRpc3BsYXk6ICdkeW5hbWljJyxcbiAgcG9wcGVyQ29uZmlnOiBudWxsXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBvZmZzZXQ6ICcobnVtYmVyfHN0cmluZ3xmdW5jdGlvbiknLFxuICBmbGlwOiAnYm9vbGVhbicsXG4gIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gIHJlZmVyZW5jZTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICBkaXNwbGF5OiAnc3RyaW5nJyxcbiAgcG9wcGVyQ29uZmlnOiAnKG51bGx8b2JqZWN0KSdcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgRHJvcGRvd24ge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX21lbnUgPSB0aGlzLl9nZXRNZW51RWxlbWVudCgpXG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuXG4gICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKVxuICB9XG5cbiAgLy8gR2V0dGVyc1xuICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XG4gICAgcmV0dXJuIFZFUlNJT05cbiAgfVxuXG4gIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIC8vIFB1YmxpY1xuICB0b2dnbGUoKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaXNBY3RpdmUgPSAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIERyb3Bkb3duLl9jbGVhck1lbnVzKClcblxuICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5zaG93KHRydWUpXG4gIH1cblxuICBzaG93KHVzZVBvcHBlciA9IGZhbHNlKSB7XG4gICAgaWYgKHRoaXMuX2VsZW1lbnQuZGlzYWJsZWQgfHwgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSB8fCAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPVywgcmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQocGFyZW50KS50cmlnZ2VyKHNob3dFdmVudClcblxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIFRvdGFsbHkgZGlzYWJsZSBQb3BwZXIgZm9yIERyb3Bkb3ducyBpbiBOYXZiYXJcbiAgICBpZiAoIXRoaXMuX2luTmF2YmFyICYmIHVzZVBvcHBlcikge1xuICAgICAgLy8gQ2hlY2sgZm9yIFBvcHBlciBkZXBlbmRlbmN5XG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQm9vdHN0cmFwXFwncyBkcm9wZG93bnMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKVxuICAgICAgfVxuXG4gICAgICBsZXQgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2VsZW1lbnRcblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBwYXJlbnRcbiAgICAgIH0gZWxzZSBpZiAoVXRpbC5pc0VsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSkpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VcblxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIGpRdWVyeSBlbGVtZW50XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZS5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2VbMF1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJZiBib3VuZGFyeSBpcyBub3QgYHNjcm9sbFBhcmVudGAsIHRoZW4gc2V0IHBvc2l0aW9uIHRvIGBzdGF0aWNgXG4gICAgICAvLyB0byBhbGxvdyB0aGUgbWVudSB0byBcImVzY2FwZVwiIHRoZSBzY3JvbGwgcGFyZW50J3MgYm91bmRhcmllc1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8yNDI1MVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5ib3VuZGFyeSAhPT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgICAgJChwYXJlbnQpLmFkZENsYXNzKENMQVNTX05BTUVfUE9TSVRJT05fU1RBVElDKVxuICAgICAgfVxuXG4gICAgICB0aGlzLl9wb3BwZXIgPSBuZXcgUG9wcGVyKHJlZmVyZW5jZUVsZW1lbnQsIHRoaXMuX21lbnUsIHRoaXMuX2dldFBvcHBlckNvbmZpZygpKVxuICAgIH1cblxuICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSBhZGQgZXh0cmFcbiAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgIC8vIG9ubHkgbmVlZGVkIGJlY2F1c2Ugb2YgYnJva2VuIGV2ZW50IGRlbGVnYXRpb24gb24gaU9TXG4gICAgLy8gaHR0cHM6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDE0LzAyL21vdXNlX2V2ZW50X2J1Yi5odG1sXG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJlxuICAgICAgICAkKHBhcmVudCkuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVJfTkFWKS5sZW5ndGggPT09IDApIHtcbiAgICAgICQoZG9jdW1lbnQuYm9keSkuY2hpbGRyZW4oKS5vbignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgIH1cblxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcblxuICAgICQodGhpcy5fbWVudSkudG9nZ2xlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICQocGFyZW50KVxuICAgICAgLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVylcbiAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRVZFTlRfU0hPV04sIHJlbGF0ZWRUYXJnZXQpKVxuICB9XG5cbiAgaGlkZSgpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5kaXNhYmxlZCB8fCAkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRElTQUJMRUQpIHx8ICEkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgfVxuICAgIGNvbnN0IGhpZGVFdmVudCA9ICQuRXZlbnQoRVZFTlRfSElERSwgcmVsYXRlZFRhcmdldClcbiAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICQocGFyZW50KS50cmlnZ2VyKGhpZGVFdmVudClcblxuICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICB9XG5cbiAgICAkKHRoaXMuX21lbnUpLnRvZ2dsZUNsYXNzKENMQVNTX05BTUVfU0hPVylcbiAgICAkKHBhcmVudClcbiAgICAgIC50b2dnbGVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG4gICAgICAudHJpZ2dlcigkLkV2ZW50KEVWRU5UX0hJRERFTiwgcmVsYXRlZFRhcmdldCkpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9LRVkpXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9tZW51ID0gbnVsbFxuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KClcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGxcbiAgICB9XG4gIH1cblxuICB1cGRhdGUoKSB7XG4gICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKVxuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbihFVkVOVF9DTElDSywgZXZlbnQgPT4ge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHRoaXMudG9nZ2xlKClcbiAgICB9KVxuICB9XG5cbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi50aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHQsXG4gICAgICAuLi4kKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cblxuICAgIFV0aWwudHlwZUNoZWNrQ29uZmlnKFxuICAgICAgTkFNRSxcbiAgICAgIGNvbmZpZyxcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuRGVmYXVsdFR5cGVcbiAgICApXG5cbiAgICByZXR1cm4gY29uZmlnXG4gIH1cblxuICBfZ2V0TWVudUVsZW1lbnQoKSB7XG4gICAgaWYgKCF0aGlzLl9tZW51KSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBEcm9wZG93bi5fZ2V0UGFyZW50RnJvbUVsZW1lbnQodGhpcy5fZWxlbWVudClcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB0aGlzLl9tZW51ID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTUVOVSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fbWVudVxuICB9XG5cbiAgX2dldFBsYWNlbWVudCgpIHtcbiAgICBjb25zdCAkcGFyZW50RHJvcGRvd24gPSAkKHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSlcbiAgICBsZXQgcGxhY2VtZW50ID0gUExBQ0VNRU5UX0JPVFRPTVxuXG4gICAgLy8gSGFuZGxlIGRyb3B1cFxuICAgIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QVVApKSB7XG4gICAgICBwbGFjZW1lbnQgPSAkKHRoaXMuX21lbnUpLmhhc0NsYXNzKENMQVNTX05BTUVfTUVOVVJJR0hUKSA/XG4gICAgICAgIFBMQUNFTUVOVF9UT1BFTkQgOlxuICAgICAgICBQTEFDRU1FTlRfVE9QXG4gICAgfSBlbHNlIGlmICgkcGFyZW50RHJvcGRvd24uaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfUklHSFRcbiAgICB9IGVsc2UgaWYgKCRwYXJlbnREcm9wZG93bi5oYXNDbGFzcyhDTEFTU19OQU1FX0RST1BMRUZUKSkge1xuICAgICAgcGxhY2VtZW50ID0gUExBQ0VNRU5UX0xFRlRcbiAgICB9IGVsc2UgaWYgKCQodGhpcy5fbWVudSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9NRU5VUklHSFQpKSB7XG4gICAgICBwbGFjZW1lbnQgPSBQTEFDRU1FTlRfQk9UVE9NRU5EXG4gICAgfVxuXG4gICAgcmV0dXJuIHBsYWNlbWVudFxuICB9XG5cbiAgX2RldGVjdE5hdmJhcigpIHtcbiAgICByZXR1cm4gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KCcubmF2YmFyJykubGVuZ3RoID4gMFxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB7fVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLl9jb25maWcub2Zmc2V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvZmZzZXQuZm4gPSBkYXRhID0+IHtcbiAgICAgICAgZGF0YS5vZmZzZXRzID0ge1xuICAgICAgICAgIC4uLmRhdGEub2Zmc2V0cyxcbiAgICAgICAgICAuLi50aGlzLl9jb25maWcub2Zmc2V0KGRhdGEub2Zmc2V0cywgdGhpcy5fZWxlbWVudClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLl9jb25maWcub2Zmc2V0XG4gICAgfVxuXG4gICAgcmV0dXJuIG9mZnNldFxuICB9XG5cbiAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICBjb25zdCBwb3BwZXJDb25maWcgPSB7XG4gICAgICBwbGFjZW1lbnQ6IHRoaXMuX2dldFBsYWNlbWVudCgpLFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXG4gICAgICAgIGZsaXA6IHtcbiAgICAgICAgICBlbmFibGVkOiB0aGlzLl9jb25maWcuZmxpcFxuICAgICAgICB9LFxuICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXlcbiAgICBpZiAodGhpcy5fY29uZmlnLmRpc3BsYXkgPT09ICdzdGF0aWMnKSB7XG4gICAgICBwb3BwZXJDb25maWcubW9kaWZpZXJzLmFwcGx5U3R5bGUgPSB7XG4gICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnBvcHBlckNvbmZpZyxcbiAgICAgIC4uLnRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWdcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBsZXQgZGF0YSA9ICQodGhpcykuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IG51bGxcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRHJvcGRvd24odGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG5cbiAgc3RhdGljIF9jbGVhck1lbnVzKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50ICYmIChldmVudC53aGljaCA9PT0gUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIHx8XG4gICAgICBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LndoaWNoICE9PSBUQUJfS0VZQ09ERSkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHRvZ2dsZXMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfREFUQV9UT0dHTEUpKVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRvZ2dsZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IERyb3Bkb3duLl9nZXRQYXJlbnRGcm9tRWxlbWVudCh0b2dnbGVzW2ldKVxuICAgICAgY29uc3QgY29udGV4dCA9ICQodG9nZ2xlc1tpXSkuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRvZ2dsZXNbaV1cbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ICYmIGV2ZW50LnR5cGUgPT09ICdjbGljaycpIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnRcbiAgICAgIH1cblxuICAgICAgaWYgKCFjb250ZXh0KSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRyb3Bkb3duTWVudSA9IGNvbnRleHQuX21lbnVcbiAgICAgIGlmICghJChwYXJlbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgaWYgKGV2ZW50ICYmIChldmVudC50eXBlID09PSAnY2xpY2snICYmXG4gICAgICAgICAgL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC53aGljaCA9PT0gVEFCX0tFWUNPREUpICYmXG4gICAgICAgICAgJC5jb250YWlucyhwYXJlbnQsIGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFLCByZWxhdGVkVGFyZ2V0KVxuICAgICAgJChwYXJlbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgICAgaWYgKGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgICAgfVxuXG4gICAgICB0b2dnbGVzW2ldLnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpXG5cbiAgICAgIGlmIChjb250ZXh0Ll9wb3BwZXIpIHtcbiAgICAgICAgY29udGV4dC5fcG9wcGVyLmRlc3Ryb3koKVxuICAgICAgfVxuXG4gICAgICAkKGRyb3Bkb3duTWVudSkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgJChwYXJlbnQpXG4gICAgICAgIC5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG4gICAgICAgIC50cmlnZ2VyKCQuRXZlbnQoRVZFTlRfSElEREVOLCByZWxhdGVkVGFyZ2V0KSlcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgX2dldFBhcmVudEZyb21FbGVtZW50KGVsZW1lbnQpIHtcbiAgICBsZXQgcGFyZW50XG4gICAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcblxuICAgIGlmIChzZWxlY3Rvcikge1xuICAgICAgcGFyZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyZW50IHx8IGVsZW1lbnQucGFyZW50Tm9kZVxuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbiAgc3RhdGljIF9kYXRhQXBpS2V5ZG93bkhhbmRsZXIoZXZlbnQpIHtcbiAgICAvLyBJZiBub3QgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gQW5kIG5vdCBhIGtleSBpbiBSRUdFWFBfS0VZRE9XTiA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gSWYgaW5wdXQvdGV4dGFyZWE6XG4gICAgLy8gIC0gSWYgc3BhY2Uga2V5ID0+IG5vdCBhIGRyb3Bkb3duIGNvbW1hbmRcbiAgICAvLyAgLSBJZiBrZXkgaXMgb3RoZXIgdGhhbiBlc2NhcGVcbiAgICAvLyAgICAtIElmIGtleSBpcyBub3QgdXAgb3IgZG93biA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgLy8gICAgLSBJZiB0cmlnZ2VyIGluc2lkZSB0aGUgbWVudSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgaWYgKC9pbnB1dHx0ZXh0YXJlYS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpID9cbiAgICAgIGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoICE9PSBFU0NBUEVfS0VZQ09ERSAmJlxuICAgICAgKGV2ZW50LndoaWNoICE9PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgZXZlbnQud2hpY2ggIT09IEFSUk9XX1VQX0tFWUNPREUgfHxcbiAgICAgICAgJChldmVudC50YXJnZXQpLmNsb3Nlc3QoU0VMRUNUT1JfTUVOVSkubGVuZ3RoKSA6ICFSRUdFWFBfS0VZRE9XTi50ZXN0KGV2ZW50LndoaWNoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZGlzYWJsZWQgfHwgJCh0aGlzKS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgcGFyZW50ID0gRHJvcGRvd24uX2dldFBhcmVudEZyb21FbGVtZW50KHRoaXMpXG4gICAgY29uc3QgaXNBY3RpdmUgPSAkKHBhcmVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSAmJiBldmVudC53aGljaCA9PT0gRVNDQVBFX0tFWUNPREUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuXG4gICAgaWYgKCFpc0FjdGl2ZSB8fCAoZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFIHx8IGV2ZW50LndoaWNoID09PSBTUEFDRV9LRVlDT0RFKSkge1xuICAgICAgaWYgKGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAkKHBhcmVudC5xdWVyeVNlbGVjdG9yKFNFTEVDVE9SX0RBVEFfVE9HR0xFKSkudHJpZ2dlcignZm9jdXMnKVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ2NsaWNrJylcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGl0ZW1zID0gW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TKSlcbiAgICAgIC5maWx0ZXIoaXRlbSA9PiAkKGl0ZW0pLmlzKCc6dmlzaWJsZScpKVxuXG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IGluZGV4ID0gaXRlbXMuaW5kZXhPZihldmVudC50YXJnZXQpXG5cbiAgICBpZiAoZXZlbnQud2hpY2ggPT09IEFSUk9XX1VQX0tFWUNPREUgJiYgaW5kZXggPiAwKSB7IC8vIFVwXG4gICAgICBpbmRleC0tXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LndoaWNoID09PSBBUlJPV19ET1dOX0tFWUNPREUgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxKSB7IC8vIERvd25cbiAgICAgIGluZGV4KytcbiAgICB9XG5cbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBpbmRleCA9IDBcbiAgICB9XG5cbiAgICBpdGVtc1tpbmRleF0uZm9jdXMoKVxuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG4kKGRvY3VtZW50KVxuICAub24oRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIERyb3Bkb3duLl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIpXG4gIC5vbihFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5fZGF0YUFwaUtleWRvd25IYW5kbGVyKVxuICAub24oYCR7RVZFTlRfQ0xJQ0tfREFUQV9BUEl9ICR7RVZFTlRfS0VZVVBfREFUQV9BUEl9YCwgRHJvcGRvd24uX2NsZWFyTWVudXMpXG4gIC5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKVxuICAgIERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2UuY2FsbCgkKHRoaXMpLCAndG9nZ2xlJylcbiAgfSlcbiAgLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9GT1JNX0NISUxELCBlID0+IHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpXG4gIH0pXG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuJC5mbltOQU1FXSA9IERyb3Bkb3duLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBEcm9wZG93blxuJC5mbltOQU1FXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAkLmZuW05BTUVdID0gSlFVRVJZX05PX0NPTkZMSUNUXG4gIHJldHVybiBEcm9wZG93bi5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IERyb3Bkb3duXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IG1vZGFsLmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAnbW9kYWwnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4xJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMubW9kYWwnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cbmNvbnN0IEVTQ0FQRV9LRVlDT0RFID0gMjcgLy8gS2V5Ym9hcmRFdmVudC53aGljaCB2YWx1ZSBmb3IgRXNjYXBlIChFc2MpIGtleVxuXG5jb25zdCBDTEFTU19OQU1FX1NDUk9MTEFCTEUgPSAnbW9kYWwtZGlhbG9nLXNjcm9sbGFibGUnXG5jb25zdCBDTEFTU19OQU1FX1NDUk9MTEJBUl9NRUFTVVJFUiA9ICdtb2RhbC1zY3JvbGxiYXItbWVhc3VyZSdcbmNvbnN0IENMQVNTX05BTUVfQkFDS0RST1AgPSAnbW9kYWwtYmFja2Ryb3AnXG5jb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3BlbidcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5jb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnXG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJREVfUFJFVkVOVEVEID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX01PVVNFVVBfRElTTUlTUyA9IGBtb3VzZXVwLmRpc21pc3Mke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZydcbmNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknXG5jb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS10b2dnbGU9XCJtb2RhbFwiXSdcbmNvbnN0IFNFTEVDVE9SX0RBVEFfRElTTUlTUyA9ICdbZGF0YS1kaXNtaXNzPVwibW9kYWxcIl0nXG5jb25zdCBTRUxFQ1RPUl9GSVhFRF9DT05URU5UID0gJy5maXhlZC10b3AsIC5maXhlZC1ib3R0b20sIC5pcy1maXhlZCwgLnN0aWNreS10b3AnXG5jb25zdCBTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCA9ICcuc3RpY2t5LXRvcCdcblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYmFja2Ryb3A6IHRydWUsXG4gIGtleWJvYXJkOiB0cnVlLFxuICBmb2N1czogdHJ1ZSxcbiAgc2hvdzogdHJ1ZVxufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgZm9jdXM6ICdib29sZWFuJyxcbiAgc2hvdzogJ2Jvb2xlYW4nXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIE1vZGFsIHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudFxuICAgIHRoaXMuX2RpYWxvZyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvcihTRUxFQ1RPUl9ESUFMT0cpXG4gICAgdGhpcy5fYmFja2Ryb3AgPSBudWxsXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG4gICAgdGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgPSBmYWxzZVxuICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBmYWxzZVxuICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlXG4gICAgdGhpcy5fc2Nyb2xsYmFyV2lkdGggPSAwXG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgdG9nZ2xlKHJlbGF0ZWRUYXJnZXQpIHtcbiAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpXG4gIH1cblxuICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IHNob3dFdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPVywge1xuICAgICAgcmVsYXRlZFRhcmdldFxuICAgIH0pXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuXG4gICAgaWYgKHNob3dFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IHRydWVcblxuICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9jaGVja1Njcm9sbGJhcigpXG4gICAgdGhpcy5fc2V0U2Nyb2xsYmFyKClcblxuICAgIHRoaXMuX2FkanVzdERpYWxvZygpXG5cbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS5vbihcbiAgICAgIEVWRU5UX0NMSUNLX0RJU01JU1MsXG4gICAgICBTRUxFQ1RPUl9EQVRBX0RJU01JU1MsXG4gICAgICBldmVudCA9PiB0aGlzLmhpZGUoZXZlbnQpXG4gICAgKVxuXG4gICAgJCh0aGlzLl9kaWFsb2cpLm9uKEVWRU5UX01PVVNFRE9XTl9ESVNNSVNTLCAoKSA9PiB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShFVkVOVF9NT1VTRVVQX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKCQoZXZlbnQudGFyZ2V0KS5pcyh0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSlcblxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSlcbiAgfVxuXG4gIGhpZGUoZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50KVxuXG4gICAgaWYgKCF0aGlzLl9pc1Nob3duIHx8IGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdGhpcy5faXNTaG93biA9IGZhbHNlXG4gICAgY29uc3QgdHJhbnNpdGlvbiA9ICQodGhpcy5fZWxlbWVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKVxuXG4gICAgaWYgKHRyYW5zaXRpb24pIHtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLl9zZXRFc2NhcGVFdmVudCgpXG4gICAgdGhpcy5fc2V0UmVzaXplRXZlbnQoKVxuXG4gICAgJChkb2N1bWVudCkub2ZmKEVWRU5UX0ZPQ1VTSU4pXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKEVWRU5UX0NMSUNLX0RJU01JU1MpXG4gICAgJCh0aGlzLl9kaWFsb2cpLm9mZihFVkVOVF9NT1VTRURPV05fRElTTUlTUylcblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBldmVudCA9PiB0aGlzLl9oaWRlTW9kYWwoZXZlbnQpKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oaWRlTW9kYWwoKVxuICAgIH1cbiAgfVxuXG4gIGRpc3Bvc2UoKSB7XG4gICAgW3dpbmRvdywgdGhpcy5fZWxlbWVudCwgdGhpcy5fZGlhbG9nXVxuICAgICAgLmZvckVhY2goaHRtbEVsZW1lbnQgPT4gJChodG1sRWxlbWVudCkub2ZmKEVWRU5UX0tFWSkpXG5cbiAgICAvKipcbiAgICAgKiBgZG9jdW1lbnRgIGhhcyAyIGV2ZW50cyBgRVZFTlRfRk9DVVNJTmAgYW5kIGBFVkVOVF9DTElDS19EQVRBX0FQSWBcbiAgICAgKiBEbyBub3QgbW92ZSBgZG9jdW1lbnRgIGluIGBodG1sRWxlbWVudHNgIGFycmF5XG4gICAgICogSXQgd2lsbCByZW1vdmUgYEVWRU5UX0NMSUNLX0RBVEFfQVBJYCBldmVudCB0aGF0IHNob3VsZCByZW1haW5cbiAgICAgKi9cbiAgICAkKGRvY3VtZW50KS5vZmYoRVZFTlRfRk9DVVNJTilcblxuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcblxuICAgIHRoaXMuX2NvbmZpZyA9IG51bGxcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX2RpYWxvZyA9IG51bGxcbiAgICB0aGlzLl9iYWNrZHJvcCA9IG51bGxcbiAgICB0aGlzLl9pc1Nob3duID0gbnVsbFxuICAgIHRoaXMuX2lzQm9keU92ZXJmbG93aW5nID0gbnVsbFxuICAgIHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2sgPSBudWxsXG4gICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gbnVsbFxuICB9XG5cbiAgaGFuZGxlVXBkYXRlKCkge1xuICAgIHRoaXMuX2FkanVzdERpYWxvZygpXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgY29uZmlnID0ge1xuICAgICAgLi4uRGVmYXVsdCxcbiAgICAgIC4uLmNvbmZpZ1xuICAgIH1cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhOQU1FLCBjb25maWcsIERlZmF1bHRUeXBlKVxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgIGNvbnN0IGhpZGVFdmVudFByZXZlbnRlZCA9ICQuRXZlbnQoRVZFTlRfSElERV9QUkVWRU5URUQpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoaGlkZUV2ZW50UHJldmVudGVkKVxuICAgIGlmIChoaWRlRXZlbnRQcmV2ZW50ZWQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbidcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpXG5cbiAgICBjb25zdCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy5fZGlhbG9nKVxuICAgICQodGhpcy5fZWxlbWVudCkub2ZmKFV0aWwuVFJBTlNJVElPTl9FTkQpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TVEFUSUMpXG4gICAgICBpZiAoIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvd1kgPSAnJ1xuICAgICAgICB9KVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50LCBtb2RhbFRyYW5zaXRpb25EdXJhdGlvbilcbiAgICAgIH1cbiAgICB9KVxuICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKG1vZGFsVHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICB9XG5cbiAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICBjb25zdCB0cmFuc2l0aW9uID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpXG4gICAgY29uc3QgbW9kYWxCb2R5ID0gdGhpcy5fZGlhbG9nID8gdGhpcy5fZGlhbG9nLnF1ZXJ5U2VsZWN0b3IoU0VMRUNUT1JfTU9EQUxfQk9EWSkgOiBudWxsXG5cbiAgICBpZiAoIXRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSB8fFxuICAgICAgICB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAvLyBEb24ndCBtb3ZlIG1vZGFsJ3MgRE9NIHBvc2l0aW9uXG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMuX2VsZW1lbnQpXG4gICAgfVxuXG4gICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJ1xuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpXG4gICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKVxuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpXG5cbiAgICBpZiAoJCh0aGlzLl9kaWFsb2cpLmhhc0NsYXNzKENMQVNTX05BTUVfU0NST0xMQUJMRSkgJiYgbW9kYWxCb2R5KSB7XG4gICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnNjcm9sbFRvcCA9IDBcbiAgICB9XG5cbiAgICBpZiAodHJhbnNpdGlvbikge1xuICAgICAgVXRpbC5yZWZsb3codGhpcy5fZWxlbWVudClcbiAgICB9XG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLmFkZENsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgIHRoaXMuX2VuZm9yY2VGb2N1cygpXG4gICAgfVxuXG4gICAgY29uc3Qgc2hvd25FdmVudCA9ICQuRXZlbnQoRVZFTlRfU0hPV04sIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICB9KVxuXG4gICAgY29uc3QgdHJhbnNpdGlvbkNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKClcbiAgICAgIH1cblxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2VcbiAgICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93bkV2ZW50KVxuICAgIH1cblxuICAgIGlmICh0cmFuc2l0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2RpYWxvZylcblxuICAgICAgJCh0aGlzLl9kaWFsb2cpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgdHJhbnNpdGlvbkNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2l0aW9uQ29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIF9lbmZvcmNlRm9jdXMoKSB7XG4gICAgJChkb2N1bWVudClcbiAgICAgIC5vZmYoRVZFTlRfRk9DVVNJTikgLy8gR3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXG4gICAgICAub24oRVZFTlRfRk9DVVNJTiwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoZG9jdW1lbnQgIT09IGV2ZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQudGFyZ2V0ICYmXG4gICAgICAgICAgICAkKHRoaXMuX2VsZW1lbnQpLmhhcyhldmVudC50YXJnZXQpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKVxuICAgICAgICB9XG4gICAgICB9KVxuICB9XG5cbiAgX3NldEVzY2FwZUV2ZW50KCkge1xuICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkICYmIGV2ZW50LndoaWNoID09PSBFU0NBUEVfS0VZQ09ERSkge1xuICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9jb25maWcua2V5Ym9hcmQgJiYgZXZlbnQud2hpY2ggPT09IEVTQ0FQRV9LRVlDT0RFKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSBlbHNlIGlmICghdGhpcy5faXNTaG93bikge1xuICAgICAgJCh0aGlzLl9lbGVtZW50KS5vZmYoRVZFTlRfS0VZRE9XTl9ESVNNSVNTKVxuICAgIH1cbiAgfVxuXG4gIF9zZXRSZXNpemVFdmVudCgpIHtcbiAgICBpZiAodGhpcy5faXNTaG93bikge1xuICAgICAgJCh3aW5kb3cpLm9uKEVWRU5UX1JFU0laRSwgZXZlbnQgPT4gdGhpcy5oYW5kbGVVcGRhdGUoZXZlbnQpKVxuICAgIH0gZWxzZSB7XG4gICAgICAkKHdpbmRvdykub2ZmKEVWRU5UX1JFU0laRSlcbiAgICB9XG4gIH1cblxuICBfaGlkZU1vZGFsKCkge1xuICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJ1xuICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWhpZGRlbicsIHRydWUpXG4gICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKVxuICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJylcbiAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZVxuICAgIHRoaXMuX3Nob3dCYWNrZHJvcCgoKSA9PiB7XG4gICAgICAkKGRvY3VtZW50LmJvZHkpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfT1BFTilcbiAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKVxuICAgICAgdGhpcy5fcmVzZXRTY3JvbGxiYXIoKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX0hJRERFTilcbiAgICB9KVxuICB9XG5cbiAgX3JlbW92ZUJhY2tkcm9wKCkge1xuICAgIGlmICh0aGlzLl9iYWNrZHJvcCkge1xuICAgICAgJCh0aGlzLl9iYWNrZHJvcCkucmVtb3ZlKClcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gbnVsbFxuICAgIH1cbiAgfVxuXG4gIF9zaG93QmFja2Ryb3AoY2FsbGJhY2spIHtcbiAgICBjb25zdCBhbmltYXRlID0gJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpID9cbiAgICAgIENMQVNTX05BTUVfRkFERSA6ICcnXG5cbiAgICBpZiAodGhpcy5faXNTaG93biAmJiB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmNsYXNzTmFtZSA9IENMQVNTX05BTUVfQkFDS0RST1BcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgdGhpcy5fYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChhbmltYXRlKVxuICAgICAgfVxuXG4gICAgICAkKHRoaXMuX2JhY2tkcm9wKS5hcHBlbmRUbyhkb2N1bWVudC5ib2R5KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RJU01JU1MsIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lnbm9yZUJhY2tkcm9wQ2xpY2spIHtcbiAgICAgICAgICB0aGlzLl9pZ25vcmVCYWNrZHJvcENsaWNrID0gZmFsc2VcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGV2ZW50LmN1cnJlbnRUYXJnZXQpIHtcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3AgPT09ICdzdGF0aWMnKSB7XG4gICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5oaWRlKClcbiAgICAgICAgfVxuICAgICAgfSlcblxuICAgICAgaWYgKGFuaW1hdGUpIHtcbiAgICAgICAgVXRpbC5yZWZsb3codGhpcy5fYmFja2Ryb3ApXG4gICAgICB9XG5cbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLmFkZENsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFhbmltYXRlKSB7XG4gICAgICAgIGNhbGxiYWNrKClcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9iYWNrZHJvcClcblxuICAgICAgJCh0aGlzLl9iYWNrZHJvcClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFjaylcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKGJhY2tkcm9wVHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2hvd24gJiYgdGhpcy5fYmFja2Ryb3ApIHtcbiAgICAgICQodGhpcy5fYmFja2Ryb3ApLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfU0hPVylcblxuICAgICAgY29uc3QgY2FsbGJhY2tSZW1vdmUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUJhY2tkcm9wKClcbiAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgkKHRoaXMuX2VsZW1lbnQpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgICAgY29uc3QgYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2JhY2tkcm9wKVxuXG4gICAgICAgICQodGhpcy5fYmFja2Ryb3ApXG4gICAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjYWxsYmFja1JlbW92ZSlcbiAgICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQoYmFja2Ryb3BUcmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFja1JlbW92ZSgpXG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKVxuICAgIH1cbiAgfVxuXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gdGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgLy8gdG9kbyAoZmF0KTogdGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIHJlZmFjdG9yZWQgb3V0IG9mIG1vZGFsLmpzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBfYWRqdXN0RGlhbG9nKCkge1xuICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodFxuXG4gICAgaWYgKCF0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUucGFkZGluZ0xlZnQgPSBgJHt0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGBcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nUmlnaHQgPSBgJHt0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGBcbiAgICB9XG4gIH1cblxuICBfcmVzZXRBZGp1c3RtZW50cygpIHtcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJydcbiAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnXG4gIH1cblxuICBfY2hlY2tTY3JvbGxiYXIoKSB7XG4gICAgY29uc3QgcmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICB0aGlzLl9pc0JvZHlPdmVyZmxvd2luZyA9IE1hdGgucm91bmQocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgPCB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHRoaXMuX3Njcm9sbGJhcldpZHRoID0gdGhpcy5fZ2V0U2Nyb2xsYmFyV2lkdGgoKVxuICB9XG5cbiAgX3NldFNjcm9sbGJhcigpIHtcbiAgICBpZiAodGhpcy5faXNCb2R5T3ZlcmZsb3dpbmcpIHtcbiAgICAgIC8vIE5vdGU6IERPTU5vZGUuc3R5bGUucGFkZGluZ1JpZ2h0IHJldHVybnMgdGhlIGFjdHVhbCB2YWx1ZSBvciAnJyBpZiBub3Qgc2V0XG4gICAgICAvLyAgIHdoaWxlICQoRE9NTm9kZSkuY3NzKCdwYWRkaW5nLXJpZ2h0JykgcmV0dXJucyB0aGUgY2FsY3VsYXRlZCB2YWx1ZSBvciAwIGlmIG5vdCBzZXRcbiAgICAgIGNvbnN0IGZpeGVkQ29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSVhFRF9DT05URU5UKSlcbiAgICAgIGNvbnN0IHN0aWNreUNvbnRlbnQgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQpKVxuXG4gICAgICAvLyBBZGp1c3QgZml4ZWQgY29udGVudCBwYWRkaW5nXG4gICAgICAkKGZpeGVkQ29udGVudCkuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgYWN0dWFsUGFkZGluZyA9IGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0XG4gICAgICAgIGNvbnN0IGNhbGN1bGF0ZWRQYWRkaW5nID0gJChlbGVtZW50KS5jc3MoJ3BhZGRpbmctcmlnaHQnKVxuICAgICAgICAkKGVsZW1lbnQpXG4gICAgICAgICAgLmRhdGEoJ3BhZGRpbmctcmlnaHQnLCBhY3R1YWxQYWRkaW5nKVxuICAgICAgICAgIC5jc3MoJ3BhZGRpbmctcmlnaHQnLCBgJHtwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIHRoaXMuX3Njcm9sbGJhcldpZHRofXB4YClcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkanVzdCBzdGlja3kgY29udGVudCBtYXJnaW5cbiAgICAgICQoc3RpY2t5Q29udGVudCkuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgICAgY29uc3QgYWN0dWFsTWFyZ2luID0gZWxlbWVudC5zdHlsZS5tYXJnaW5SaWdodFxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkTWFyZ2luID0gJChlbGVtZW50KS5jc3MoJ21hcmdpbi1yaWdodCcpXG4gICAgICAgICQoZWxlbWVudClcbiAgICAgICAgICAuZGF0YSgnbWFyZ2luLXJpZ2h0JywgYWN0dWFsTWFyZ2luKVxuICAgICAgICAgIC5jc3MoJ21hcmdpbi1yaWdodCcsIGAke3BhcnNlRmxvYXQoY2FsY3VsYXRlZE1hcmdpbikgLSB0aGlzLl9zY3JvbGxiYXJXaWR0aH1weGApXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGp1c3QgYm9keSBwYWRkaW5nXG4gICAgICBjb25zdCBhY3R1YWxQYWRkaW5nID0gZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHRcbiAgICAgIGNvbnN0IGNhbGN1bGF0ZWRQYWRkaW5nID0gJChkb2N1bWVudC5ib2R5KS5jc3MoJ3BhZGRpbmctcmlnaHQnKVxuICAgICAgJChkb2N1bWVudC5ib2R5KVxuICAgICAgICAuZGF0YSgncGFkZGluZy1yaWdodCcsIGFjdHVhbFBhZGRpbmcpXG4gICAgICAgIC5jc3MoJ3BhZGRpbmctcmlnaHQnLCBgJHtwYXJzZUZsb2F0KGNhbGN1bGF0ZWRQYWRkaW5nKSArIHRoaXMuX3Njcm9sbGJhcldpZHRofXB4YClcbiAgICB9XG5cbiAgICAkKGRvY3VtZW50LmJvZHkpLmFkZENsYXNzKENMQVNTX05BTUVfT1BFTilcbiAgfVxuXG4gIF9yZXNldFNjcm9sbGJhcigpIHtcbiAgICAvLyBSZXN0b3JlIGZpeGVkIGNvbnRlbnQgcGFkZGluZ1xuICAgIGNvbnN0IGZpeGVkQ29udGVudCA9IFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChTRUxFQ1RPUl9GSVhFRF9DT05URU5UKSlcbiAgICAkKGZpeGVkQ29udGVudCkuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IHBhZGRpbmcgPSAkKGVsZW1lbnQpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgICAgJChlbGVtZW50KS5yZW1vdmVEYXRhKCdwYWRkaW5nLXJpZ2h0JylcbiAgICAgIGVsZW1lbnQuc3R5bGUucGFkZGluZ1JpZ2h0ID0gcGFkZGluZyA/IHBhZGRpbmcgOiAnJ1xuICAgIH0pXG5cbiAgICAvLyBSZXN0b3JlIHN0aWNreSBjb250ZW50XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCR7U0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlR9YCkpXG4gICAgJChlbGVtZW50cykuZWFjaCgoaW5kZXgsIGVsZW1lbnQpID0+IHtcbiAgICAgIGNvbnN0IG1hcmdpbiA9ICQoZWxlbWVudCkuZGF0YSgnbWFyZ2luLXJpZ2h0JylcbiAgICAgIGlmICh0eXBlb2YgbWFyZ2luICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAkKGVsZW1lbnQpLmNzcygnbWFyZ2luLXJpZ2h0JywgbWFyZ2luKS5yZW1vdmVEYXRhKCdtYXJnaW4tcmlnaHQnKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBSZXN0b3JlIGJvZHkgcGFkZGluZ1xuICAgIGNvbnN0IHBhZGRpbmcgPSAkKGRvY3VtZW50LmJvZHkpLmRhdGEoJ3BhZGRpbmctcmlnaHQnKVxuICAgICQoZG9jdW1lbnQuYm9keSkucmVtb3ZlRGF0YSgncGFkZGluZy1yaWdodCcpXG4gICAgZG9jdW1lbnQuYm9keS5zdHlsZS5wYWRkaW5nUmlnaHQgPSBwYWRkaW5nID8gcGFkZGluZyA6ICcnXG4gIH1cblxuICBfZ2V0U2Nyb2xsYmFyV2lkdGgoKSB7IC8vIHRoeCBkLndhbHNoXG4gICAgY29uc3Qgc2Nyb2xsRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBzY3JvbGxEaXYuY2xhc3NOYW1lID0gQ0xBU1NfTkFNRV9TQ1JPTExCQVJfTUVBU1VSRVJcbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHNjcm9sbERpdilcbiAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHNjcm9sbERpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCAtIHNjcm9sbERpdi5jbGllbnRXaWR0aFxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2Nyb2xsRGl2KVxuICAgIHJldHVybiBzY3JvbGxiYXJXaWR0aFxuICB9XG5cbiAgLy8gU3RhdGljXG4gIHN0YXRpYyBfalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZywgcmVsYXRlZFRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgbGV0IGRhdGEgPSAkKHRoaXMpLmRhdGEoREFUQV9LRVkpXG4gICAgICBjb25zdCBfY29uZmlnID0ge1xuICAgICAgICAuLi5EZWZhdWx0LFxuICAgICAgICAuLi4kKHRoaXMpLmRhdGEoKSxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBNb2RhbCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkKHRoaXMpLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldClcbiAgICAgIH0gZWxzZSBpZiAoX2NvbmZpZy5zaG93KSB7XG4gICAgICAgIGRhdGEuc2hvdyhyZWxhdGVkVGFyZ2V0KVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbiQoZG9jdW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RBVEFfQVBJLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGxldCB0YXJnZXRcbiAgY29uc3Qgc2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQodGhpcylcblxuICBpZiAoc2VsZWN0b3IpIHtcbiAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICB9XG5cbiAgY29uc3QgY29uZmlnID0gJCh0YXJnZXQpLmRhdGEoREFUQV9LRVkpID9cbiAgICAndG9nZ2xlJyA6IHtcbiAgICAgIC4uLiQodGFyZ2V0KS5kYXRhKCksXG4gICAgICAuLi4kKHRoaXMpLmRhdGEoKVxuICAgIH1cblxuICBpZiAodGhpcy50YWdOYW1lID09PSAnQScgfHwgdGhpcy50YWdOYW1lID09PSAnQVJFQScpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gIH1cblxuICBjb25zdCAkdGFyZ2V0ID0gJCh0YXJnZXQpLm9uZShFVkVOVF9TSE9XLCBzaG93RXZlbnQgPT4ge1xuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIC8vIE9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICR0YXJnZXQub25lKEVWRU5UX0hJRERFTiwgKCkgPT4ge1xuICAgICAgaWYgKCQodGhpcykuaXMoJzp2aXNpYmxlJykpIHtcbiAgICAgICAgdGhpcy5mb2N1cygpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcblxuICBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJCh0YXJnZXQpLCBjb25maWcsIHRoaXMpXG59KVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBNb2RhbC5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gTW9kYWxcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gTW9kYWwuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBNb2RhbFxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjEpOiB0b29scy9zYW5pdGl6ZXIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5jb25zdCB1cmlBdHRycyA9IFtcbiAgJ2JhY2tncm91bmQnLFxuICAnY2l0ZScsXG4gICdocmVmJyxcbiAgJ2l0ZW10eXBlJyxcbiAgJ2xvbmdkZXNjJyxcbiAgJ3Bvc3RlcicsXG4gICdzcmMnLFxuICAneGxpbms6aHJlZidcbl1cblxuY29uc3QgQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiA9IC9eYXJpYS1bXFx3LV0qJC9pXG5cbmV4cG9ydCBjb25zdCBEZWZhdWx0V2hpdGVsaXN0ID0ge1xuICAvLyBHbG9iYWwgYXR0cmlidXRlcyBhbGxvd2VkIG9uIGFueSBzdXBwbGllZCBlbGVtZW50IGJlbG93LlxuICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICBhOiBbJ3RhcmdldCcsICdocmVmJywgJ3RpdGxlJywgJ3JlbCddLFxuICBhcmVhOiBbXSxcbiAgYjogW10sXG4gIGJyOiBbXSxcbiAgY29sOiBbXSxcbiAgY29kZTogW10sXG4gIGRpdjogW10sXG4gIGVtOiBbXSxcbiAgaHI6IFtdLFxuICBoMTogW10sXG4gIGgyOiBbXSxcbiAgaDM6IFtdLFxuICBoNDogW10sXG4gIGg1OiBbXSxcbiAgaDY6IFtdLFxuICBpOiBbXSxcbiAgaW1nOiBbJ3NyYycsICdzcmNzZXQnLCAnYWx0JywgJ3RpdGxlJywgJ3dpZHRoJywgJ2hlaWdodCddLFxuICBsaTogW10sXG4gIG9sOiBbXSxcbiAgcDogW10sXG4gIHByZTogW10sXG4gIHM6IFtdLFxuICBzbWFsbDogW10sXG4gIHNwYW46IFtdLFxuICBzdWI6IFtdLFxuICBzdXA6IFtdLFxuICBzdHJvbmc6IFtdLFxuICB1OiBbXSxcbiAgdWw6IFtdXG59XG5cbi8qKlxuICogQSBwYXR0ZXJuIHRoYXQgcmVjb2duaXplcyBhIGNvbW1vbmx5IHVzZWZ1bCBzdWJzZXQgb2YgVVJMcyB0aGF0IGFyZSBzYWZlLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBTQUZFX1VSTF9QQVRURVJOID0gL14oPzooPzpodHRwcz98bWFpbHRvfGZ0cHx0ZWx8ZmlsZXxzbXMpOnxbXiMmLzo/XSooPzpbIy8/XXwkKSkvaVxuXG4vKipcbiAqIEEgcGF0dGVybiB0aGF0IG1hdGNoZXMgc2FmZSBkYXRhIFVSTHMuIE9ubHkgbWF0Y2hlcyBpbWFnZSwgdmlkZW8gYW5kIGF1ZGlvIHR5cGVzLlxuICpcbiAqIFNob3V0b3V0IHRvIEFuZ3VsYXIgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhci9ibG9iLzEyLjIueC9wYWNrYWdlcy9jb3JlL3NyYy9zYW5pdGl6YXRpb24vdXJsX3Nhbml0aXplci50c1xuICovXG5jb25zdCBEQVRBX1VSTF9QQVRURVJOID0gL15kYXRhOig/OmltYWdlXFwvKD86Ym1wfGdpZnxqcGVnfGpwZ3xwbmd8dGlmZnx3ZWJwKXx2aWRlb1xcLyg/Om1wZWd8bXA0fG9nZ3x3ZWJtKXxhdWRpb1xcLyg/Om1wM3xvZ2F8b2dnfG9wdXMpKTtiYXNlNjQsW1xcZCsvYS16XSs9KiQvaVxuXG5mdW5jdGlvbiBhbGxvd2VkQXR0cmlidXRlKGF0dHIsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSB7XG4gIGNvbnN0IGF0dHJOYW1lID0gYXR0ci5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgaWYgKGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmluZGV4T2YoYXR0ck5hbWUpICE9PSAtMSkge1xuICAgIGlmICh1cmlBdHRycy5pbmRleE9mKGF0dHJOYW1lKSAhPT0gLTEpIHtcbiAgICAgIHJldHVybiBCb29sZWFuKFNBRkVfVVJMX1BBVFRFUk4udGVzdChhdHRyLm5vZGVWYWx1ZSkgfHwgREFUQV9VUkxfUEFUVEVSTi50ZXN0KGF0dHIubm9kZVZhbHVlKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgY29uc3QgcmVnRXhwID0gYWxsb3dlZEF0dHJpYnV0ZUxpc3QuZmlsdGVyKGF0dHJSZWdleCA9PiBhdHRyUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApXG5cbiAgLy8gQ2hlY2sgaWYgYSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVzIHRoZSBhdHRyaWJ1dGUuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSByZWdFeHAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBpZiAocmVnRXhwW2ldLnRlc3QoYXR0ck5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIHdoaXRlTGlzdCwgc2FuaXRpemVGbikge1xuICBpZiAodW5zYWZlSHRtbC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdW5zYWZlSHRtbFxuICB9XG5cbiAgaWYgKHNhbml0aXplRm4gJiYgdHlwZW9mIHNhbml0aXplRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc2FuaXRpemVGbih1bnNhZmVIdG1sKVxuICB9XG5cbiAgY29uc3QgZG9tUGFyc2VyID0gbmV3IHdpbmRvdy5ET01QYXJzZXIoKVxuICBjb25zdCBjcmVhdGVkRG9jdW1lbnQgPSBkb21QYXJzZXIucGFyc2VGcm9tU3RyaW5nKHVuc2FmZUh0bWwsICd0ZXh0L2h0bWwnKVxuICBjb25zdCB3aGl0ZWxpc3RLZXlzID0gT2JqZWN0LmtleXMod2hpdGVMaXN0KVxuICBjb25zdCBlbGVtZW50cyA9IFtdLnNsaWNlLmNhbGwoY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKVxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbGVtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGNvbnN0IGVsID0gZWxlbWVudHNbaV1cbiAgICBjb25zdCBlbE5hbWUgPSBlbC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXG5cbiAgICBpZiAod2hpdGVsaXN0S2V5cy5pbmRleE9mKGVsLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpID09PSAtMSkge1xuICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbClcblxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uc2xpY2UuY2FsbChlbC5hdHRyaWJ1dGVzKVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB1bmljb3JuL3ByZWZlci1zcHJlYWRcbiAgICBjb25zdCB3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMgPSBbXS5jb25jYXQod2hpdGVMaXN0WycqJ10gfHwgW10sIHdoaXRlTGlzdFtlbE5hbWVdIHx8IFtdKVxuXG4gICAgYXR0cmlidXRlTGlzdC5mb3JFYWNoKGF0dHIgPT4ge1xuICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHIsIHdoaXRlbGlzdGVkQXR0cmlidXRlcykpIHtcbiAgICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGF0dHIubm9kZU5hbWUpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUxcbn1cbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4xKTogdG9vbHRpcC5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCB7IERlZmF1bHRXaGl0ZWxpc3QsIHNhbml0aXplSHRtbCB9IGZyb20gJy4vdG9vbHMvc2FuaXRpemVyJ1xuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFBvcHBlciBmcm9tICdwb3BwZXIuanMnXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSA9ICd0b29sdGlwJ1xuY29uc3QgVkVSU0lPTiA9ICc0LjYuMSdcbmNvbnN0IERBVEFfS0VZID0gJ2JzLnRvb2x0aXAnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuY29uc3QgQ0xBU1NfUFJFRklYID0gJ2JzLXRvb2x0aXAnXG5jb25zdCBCU0NMU19QUkVGSVhfUkVHRVggPSBuZXcgUmVnRXhwKGAoXnxcXFxccykke0NMQVNTX1BSRUZJWH1cXFxcUytgLCAnZycpXG5jb25zdCBESVNBTExPV0VEX0FUVFJJQlVURVMgPSBbJ3Nhbml0aXplJywgJ3doaXRlTGlzdCcsICdzYW5pdGl6ZUZuJ11cblxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcblxuY29uc3QgSE9WRVJfU1RBVEVfU0hPVyA9ICdzaG93J1xuY29uc3QgSE9WRVJfU1RBVEVfT1VUID0gJ291dCdcblxuY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcidcbmNvbnN0IFNFTEVDVE9SX0FSUk9XID0gJy5hcnJvdydcblxuY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3ZlcidcbmNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnXG5jb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJ1xuY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJ1xuXG5jb25zdCBBdHRhY2htZW50TWFwID0ge1xuICBBVVRPOiAnYXV0bycsXG4gIFRPUDogJ3RvcCcsXG4gIFJJR0hUOiAncmlnaHQnLFxuICBCT1RUT006ICdib3R0b20nLFxuICBMRUZUOiAnbGVmdCdcbn1cblxuY29uc3QgRGVmYXVsdCA9IHtcbiAgYW5pbWF0aW9uOiB0cnVlLFxuICB0ZW1wbGF0ZTogJzxkaXYgY2xhc3M9XCJ0b29sdGlwXCIgcm9sZT1cInRvb2x0aXBcIj4nICtcbiAgICAgICAgICAgICAgICAgICAgJzxkaXYgY2xhc3M9XCJhcnJvd1wiPjwvZGl2PicgK1xuICAgICAgICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj48L2Rpdj4nLFxuICB0cmlnZ2VyOiAnaG92ZXIgZm9jdXMnLFxuICB0aXRsZTogJycsXG4gIGRlbGF5OiAwLFxuICBodG1sOiBmYWxzZSxcbiAgc2VsZWN0b3I6IGZhbHNlLFxuICBwbGFjZW1lbnQ6ICd0b3AnLFxuICBvZmZzZXQ6IDAsXG4gIGNvbnRhaW5lcjogZmFsc2UsXG4gIGZhbGxiYWNrUGxhY2VtZW50OiAnZmxpcCcsXG4gIGJvdW5kYXJ5OiAnc2Nyb2xsUGFyZW50JyxcbiAgY3VzdG9tQ2xhc3M6ICcnLFxuICBzYW5pdGl6ZTogdHJ1ZSxcbiAgc2FuaXRpemVGbjogbnVsbCxcbiAgd2hpdGVMaXN0OiBEZWZhdWx0V2hpdGVsaXN0LFxuICBwb3BwZXJDb25maWc6IG51bGxcbn1cblxuY29uc3QgRGVmYXVsdFR5cGUgPSB7XG4gIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gIHRpdGxlOiAnKHN0cmluZ3xlbGVtZW50fGZ1bmN0aW9uKScsXG4gIHRyaWdnZXI6ICdzdHJpbmcnLFxuICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gIGh0bWw6ICdib29sZWFuJyxcbiAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICBvZmZzZXQ6ICcobnVtYmVyfHN0cmluZ3xmdW5jdGlvbiknLFxuICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxuICBmYWxsYmFja1BsYWNlbWVudDogJyhzdHJpbmd8YXJyYXkpJyxcbiAgYm91bmRhcnk6ICcoc3RyaW5nfGVsZW1lbnQpJyxcbiAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXG4gIHNhbml0aXplOiAnYm9vbGVhbicsXG4gIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICB3aGl0ZUxpc3Q6ICdvYmplY3QnLFxuICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3QpJ1xufVxuXG5jb25zdCBFdmVudCA9IHtcbiAgSElERTogYGhpZGUke0VWRU5UX0tFWX1gLFxuICBISURERU46IGBoaWRkZW4ke0VWRU5UX0tFWX1gLFxuICBTSE9XOiBgc2hvdyR7RVZFTlRfS0VZfWAsXG4gIFNIT1dOOiBgc2hvd24ke0VWRU5UX0tFWX1gLFxuICBJTlNFUlRFRDogYGluc2VydGVkJHtFVkVOVF9LRVl9YCxcbiAgQ0xJQ0s6IGBjbGljayR7RVZFTlRfS0VZfWAsXG4gIEZPQ1VTSU46IGBmb2N1c2luJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNPVVQ6IGBmb2N1c291dCR7RVZFTlRfS0VZfWAsXG4gIE1PVVNFRU5URVI6IGBtb3VzZWVudGVyJHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VMRUFWRTogYG1vdXNlbGVhdmUke0VWRU5UX0tFWX1gXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvb2x0aXAge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgdG9vbHRpcHMgcmVxdWlyZSBQb3BwZXIgKGh0dHBzOi8vcG9wcGVyLmpzLm9yZyknKVxuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlXG4gICAgdGhpcy5fdGltZW91dCA9IDBcbiAgICB0aGlzLl9ob3ZlclN0YXRlID0gJydcbiAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyID0ge31cbiAgICB0aGlzLl9wb3BwZXIgPSBudWxsXG5cbiAgICAvLyBQcm90ZWN0ZWRcbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50XG4gICAgdGhpcy5jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMudGlwID0gbnVsbFxuXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgcmV0dXJuIERlZmF1bHRcbiAgfVxuXG4gIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICByZXR1cm4gTkFNRVxuICB9XG5cbiAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcbiAgICByZXR1cm4gREFUQV9LRVlcbiAgfVxuXG4gIHN0YXRpYyBnZXQgRXZlbnQoKSB7XG4gICAgcmV0dXJuIEV2ZW50XG4gIH1cblxuICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICByZXR1cm4gRVZFTlRfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgLy8gUHVibGljXG4gIGVuYWJsZSgpIHtcbiAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlXG4gIH1cblxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9IGZhbHNlXG4gIH1cblxuICB0b2dnbGVFbmFibGVkKCkge1xuICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWRcbiAgfVxuXG4gIHRvZ2dsZShldmVudCkge1xuICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQpIHtcbiAgICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgICBsZXQgY29udGV4dCA9ICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5KVxuXG4gICAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgICAgY29udGV4dCA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKFxuICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQsXG4gICAgICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICAgICApXG4gICAgICAgICQoZXZlbnQuY3VycmVudFRhcmdldCkuZGF0YShkYXRhS2V5LCBjb250ZXh0KVxuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIWNvbnRleHQuX2FjdGl2ZVRyaWdnZXIuY2xpY2tcblxuICAgICAgaWYgKGNvbnRleHQuX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSkge1xuICAgICAgICBjb250ZXh0Ll9lbnRlcihudWxsLCBjb250ZXh0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5fbGVhdmUobnVsbCwgY29udGV4dClcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmhhc0NsYXNzKENMQVNTX05BTUVfU0hPVykpIHtcbiAgICAgICAgdGhpcy5fbGVhdmUobnVsbCwgdGhpcylcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2VudGVyKG51bGwsIHRoaXMpXG4gICAgfVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dClcblxuICAgICQucmVtb3ZlRGF0YSh0aGlzLmVsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpXG5cbiAgICAkKHRoaXMuZWxlbWVudCkub2ZmKHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKVxuICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vZmYoJ2hpZGUuYnMubW9kYWwnLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKVxuXG4gICAgaWYgKHRoaXMudGlwKSB7XG4gICAgICAkKHRoaXMudGlwKS5yZW1vdmUoKVxuICAgIH1cblxuICAgIHRoaXMuX2lzRW5hYmxlZCA9IG51bGxcbiAgICB0aGlzLl90aW1lb3V0ID0gbnVsbFxuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IG51bGxcbiAgICBpZiAodGhpcy5fcG9wcGVyKSB7XG4gICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpXG4gICAgfVxuXG4gICAgdGhpcy5fcG9wcGVyID0gbnVsbFxuICAgIHRoaXMuZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLmNvbmZpZyA9IG51bGxcbiAgICB0aGlzLnRpcCA9IG51bGxcbiAgfVxuXG4gIHNob3coKSB7XG4gICAgaWYgKCQodGhpcy5lbGVtZW50KS5jc3MoJ2Rpc3BsYXknKSA9PT0gJ25vbmUnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSB1c2Ugc2hvdyBvbiB2aXNpYmxlIGVsZW1lbnRzJylcbiAgICB9XG5cbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPVylcbiAgICBpZiAodGhpcy5pc1dpdGhDb250ZW50KCkgJiYgdGhpcy5faXNFbmFibGVkKSB7XG4gICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBVdGlsLmZpbmRTaGFkb3dSb290KHRoaXMuZWxlbWVudClcbiAgICAgIGNvbnN0IGlzSW5UaGVEb20gPSAkLmNvbnRhaW5zKFxuICAgICAgICBzaGFkb3dSb290ICE9PSBudWxsID8gc2hhZG93Um9vdCA6IHRoaXMuZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcbiAgICAgICAgdGhpcy5lbGVtZW50XG4gICAgICApXG5cbiAgICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgICBjb25zdCB0aXBJZCA9IFV0aWwuZ2V0VUlEKHRoaXMuY29uc3RydWN0b3IuTkFNRSlcblxuICAgICAgdGlwLnNldEF0dHJpYnV0ZSgnaWQnLCB0aXBJZClcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknLCB0aXBJZClcblxuICAgICAgdGhpcy5zZXRDb250ZW50KClcblxuICAgICAgaWYgKHRoaXMuY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgICAkKHRpcCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9GQURFKVxuICAgICAgfVxuXG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSB0eXBlb2YgdGhpcy5jb25maWcucGxhY2VtZW50ID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5jb25maWcucGxhY2VtZW50LmNhbGwodGhpcywgdGlwLCB0aGlzLmVsZW1lbnQpIDpcbiAgICAgICAgdGhpcy5jb25maWcucGxhY2VtZW50XG5cbiAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSB0aGlzLl9nZXRBdHRhY2htZW50KHBsYWNlbWVudClcbiAgICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpXG5cbiAgICAgIGNvbnN0IGNvbnRhaW5lciA9IHRoaXMuX2dldENvbnRhaW5lcigpXG4gICAgICAkKHRpcCkuZGF0YSh0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKVxuXG4gICAgICBpZiAoISQuY29udGFpbnModGhpcy5lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LCB0aGlzLnRpcCkpIHtcbiAgICAgICAgJCh0aXApLmFwcGVuZFRvKGNvbnRhaW5lcilcbiAgICAgIH1cblxuICAgICAgJCh0aGlzLmVsZW1lbnQpLnRyaWdnZXIodGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5JTlNFUlRFRClcblxuICAgICAgdGhpcy5fcG9wcGVyID0gbmV3IFBvcHBlcih0aGlzLmVsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKVxuXG4gICAgICAkKHRpcCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgJCh0aXApLmFkZENsYXNzKHRoaXMuY29uZmlnLmN1c3RvbUNsYXNzKVxuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICAkKGRvY3VtZW50LmJvZHkpLmNoaWxkcmVuKCkub24oJ21vdXNlb3ZlcicsIG51bGwsICQubm9vcClcbiAgICAgIH1cblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgICB0aGlzLl9maXhUcmFuc2l0aW9uKClcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHByZXZIb3ZlclN0YXRlID0gdGhpcy5faG92ZXJTdGF0ZVxuICAgICAgICB0aGlzLl9ob3ZlclN0YXRlID0gbnVsbFxuXG4gICAgICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKHRoaXMuY29uc3RydWN0b3IuRXZlbnQuU0hPV04pXG5cbiAgICAgICAgaWYgKHByZXZIb3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcbiAgICAgICAgICB0aGlzLl9sZWF2ZShudWxsLCB0aGlzKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgkKHRoaXMudGlwKS5oYXNDbGFzcyhDTEFTU19OQU1FX0ZBREUpKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGhpcy50aXApXG5cbiAgICAgICAgJCh0aGlzLnRpcClcbiAgICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21wbGV0ZSgpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGlkZShjYWxsYmFjaykge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudCh0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJREUpXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5faG92ZXJTdGF0ZSAhPT0gSE9WRVJfU1RBVEVfU0hPVyAmJiB0aXAucGFyZW50Tm9kZSkge1xuICAgICAgICB0aXAucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aXApXG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKVxuICAgICAgdGhpcy5lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScpXG4gICAgICAkKHRoaXMuZWxlbWVudCkudHJpZ2dlcih0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkhJRERFTilcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKVxuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudClcblxuICAgIGlmIChoaWRlRXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhDTEFTU19OQU1FX1NIT1cpXG5cbiAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XG4gICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgJChkb2N1bWVudC5ib2R5KS5jaGlsZHJlbigpLm9mZignbW91c2VvdmVyJywgbnVsbCwgJC5ub29wKVxuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10gPSBmYWxzZVxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9GT0NVU10gPSBmYWxzZVxuICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZVxuXG4gICAgaWYgKCQodGhpcy50aXApLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpIHtcbiAgICAgIGNvbnN0IHRyYW5zaXRpb25EdXJhdGlvbiA9IFV0aWwuZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodGlwKVxuXG4gICAgICAkKHRpcClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cblxuICAgIHRoaXMuX2hvdmVyU3RhdGUgPSAnJ1xuICB9XG5cbiAgdXBkYXRlKCkge1xuICAgIGlmICh0aGlzLl9wb3BwZXIgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX3BvcHBlci5zY2hlZHVsZVVwZGF0ZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gUHJvdGVjdGVkXG4gIGlzV2l0aENvbnRlbnQoKSB7XG4gICAgcmV0dXJuIEJvb2xlYW4odGhpcy5nZXRUaXRsZSgpKVxuICB9XG5cbiAgYWRkQXR0YWNobWVudENsYXNzKGF0dGFjaG1lbnQpIHtcbiAgICAkKHRoaXMuZ2V0VGlwRWxlbWVudCgpKS5hZGRDbGFzcyhgJHtDTEFTU19QUkVGSVh9LSR7YXR0YWNobWVudH1gKVxuICB9XG5cbiAgZ2V0VGlwRWxlbWVudCgpIHtcbiAgICB0aGlzLnRpcCA9IHRoaXMudGlwIHx8ICQodGhpcy5jb25maWcudGVtcGxhdGUpWzBdXG4gICAgcmV0dXJuIHRoaXMudGlwXG4gIH1cblxuICBzZXRDb250ZW50KCkge1xuICAgIGNvbnN0IHRpcCA9IHRoaXMuZ2V0VGlwRWxlbWVudCgpXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkKHRpcC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIpKSwgdGhpcy5nZXRUaXRsZSgpKVxuICAgICQodGlwKS5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0ZBREV9ICR7Q0xBU1NfTkFNRV9TSE9XfWApXG4gIH1cblxuICBzZXRFbGVtZW50Q29udGVudCgkZWxlbWVudCwgY29udGVudCkge1xuICAgIGlmICh0eXBlb2YgY29udGVudCA9PT0gJ29iamVjdCcgJiYgKGNvbnRlbnQubm9kZVR5cGUgfHwgY29udGVudC5qcXVlcnkpKSB7XG4gICAgICAvLyBDb250ZW50IGlzIGEgRE9NIG5vZGUgb3IgYSBqUXVlcnlcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5odG1sKSB7XG4gICAgICAgIGlmICghJChjb250ZW50KS5wYXJlbnQoKS5pcygkZWxlbWVudCkpIHtcbiAgICAgICAgICAkZWxlbWVudC5lbXB0eSgpLmFwcGVuZChjb250ZW50KVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAkZWxlbWVudC50ZXh0KCQoY29udGVudCkudGV4dCgpKVxuICAgICAgfVxuXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy5jb25maWcuaHRtbCkge1xuICAgICAgaWYgKHRoaXMuY29uZmlnLnNhbml0aXplKSB7XG4gICAgICAgIGNvbnRlbnQgPSBzYW5pdGl6ZUh0bWwoY29udGVudCwgdGhpcy5jb25maWcud2hpdGVMaXN0LCB0aGlzLmNvbmZpZy5zYW5pdGl6ZUZuKVxuICAgICAgfVxuXG4gICAgICAkZWxlbWVudC5odG1sKGNvbnRlbnQpXG4gICAgfSBlbHNlIHtcbiAgICAgICRlbGVtZW50LnRleHQoY29udGVudClcbiAgICB9XG4gIH1cblxuICBnZXRUaXRsZSgpIHtcbiAgICBsZXQgdGl0bGUgPSB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICghdGl0bGUpIHtcbiAgICAgIHRpdGxlID0gdHlwZW9mIHRoaXMuY29uZmlnLnRpdGxlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgdGhpcy5jb25maWcudGl0bGUuY2FsbCh0aGlzLmVsZW1lbnQpIDpcbiAgICAgICAgdGhpcy5jb25maWcudGl0bGVcbiAgICB9XG5cbiAgICByZXR1cm4gdGl0bGVcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XG4gICAgY29uc3QgZGVmYXVsdEJzQ29uZmlnID0ge1xuICAgICAgcGxhY2VtZW50OiBhdHRhY2htZW50LFxuICAgICAgbW9kaWZpZXJzOiB7XG4gICAgICAgIG9mZnNldDogdGhpcy5fZ2V0T2Zmc2V0KCksXG4gICAgICAgIGZsaXA6IHtcbiAgICAgICAgICBiZWhhdmlvcjogdGhpcy5jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRcbiAgICAgICAgfSxcbiAgICAgICAgYXJyb3c6IHtcbiAgICAgICAgICBlbGVtZW50OiBTRUxFQ1RPUl9BUlJPV1xuICAgICAgICB9LFxuICAgICAgICBwcmV2ZW50T3ZlcmZsb3c6IHtcbiAgICAgICAgICBib3VuZGFyaWVzRWxlbWVudDogdGhpcy5jb25maWcuYm91bmRhcnlcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9uQ3JlYXRlOiBkYXRhID0+IHtcbiAgICAgICAgaWYgKGRhdGEub3JpZ2luYWxQbGFjZW1lbnQgIT09IGRhdGEucGxhY2VtZW50KSB7XG4gICAgICAgICAgdGhpcy5faGFuZGxlUG9wcGVyUGxhY2VtZW50Q2hhbmdlKGRhdGEpXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvblVwZGF0ZTogZGF0YSA9PiB0aGlzLl9oYW5kbGVQb3BwZXJQbGFjZW1lbnRDaGFuZ2UoZGF0YSlcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgLi4uZGVmYXVsdEJzQ29uZmlnLFxuICAgICAgLi4udGhpcy5jb25maWcucG9wcGVyQ29uZmlnXG4gICAgfVxuICB9XG5cbiAgX2dldE9mZnNldCgpIHtcbiAgICBjb25zdCBvZmZzZXQgPSB7fVxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNvbmZpZy5vZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9mZnNldC5mbiA9IGRhdGEgPT4ge1xuICAgICAgICBkYXRhLm9mZnNldHMgPSB7XG4gICAgICAgICAgLi4uZGF0YS5vZmZzZXRzLFxuICAgICAgICAgIC4uLnRoaXMuY29uZmlnLm9mZnNldChkYXRhLm9mZnNldHMsIHRoaXMuZWxlbWVudClcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldC5vZmZzZXQgPSB0aGlzLmNvbmZpZy5vZmZzZXRcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0XG4gIH1cblxuICBfZ2V0Q29udGFpbmVyKCkge1xuICAgIGlmICh0aGlzLmNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuYm9keVxuICAgIH1cblxuICAgIGlmIChVdGlsLmlzRWxlbWVudCh0aGlzLmNvbmZpZy5jb250YWluZXIpKSB7XG4gICAgICByZXR1cm4gJCh0aGlzLmNvbmZpZy5jb250YWluZXIpXG4gICAgfVxuXG4gICAgcmV0dXJuICQoZG9jdW1lbnQpLmZpbmQodGhpcy5jb25maWcuY29udGFpbmVyKVxuICB9XG5cbiAgX2dldEF0dGFjaG1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldXG4gIH1cblxuICBfc2V0TGlzdGVuZXJzKCkge1xuICAgIGNvbnN0IHRyaWdnZXJzID0gdGhpcy5jb25maWcudHJpZ2dlci5zcGxpdCgnICcpXG5cbiAgICB0cmlnZ2Vycy5mb3JFYWNoKHRyaWdnZXIgPT4ge1xuICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpLm9uKFxuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuQ0xJQ0ssXG4gICAgICAgICAgdGhpcy5jb25maWcuc2VsZWN0b3IsXG4gICAgICAgICAgZXZlbnQgPT4gdGhpcy50b2dnbGUoZXZlbnQpXG4gICAgICAgIClcbiAgICAgIH0gZWxzZSBpZiAodHJpZ2dlciAhPT0gVFJJR0dFUl9NQU5VQUwpIHtcbiAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgP1xuICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IuRXZlbnQuTU9VU0VFTlRFUiA6XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5GT0NVU0lOXG4gICAgICAgIGNvbnN0IGV2ZW50T3V0ID0gdHJpZ2dlciA9PT0gVFJJR0dFUl9IT1ZFUiA/XG4gICAgICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5FdmVudC5NT1VTRUxFQVZFIDpcbiAgICAgICAgICB0aGlzLmNvbnN0cnVjdG9yLkV2ZW50LkZPQ1VTT1VUXG5cbiAgICAgICAgJCh0aGlzLmVsZW1lbnQpXG4gICAgICAgICAgLm9uKGV2ZW50SW4sIHRoaXMuY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB0aGlzLl9lbnRlcihldmVudCkpXG4gICAgICAgICAgLm9uKGV2ZW50T3V0LCB0aGlzLmNvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4gdGhpcy5fbGVhdmUoZXZlbnQpKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICB0aGlzLmhpZGUoKVxuICAgICAgfVxuICAgIH1cblxuICAgICQodGhpcy5lbGVtZW50KS5jbG9zZXN0KCcubW9kYWwnKS5vbignaGlkZS5icy5tb2RhbCcsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpXG5cbiAgICBpZiAodGhpcy5jb25maWcuc2VsZWN0b3IpIHtcbiAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAuLi50aGlzLmNvbmZpZyxcbiAgICAgICAgdHJpZ2dlcjogJ21hbnVhbCcsXG4gICAgICAgIHNlbGVjdG9yOiAnJ1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9maXhUaXRsZSgpXG4gICAgfVxuICB9XG5cbiAgX2ZpeFRpdGxlKCkge1xuICAgIGNvbnN0IHRpdGxlVHlwZSA9IHR5cGVvZiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJylcblxuICAgIGlmICh0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IHRpdGxlVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMuZWxlbWVudC5zZXRBdHRyaWJ1dGUoXG4gICAgICAgICdkYXRhLW9yaWdpbmFsLXRpdGxlJyxcbiAgICAgICAgdGhpcy5lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKSB8fCAnJ1xuICAgICAgKVxuXG4gICAgICB0aGlzLmVsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsICcnKVxuICAgIH1cbiAgfVxuXG4gIF9lbnRlcihldmVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpXG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICAgKVxuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW1xuICAgICAgICBldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUlxuICAgICAgXSA9IHRydWVcbiAgICB9XG5cbiAgICBpZiAoJChjb250ZXh0LmdldFRpcEVsZW1lbnQoKSkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKSB8fCBjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9TSE9XKSB7XG4gICAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfU0hPV1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY2xlYXJUaW1lb3V0KGNvbnRleHQuX3RpbWVvdXQpXG5cbiAgICBjb250ZXh0Ll9ob3ZlclN0YXRlID0gSE9WRVJfU1RBVEVfU0hPV1xuXG4gICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuc2hvdykge1xuICAgICAgY29udGV4dC5zaG93KClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9TSE9XKSB7XG4gICAgICAgIGNvbnRleHQuc2hvdygpXG4gICAgICB9XG4gICAgfSwgY29udGV4dC5jb25maWcuZGVsYXkuc2hvdylcbiAgfVxuXG4gIF9sZWF2ZShldmVudCwgY29udGV4dCkge1xuICAgIGNvbnN0IGRhdGFLZXkgPSB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZXG4gICAgY29udGV4dCA9IGNvbnRleHQgfHwgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXkpXG5cbiAgICBpZiAoIWNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQgPSBuZXcgdGhpcy5jb25zdHJ1Y3RvcihcbiAgICAgICAgZXZlbnQuY3VycmVudFRhcmdldCxcbiAgICAgICAgdGhpcy5fZ2V0RGVsZWdhdGVDb25maWcoKVxuICAgICAgKVxuICAgICAgJChldmVudC5jdXJyZW50VGFyZ2V0KS5kYXRhKGRhdGFLZXksIGNvbnRleHQpXG4gICAgfVxuXG4gICAgaWYgKGV2ZW50KSB7XG4gICAgICBjb250ZXh0Ll9hY3RpdmVUcmlnZ2VyW1xuICAgICAgICBldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJcbiAgICAgIF0gPSBmYWxzZVxuICAgIH1cblxuICAgIGlmIChjb250ZXh0Ll9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNsZWFyVGltZW91dChjb250ZXh0Ll90aW1lb3V0KVxuXG4gICAgY29udGV4dC5faG92ZXJTdGF0ZSA9IEhPVkVSX1NUQVRFX09VVFxuXG4gICAgaWYgKCFjb250ZXh0LmNvbmZpZy5kZWxheSB8fCAhY29udGV4dC5jb25maWcuZGVsYXkuaGlkZSkge1xuICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGNvbnRleHQuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmIChjb250ZXh0Ll9ob3ZlclN0YXRlID09PSBIT1ZFUl9TVEFURV9PVVQpIHtcbiAgICAgICAgY29udGV4dC5oaWRlKClcbiAgICAgIH1cbiAgICB9LCBjb250ZXh0LmNvbmZpZy5kZWxheS5oaWRlKVxuICB9XG5cbiAgX2lzV2l0aEFjdGl2ZVRyaWdnZXIoKSB7XG4gICAgZm9yIChjb25zdCB0cmlnZ2VyIGluIHRoaXMuX2FjdGl2ZVRyaWdnZXIpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUcmlnZ2VyW3RyaWdnZXJdKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbnN0IGRhdGFBdHRyaWJ1dGVzID0gJCh0aGlzLmVsZW1lbnQpLmRhdGEoKVxuXG4gICAgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpXG4gICAgICAuZm9yRWFjaChkYXRhQXR0ciA9PiB7XG4gICAgICAgIGlmIChESVNBTExPV0VEX0FUVFJJQlVURVMuaW5kZXhPZihkYXRhQXR0cikgIT09IC0xKSB7XG4gICAgICAgICAgZGVsZXRlIGRhdGFBdHRyaWJ1dGVzW2RhdGFBdHRyXVxuICAgICAgICB9XG4gICAgICB9KVxuXG4gICAgY29uZmlnID0ge1xuICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgLi4uZGF0YUF0dHJpYnV0ZXMsXG4gICAgICAuLi4odHlwZW9mIGNvbmZpZyA9PT0gJ29iamVjdCcgJiYgY29uZmlnID8gY29uZmlnIDoge30pXG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuZGVsYXkgPSB7XG4gICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb25maWcudGl0bGUgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb25maWcuY29udGVudCA9IGNvbmZpZy5jb250ZW50LnRvU3RyaW5nKClcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgIE5BTUUsXG4gICAgICBjb25maWcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgKVxuXG4gICAgaWYgKGNvbmZpZy5zYW5pdGl6ZSkge1xuICAgICAgY29uZmlnLnRlbXBsYXRlID0gc2FuaXRpemVIdG1sKGNvbmZpZy50ZW1wbGF0ZSwgY29uZmlnLndoaXRlTGlzdCwgY29uZmlnLnNhbml0aXplRm4pXG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xuICAgIGNvbnN0IGNvbmZpZyA9IHt9XG5cbiAgICBpZiAodGhpcy5jb25maWcpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdGhpcy5jb25maWdba2V5XSkge1xuICAgICAgICAgIGNvbmZpZ1trZXldID0gdGhpcy5jb25maWdba2V5XVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGgpIHtcbiAgICAgICR0aXAucmVtb3ZlQ2xhc3ModGFiQ2xhc3Muam9pbignJykpXG4gICAgfVxuICB9XG5cbiAgX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZShwb3BwZXJEYXRhKSB7XG4gICAgdGhpcy50aXAgPSBwb3BwZXJEYXRhLmluc3RhbmNlLnBvcHBlclxuICAgIHRoaXMuX2NsZWFuVGlwQ2xhc3MoKVxuICAgIHRoaXMuYWRkQXR0YWNobWVudENsYXNzKHRoaXMuX2dldEF0dGFjaG1lbnQocG9wcGVyRGF0YS5wbGFjZW1lbnQpKVxuICB9XG5cbiAgX2ZpeFRyYW5zaXRpb24oKSB7XG4gICAgY29uc3QgdGlwID0gdGhpcy5nZXRUaXBFbGVtZW50KClcbiAgICBjb25zdCBpbml0Q29uZmlnQW5pbWF0aW9uID0gdGhpcy5jb25maWcuYW5pbWF0aW9uXG5cbiAgICBpZiAodGlwLmdldEF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgJCh0aXApLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfRkFERSlcbiAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBmYWxzZVxuICAgIHRoaXMuaGlkZSgpXG4gICAgdGhpcy5zaG93KClcbiAgICB0aGlzLmNvbmZpZy5hbmltYXRpb24gPSBpbml0Q29uZmlnQW5pbWF0aW9uXG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCAkZWxlbWVudCA9ICQodGhpcylcbiAgICAgIGxldCBkYXRhID0gJGVsZW1lbnQuZGF0YShEQVRBX0tFWSlcbiAgICAgIGNvbnN0IF9jb25maWcgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWdcblxuICAgICAgaWYgKCFkYXRhICYmIC9kaXNwb3NlfGhpZGUvLnRlc3QoY29uZmlnKSkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVG9vbHRpcCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuJC5mbltOQU1FXSA9IFRvb2x0aXAuX2pRdWVyeUludGVyZmFjZVxuJC5mbltOQU1FXS5Db25zdHJ1Y3RvciA9IFRvb2x0aXBcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gVG9vbHRpcC5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRvb2x0aXBcbiIsIi8qKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIEJvb3RzdHJhcCAodjQuNi4xKTogcG9wb3Zlci5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBUb29sdGlwIGZyb20gJy4vdG9vbHRpcCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ3BvcG92ZXInXG5jb25zdCBWRVJTSU9OID0gJzQuNi4xJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMucG9wb3ZlcidcbmNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5jb25zdCBDTEFTU19QUkVGSVggPSAnYnMtcG9wb3ZlcidcbmNvbnN0IEJTQ0xTX1BSRUZJWF9SRUdFWCA9IG5ldyBSZWdFeHAoYChefFxcXFxzKSR7Q0xBU1NfUFJFRklYfVxcXFxTK2AsICdnJylcblxuY29uc3QgQ0xBU1NfTkFNRV9GQURFID0gJ2ZhZGUnXG5jb25zdCBDTEFTU19OQU1FX1NIT1cgPSAnc2hvdydcblxuY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJ1xuY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5J1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICAuLi5Ub29sdGlwLkRlZmF1bHQsXG4gIHBsYWNlbWVudDogJ3JpZ2h0JyxcbiAgdHJpZ2dlcjogJ2NsaWNrJyxcbiAgY29udGVudDogJycsXG4gIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgK1xuICAgICAgICAgICAgICAnPGRpdiBjbGFzcz1cImFycm93XCI+PC9kaXY+JyArXG4gICAgICAgICAgICAgICc8aDMgY2xhc3M9XCJwb3BvdmVyLWhlYWRlclwiPjwvaDM+JyArXG4gICAgICAgICAgICAgICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1ib2R5XCI+PC9kaXY+PC9kaXY+J1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgY29udGVudDogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXG59XG5cbmNvbnN0IEV2ZW50ID0ge1xuICBISURFOiBgaGlkZSR7RVZFTlRfS0VZfWAsXG4gIEhJRERFTjogYGhpZGRlbiR7RVZFTlRfS0VZfWAsXG4gIFNIT1c6IGBzaG93JHtFVkVOVF9LRVl9YCxcbiAgU0hPV046IGBzaG93biR7RVZFTlRfS0VZfWAsXG4gIElOU0VSVEVEOiBgaW5zZXJ0ZWQke0VWRU5UX0tFWX1gLFxuICBDTElDSzogYGNsaWNrJHtFVkVOVF9LRVl9YCxcbiAgRk9DVVNJTjogYGZvY3VzaW4ke0VWRU5UX0tFWX1gLFxuICBGT0NVU09VVDogYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YCxcbiAgTU9VU0VFTlRFUjogYG1vdXNlZW50ZXIke0VWRU5UX0tFWX1gLFxuICBNT1VTRUxFQVZFOiBgbW91c2VsZWF2ZSR7RVZFTlRfS0VZfWBcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgUG9wb3ZlciBleHRlbmRzIFRvb2x0aXAge1xuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgcmV0dXJuIE5BTUVcbiAgfVxuXG4gIHN0YXRpYyBnZXQgREFUQV9LRVkoKSB7XG4gICAgcmV0dXJuIERBVEFfS0VZXG4gIH1cblxuICBzdGF0aWMgZ2V0IEV2ZW50KCkge1xuICAgIHJldHVybiBFdmVudFxuICB9XG5cbiAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XG4gICAgcmV0dXJuIEVWRU5UX0tFWVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICByZXR1cm4gRGVmYXVsdFR5cGVcbiAgfVxuXG4gIC8vIE92ZXJyaWRlc1xuICBpc1dpdGhDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmdldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpXG4gIH1cblxuICBhZGRBdHRhY2htZW50Q2xhc3MoYXR0YWNobWVudCkge1xuICAgICQodGhpcy5nZXRUaXBFbGVtZW50KCkpLmFkZENsYXNzKGAke0NMQVNTX1BSRUZJWH0tJHthdHRhY2htZW50fWApXG4gIH1cblxuICBnZXRUaXBFbGVtZW50KCkge1xuICAgIHRoaXMudGlwID0gdGhpcy50aXAgfHwgJCh0aGlzLmNvbmZpZy50ZW1wbGF0ZSlbMF1cbiAgICByZXR1cm4gdGhpcy50aXBcbiAgfVxuXG4gIHNldENvbnRlbnQoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG5cbiAgICAvLyBXZSB1c2UgYXBwZW5kIGZvciBodG1sIG9iamVjdHMgdG8gbWFpbnRhaW4ganMgZXZlbnRzXG4gICAgdGhpcy5zZXRFbGVtZW50Q29udGVudCgkdGlwLmZpbmQoU0VMRUNUT1JfVElUTEUpLCB0aGlzLmdldFRpdGxlKCkpXG4gICAgbGV0IGNvbnRlbnQgPSB0aGlzLl9nZXRDb250ZW50KClcbiAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbnRlbnQgPSBjb250ZW50LmNhbGwodGhpcy5lbGVtZW50KVxuICAgIH1cblxuICAgIHRoaXMuc2V0RWxlbWVudENvbnRlbnQoJHRpcC5maW5kKFNFTEVDVE9SX0NPTlRFTlQpLCBjb250ZW50KVxuXG4gICAgJHRpcC5yZW1vdmVDbGFzcyhgJHtDTEFTU19OQU1FX0ZBREV9ICR7Q0xBU1NfTkFNRV9TSE9XfWApXG4gIH1cblxuICAvLyBQcml2YXRlXG4gIF9nZXRDb250ZW50KCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWNvbnRlbnQnKSB8fFxuICAgICAgdGhpcy5jb25maWcuY29udGVudFxuICB9XG5cbiAgX2NsZWFuVGlwQ2xhc3MoKSB7XG4gICAgY29uc3QgJHRpcCA9ICQodGhpcy5nZXRUaXBFbGVtZW50KCkpXG4gICAgY29uc3QgdGFiQ2xhc3MgPSAkdGlwLmF0dHIoJ2NsYXNzJykubWF0Y2goQlNDTFNfUFJFRklYX1JFR0VYKVxuICAgIGlmICh0YWJDbGFzcyAhPT0gbnVsbCAmJiB0YWJDbGFzcy5sZW5ndGggPiAwKSB7XG4gICAgICAkdGlwLnJlbW92ZUNsYXNzKHRhYkNsYXNzLmpvaW4oJycpKVxuICAgIH1cbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbFxuXG4gICAgICBpZiAoIWRhdGEgJiYgL2Rpc3Bvc2V8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBQb3BvdmVyKHRoaXMsIF9jb25maWcpXG4gICAgICAgICQodGhpcykuZGF0YShEQVRBX0tFWSwgZGF0YSlcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYClcbiAgICAgICAgfVxuXG4gICAgICAgIGRhdGFbY29uZmlnXSgpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBQb3BvdmVyLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBQb3BvdmVyXG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFBvcG92ZXIuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBQb3BvdmVyXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IHNjcm9sbHNweS5qc1xuICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICovXG5cbmltcG9ydCAkIGZyb20gJ2pxdWVyeSdcbmltcG9ydCBVdGlsIGZyb20gJy4vdXRpbCdcblxuLyoqXG4gKiBDb25zdGFudHNcbiAqL1xuXG5jb25zdCBOQU1FID0gJ3Njcm9sbHNweSdcbmNvbnN0IFZFUlNJT04gPSAnNC42LjEnXG5jb25zdCBEQVRBX0tFWSA9ICdicy5zY3JvbGxzcHknXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSdcbmNvbnN0IEpRVUVSWV9OT19DT05GTElDVCA9ICQuZm5bTkFNRV1cblxuY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNID0gJ2Ryb3Bkb3duLWl0ZW0nXG5jb25zdCBDTEFTU19OQU1FX0FDVElWRSA9ICdhY3RpdmUnXG5cbmNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfU0NST0xMID0gYHNjcm9sbCR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZfSR7REFUQV9BUElfS0VZfWBcblxuY29uc3QgTUVUSE9EX09GRlNFVCA9ICdvZmZzZXQnXG5jb25zdCBNRVRIT0RfUE9TSVRJT04gPSAncG9zaXRpb24nXG5cbmNvbnN0IFNFTEVDVE9SX0RBVEFfU1BZID0gJ1tkYXRhLXNweT1cInNjcm9sbFwiXSdcbmNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJ1xuY29uc3QgU0VMRUNUT1JfTkFWX0xJTktTID0gJy5uYXYtbGluaydcbmNvbnN0IFNFTEVDVE9SX05BVl9JVEVNUyA9ICcubmF2LWl0ZW0nXG5jb25zdCBTRUxFQ1RPUl9MSVNUX0lURU1TID0gJy5saXN0LWdyb3VwLWl0ZW0nXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9JVEVNUyA9ICcuZHJvcGRvd24taXRlbSdcbmNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBvZmZzZXQ6IDEwLFxuICBtZXRob2Q6ICdhdXRvJyxcbiAgdGFyZ2V0OiAnJ1xufVxuXG5jb25zdCBEZWZhdWx0VHlwZSA9IHtcbiAgb2Zmc2V0OiAnbnVtYmVyJyxcbiAgbWV0aG9kOiAnc3RyaW5nJyxcbiAgdGFyZ2V0OiAnKHN0cmluZ3xlbGVtZW50KSdcbn1cblxuLyoqXG4gKiBDbGFzcyBkZWZpbml0aW9uXG4gKi9cblxuY2xhc3MgU2Nyb2xsU3B5IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gZWxlbWVudC50YWdOYW1lID09PSAnQk9EWScgPyB3aW5kb3cgOiBlbGVtZW50XG4gICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZylcbiAgICB0aGlzLl9zZWxlY3RvciA9IGAke3RoaXMuX2NvbmZpZy50YXJnZXR9ICR7U0VMRUNUT1JfTkFWX0xJTktTfSxgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9MSVNUX0lURU1TfSxgICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYCR7dGhpcy5fY29uZmlnLnRhcmdldH0gJHtTRUxFQ1RPUl9EUk9QRE9XTl9JVEVNU31gXG4gICAgdGhpcy5fb2Zmc2V0cyA9IFtdXG4gICAgdGhpcy5fdGFyZ2V0cyA9IFtdXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IDBcblxuICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkub24oRVZFTlRfU0NST0xMLCBldmVudCA9PiB0aGlzLl9wcm9jZXNzKGV2ZW50KSlcblxuICAgIHRoaXMucmVmcmVzaCgpXG4gICAgdGhpcy5fcHJvY2VzcygpXG4gIH1cblxuICAvLyBHZXR0ZXJzXG4gIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICByZXR1cm4gVkVSU0lPTlxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgcmVmcmVzaCgpIHtcbiAgICBjb25zdCBhdXRvTWV0aG9kID0gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gdGhpcy5fc2Nyb2xsRWxlbWVudC53aW5kb3cgP1xuICAgICAgTUVUSE9EX09GRlNFVCA6IE1FVEhPRF9QT1NJVElPTlxuXG4gICAgY29uc3Qgb2Zmc2V0TWV0aG9kID0gdGhpcy5fY29uZmlnLm1ldGhvZCA9PT0gJ2F1dG8nID9cbiAgICAgIGF1dG9NZXRob2QgOiB0aGlzLl9jb25maWcubWV0aG9kXG5cbiAgICBjb25zdCBvZmZzZXRCYXNlID0gb2Zmc2V0TWV0aG9kID09PSBNRVRIT0RfUE9TSVRJT04gP1xuICAgICAgdGhpcy5fZ2V0U2Nyb2xsVG9wKCkgOiAwXG5cbiAgICB0aGlzLl9vZmZzZXRzID0gW11cbiAgICB0aGlzLl90YXJnZXRzID0gW11cblxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IHRoaXMuX2dldFNjcm9sbEhlaWdodCgpXG5cbiAgICBjb25zdCB0YXJnZXRzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHRoaXMuX3NlbGVjdG9yKSlcblxuICAgIHRhcmdldHNcbiAgICAgIC5tYXAoZWxlbWVudCA9PiB7XG4gICAgICAgIGxldCB0YXJnZXRcbiAgICAgICAgY29uc3QgdGFyZ2V0U2VsZWN0b3IgPSBVdGlsLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbWVudClcblxuICAgICAgICBpZiAodGFyZ2V0U2VsZWN0b3IpIHtcbiAgICAgICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIGNvbnN0IHRhcmdldEJDUiA9IHRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgICAgIGlmICh0YXJnZXRCQ1Iud2lkdGggfHwgdGFyZ2V0QkNSLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gVE9ETyAoZmF0KTogcmVtb3ZlIHNrZXRjaCByZWxpYW5jZSBvbiBqUXVlcnkgcG9zaXRpb24vb2Zmc2V0XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAkKHRhcmdldClbb2Zmc2V0TWV0aG9kXSgpLnRvcCArIG9mZnNldEJhc2UsXG4gICAgICAgICAgICAgIHRhcmdldFNlbGVjdG9yXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH0pXG4gICAgICAuZmlsdGVyKGl0ZW0gPT4gaXRlbSlcbiAgICAgIC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSlcbiAgICAgIC5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICB0aGlzLl9vZmZzZXRzLnB1c2goaXRlbVswXSlcbiAgICAgICAgdGhpcy5fdGFyZ2V0cy5wdXNoKGl0ZW1bMV0pXG4gICAgICB9KVxuICB9XG5cbiAgZGlzcG9zZSgpIHtcbiAgICAkLnJlbW92ZURhdGEodGhpcy5fZWxlbWVudCwgREFUQV9LRVkpXG4gICAgJCh0aGlzLl9zY3JvbGxFbGVtZW50KS5vZmYoRVZFTlRfS0VZKVxuXG4gICAgdGhpcy5fZWxlbWVudCA9IG51bGxcbiAgICB0aGlzLl9zY3JvbGxFbGVtZW50ID0gbnVsbFxuICAgIHRoaXMuX2NvbmZpZyA9IG51bGxcbiAgICB0aGlzLl9zZWxlY3RvciA9IG51bGxcbiAgICB0aGlzLl9vZmZzZXRzID0gbnVsbFxuICAgIHRoaXMuX3RhcmdldHMgPSBudWxsXG4gICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbFxuICAgIHRoaXMuX3Njcm9sbEhlaWdodCA9IG51bGxcbiAgfVxuXG4gIC8vIFByaXZhdGVcbiAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICBjb25maWcgPSB7XG4gICAgICAuLi5EZWZhdWx0LFxuICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29uZmlnLnRhcmdldCAhPT0gJ3N0cmluZycgJiYgVXRpbC5pc0VsZW1lbnQoY29uZmlnLnRhcmdldCkpIHtcbiAgICAgIGxldCBpZCA9ICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnKVxuICAgICAgaWYgKCFpZCkge1xuICAgICAgICBpZCA9IFV0aWwuZ2V0VUlEKE5BTUUpXG4gICAgICAgICQoY29uZmlnLnRhcmdldCkuYXR0cignaWQnLCBpZClcbiAgICAgIH1cblxuICAgICAgY29uZmlnLnRhcmdldCA9IGAjJHtpZH1gXG4gICAgfVxuXG4gICAgVXRpbC50eXBlQ2hlY2tDb25maWcoTkFNRSwgY29uZmlnLCBEZWZhdWx0VHlwZSlcblxuICAgIHJldHVybiBjb25maWdcbiAgfVxuXG4gIF9nZXRTY3JvbGxUb3AoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQgPT09IHdpbmRvdyA/XG4gICAgICB0aGlzLl9zY3JvbGxFbGVtZW50LnBhZ2VZT2Zmc2V0IDogdGhpcy5fc2Nyb2xsRWxlbWVudC5zY3JvbGxUb3BcbiAgfVxuXG4gIF9nZXRTY3JvbGxIZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Njcm9sbEVsZW1lbnQuc2Nyb2xsSGVpZ2h0IHx8IE1hdGgubWF4KFxuICAgICAgZG9jdW1lbnQuYm9keS5zY3JvbGxIZWlnaHQsXG4gICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsSGVpZ2h0XG4gICAgKVxuICB9XG5cbiAgX2dldE9mZnNldEhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2Nyb2xsRWxlbWVudCA9PT0gd2luZG93ID9cbiAgICAgIHdpbmRvdy5pbm5lckhlaWdodCA6IHRoaXMuX3Njcm9sbEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0XG4gIH1cblxuICBfcHJvY2VzcygpIHtcbiAgICBjb25zdCBzY3JvbGxUb3AgPSB0aGlzLl9nZXRTY3JvbGxUb3AoKSArIHRoaXMuX2NvbmZpZy5vZmZzZXRcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSB0aGlzLl9nZXRTY3JvbGxIZWlnaHQoKVxuICAgIGNvbnN0IG1heFNjcm9sbCA9IHRoaXMuX2NvbmZpZy5vZmZzZXQgKyBzY3JvbGxIZWlnaHQgLSB0aGlzLl9nZXRPZmZzZXRIZWlnaHQoKVxuXG4gICAgaWYgKHRoaXMuX3Njcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0KSB7XG4gICAgICB0aGlzLnJlZnJlc2goKVxuICAgIH1cblxuICAgIGlmIChzY3JvbGxUb3AgPj0gbWF4U2Nyb2xsKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMubGVuZ3RoIC0gMV1cblxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRhcmdldClcbiAgICAgIH1cblxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCAmJiBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzWzBdICYmIHRoaXMuX29mZnNldHNbMF0gPiAwKSB7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsXG4gICAgICB0aGlzLl9jbGVhcigpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gdGhpcy5fb2Zmc2V0cy5sZW5ndGg7IGktLTspIHtcbiAgICAgIGNvbnN0IGlzQWN0aXZlVGFyZ2V0ID0gdGhpcy5fYWN0aXZlVGFyZ2V0ICE9PSB0aGlzLl90YXJnZXRzW2ldICYmXG4gICAgICAgICAgc2Nyb2xsVG9wID49IHRoaXMuX29mZnNldHNbaV0gJiZcbiAgICAgICAgICAodHlwZW9mIHRoaXMuX29mZnNldHNbaSArIDFdID09PSAndW5kZWZpbmVkJyB8fFxuICAgICAgICAgICAgICBzY3JvbGxUb3AgPCB0aGlzLl9vZmZzZXRzW2kgKyAxXSlcblxuICAgICAgaWYgKGlzQWN0aXZlVGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2FjdGl2YXRlKHRoaXMuX3RhcmdldHNbaV0pXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FjdGl2YXRlKHRhcmdldCkge1xuICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldFxuXG4gICAgdGhpcy5fY2xlYXIoKVxuXG4gICAgY29uc3QgcXVlcmllcyA9IHRoaXMuX3NlbGVjdG9yXG4gICAgICAuc3BsaXQoJywnKVxuICAgICAgLm1hcChzZWxlY3RvciA9PiBgJHtzZWxlY3Rvcn1bZGF0YS10YXJnZXQ9XCIke3RhcmdldH1cIl0sJHtzZWxlY3Rvcn1baHJlZj1cIiR7dGFyZ2V0fVwiXWApXG5cbiAgICBjb25zdCAkbGluayA9ICQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHF1ZXJpZXMuam9pbignLCcpKSkpXG5cbiAgICBpZiAoJGxpbmsuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xuICAgICAgJGxpbmsuY2xvc2VzdChTRUxFQ1RPUl9EUk9QRE9XTilcbiAgICAgICAgLmZpbmQoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAkbGluay5hZGRDbGFzcyhDTEFTU19OQU1FX0FDVElWRSlcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2V0IHRyaWdnZXJlZCBsaW5rIGFzIGFjdGl2ZVxuICAgICAgJGxpbmsuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcbiAgICAgICRsaW5rLnBhcmVudHMoU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApXG4gICAgICAgIC5wcmV2KGAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gKVxuICAgICAgICAuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICAvLyBIYW5kbGUgc3BlY2lhbCBjYXNlIHdoZW4gLm5hdi1saW5rIGlzIGluc2lkZSAubmF2LWl0ZW1cbiAgICAgICRsaW5rLnBhcmVudHMoU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVApXG4gICAgICAgIC5wcmV2KFNFTEVDVE9SX05BVl9JVEVNUylcbiAgICAgICAgLmNoaWxkcmVuKFNFTEVDVE9SX05BVl9MSU5LUylcbiAgICAgICAgLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIH1cblxuICAgICQodGhpcy5fc2Nyb2xsRWxlbWVudCkudHJpZ2dlcihFVkVOVF9BQ1RJVkFURSwge1xuICAgICAgcmVsYXRlZFRhcmdldDogdGFyZ2V0XG4gICAgfSlcbiAgfVxuXG4gIF9jbGVhcigpIHtcbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwodGhpcy5fc2VsZWN0b3IpKVxuICAgICAgLmZpbHRlcihub2RlID0+IG5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKSlcbiAgICAgIC5mb3JFYWNoKG5vZGUgPT4gbm9kZS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFKSlcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGxldCBkYXRhID0gJCh0aGlzKS5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBTY3JvbGxTcHkodGhpcywgX2NvbmZpZylcbiAgICAgICAgJCh0aGlzKS5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKClcbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbi8qKlxuICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAqL1xuXG4kKHdpbmRvdykub24oRVZFTlRfTE9BRF9EQVRBX0FQSSwgKCkgPT4ge1xuICBjb25zdCBzY3JvbGxTcHlzID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFNFTEVDVE9SX0RBVEFfU1BZKSlcbiAgY29uc3Qgc2Nyb2xsU3B5c0xlbmd0aCA9IHNjcm9sbFNweXMubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IHNjcm9sbFNweXNMZW5ndGg7IGktLTspIHtcbiAgICBjb25zdCAkc3B5ID0gJChzY3JvbGxTcHlzW2ldKVxuICAgIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlLmNhbGwoJHNweSwgJHNweS5kYXRhKCkpXG4gIH1cbn0pXG5cbi8qKlxuICogalF1ZXJ5XG4gKi9cblxuJC5mbltOQU1FXSA9IFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gU2Nyb2xsU3B5XG4kLmZuW05BTUVdLm5vQ29uZmxpY3QgPSAoKSA9PiB7XG4gICQuZm5bTkFNRV0gPSBKUVVFUllfTk9fQ09ORkxJQ1RcbiAgcmV0dXJuIFNjcm9sbFNweS5falF1ZXJ5SW50ZXJmYWNlXG59XG5cbmV4cG9ydCBkZWZhdWx0IFNjcm9sbFNweVxuIiwiLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQm9vdHN0cmFwICh2NC42LjEpOiB0YWIuanNcbiAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknXG5pbXBvcnQgVXRpbCBmcm9tICcuL3V0aWwnXG5cbi8qKlxuICogQ29uc3RhbnRzXG4gKi9cblxuY29uc3QgTkFNRSA9ICd0YWInXG5jb25zdCBWRVJTSU9OID0gJzQuNi4xJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMudGFiJ1xuY29uc3QgRVZFTlRfS0VZID0gYC4ke0RBVEFfS0VZfWBcbmNvbnN0IERBVEFfQVBJX0tFWSA9ICcuZGF0YS1hcGknXG5jb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW05BTUVdXG5cbmNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fTUVOVSA9ICdkcm9wZG93bi1tZW51J1xuY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJ1xuY29uc3QgQ0xBU1NfTkFNRV9ESVNBQkxFRCA9ICdkaXNhYmxlZCdcbmNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5cbmNvbnN0IEVWRU5UX0hJREUgPSBgaGlkZSR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XID0gYHNob3cke0VWRU5UX0tFWX1gXG5jb25zdCBFVkVOVF9TSE9XTiA9IGBzaG93biR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJID0gYGNsaWNrJHtFVkVOVF9LRVl9JHtEQVRBX0FQSV9LRVl9YFxuXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nXG5jb25zdCBTRUxFQ1RPUl9OQVZfTElTVF9HUk9VUCA9ICcubmF2LCAubGlzdC1ncm91cCdcbmNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfQUNUSVZFX1VMID0gJz4gbGkgPiAuYWN0aXZlJ1xuY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS10b2dnbGU9XCJsaXN0XCJdJ1xuY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnXG5jb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9BQ1RJVkVfQ0hJTEQgPSAnPiAuZHJvcGRvd24tbWVudSAuYWN0aXZlJ1xuXG4vKipcbiAqIENsYXNzIGRlZmluaXRpb25cbiAqL1xuXG5jbGFzcyBUYWIge1xuICBjb25zdHJ1Y3RvcihlbGVtZW50KSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5fZWxlbWVudC5wYXJlbnROb2RlICYmXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiZcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0FDVElWRSkgfHxcbiAgICAgICAgJCh0aGlzLl9lbGVtZW50KS5oYXNDbGFzcyhDTEFTU19OQU1FX0RJU0FCTEVEKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgbGV0IHRhcmdldFxuICAgIGxldCBwcmV2aW91c1xuICAgIGNvbnN0IGxpc3RFbGVtZW50ID0gJCh0aGlzLl9lbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKVswXVxuICAgIGNvbnN0IHNlbGVjdG9yID0gVXRpbC5nZXRTZWxlY3RvckZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICBpZiAobGlzdEVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IGl0ZW1TZWxlY3RvciA9IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnVUwnIHx8IGxpc3RFbGVtZW50Lm5vZGVOYW1lID09PSAnT0wnID8gU0VMRUNUT1JfQUNUSVZFX1VMIDogU0VMRUNUT1JfQUNUSVZFXG4gICAgICBwcmV2aW91cyA9ICQubWFrZUFycmF5KCQobGlzdEVsZW1lbnQpLmZpbmQoaXRlbVNlbGVjdG9yKSlcbiAgICAgIHByZXZpb3VzID0gcHJldmlvdXNbcHJldmlvdXMubGVuZ3RoIC0gMV1cbiAgICB9XG5cbiAgICBjb25zdCBoaWRlRXZlbnQgPSAkLkV2ZW50KEVWRU5UX0hJREUsIHtcbiAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICB9KVxuXG4gICAgY29uc3Qgc2hvd0V2ZW50ID0gJC5FdmVudChFVkVOVF9TSE9XLCB7XG4gICAgICByZWxhdGVkVGFyZ2V0OiBwcmV2aW91c1xuICAgIH0pXG5cbiAgICBpZiAocHJldmlvdXMpIHtcbiAgICAgICQocHJldmlvdXMpLnRyaWdnZXIoaGlkZUV2ZW50KVxuICAgIH1cblxuICAgICQodGhpcy5fZWxlbWVudCkudHJpZ2dlcihzaG93RXZlbnQpXG5cbiAgICBpZiAoc2hvd0V2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpIHx8XG4gICAgICAgIGhpZGVFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICB0YXJnZXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIH1cblxuICAgIHRoaXMuX2FjdGl2YXRlKFxuICAgICAgdGhpcy5fZWxlbWVudCxcbiAgICAgIGxpc3RFbGVtZW50XG4gICAgKVxuXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICBjb25zdCBoaWRkZW5FdmVudCA9ICQuRXZlbnQoRVZFTlRfSElEREVOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pXG5cbiAgICAgIGNvbnN0IHNob3duRXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1dOLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHByZXZpb3VzXG4gICAgICB9KVxuXG4gICAgICAkKHByZXZpb3VzKS50cmlnZ2VyKGhpZGRlbkV2ZW50KVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKHNob3duRXZlbnQpXG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5fYWN0aXZhdGUodGFyZ2V0LCB0YXJnZXQucGFyZW50Tm9kZSwgY29tcGxldGUpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgICQucmVtb3ZlRGF0YSh0aGlzLl9lbGVtZW50LCBEQVRBX0tFWSlcbiAgICB0aGlzLl9lbGVtZW50ID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfYWN0aXZhdGUoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnRzID0gY29udGFpbmVyICYmIChjb250YWluZXIubm9kZU5hbWUgPT09ICdVTCcgfHwgY29udGFpbmVyLm5vZGVOYW1lID09PSAnT0wnKSA/XG4gICAgICAkKGNvbnRhaW5lcikuZmluZChTRUxFQ1RPUl9BQ1RJVkVfVUwpIDpcbiAgICAgICQoY29udGFpbmVyKS5jaGlsZHJlbihTRUxFQ1RPUl9BQ1RJVkUpXG5cbiAgICBjb25zdCBhY3RpdmUgPSBhY3RpdmVFbGVtZW50c1swXVxuICAgIGNvbnN0IGlzVHJhbnNpdGlvbmluZyA9IGNhbGxiYWNrICYmIChhY3RpdmUgJiYgJChhY3RpdmUpLmhhc0NsYXNzKENMQVNTX05BTUVfRkFERSkpXG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB0aGlzLl90cmFuc2l0aW9uQ29tcGxldGUoXG4gICAgICBlbGVtZW50LFxuICAgICAgYWN0aXZlLFxuICAgICAgY2FsbGJhY2tcbiAgICApXG5cbiAgICBpZiAoYWN0aXZlICYmIGlzVHJhbnNpdGlvbmluZykge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudChhY3RpdmUpXG5cbiAgICAgICQoYWN0aXZlKVxuICAgICAgICAucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9TSE9XKVxuICAgICAgICAub25lKFV0aWwuVFJBTlNJVElPTl9FTkQsIGNvbXBsZXRlKVxuICAgICAgICAuZW11bGF0ZVRyYW5zaXRpb25FbmQodHJhbnNpdGlvbkR1cmF0aW9uKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wbGV0ZSgpXG4gICAgfVxuICB9XG5cbiAgX3RyYW5zaXRpb25Db21wbGV0ZShlbGVtZW50LCBhY3RpdmUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFjdGl2ZSkge1xuICAgICAgJChhY3RpdmUpLnJlbW92ZUNsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuXG4gICAgICBjb25zdCBkcm9wZG93bkNoaWxkID0gJChhY3RpdmUucGFyZW50Tm9kZSkuZmluZChcbiAgICAgICAgU0VMRUNUT1JfRFJPUERPV05fQUNUSVZFX0NISUxEXG4gICAgICApWzBdXG5cbiAgICAgIGlmIChkcm9wZG93bkNoaWxkKSB7XG4gICAgICAgICQoZHJvcGRvd25DaGlsZCkucmVtb3ZlQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIGlmIChhY3RpdmUuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICd0YWInKSB7XG4gICAgICAgIGFjdGl2ZS5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCBmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICAkKGVsZW1lbnQpLmFkZENsYXNzKENMQVNTX05BTUVfQUNUSVZFKVxuICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpID09PSAndGFiJykge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKVxuICAgIH1cblxuICAgIFV0aWwucmVmbG93KGVsZW1lbnQpXG5cbiAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFKSkge1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVylcbiAgICB9XG5cbiAgICBsZXQgcGFyZW50ID0gZWxlbWVudC5wYXJlbnROb2RlXG4gICAgaWYgKHBhcmVudCAmJiBwYXJlbnQubm9kZU5hbWUgPT09ICdMSScpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnROb2RlXG4gICAgfVxuXG4gICAgaWYgKHBhcmVudCAmJiAkKHBhcmVudCkuaGFzQ2xhc3MoQ0xBU1NfTkFNRV9EUk9QRE9XTl9NRU5VKSkge1xuICAgICAgY29uc3QgZHJvcGRvd25FbGVtZW50ID0gJChlbGVtZW50KS5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKVswXVxuXG4gICAgICBpZiAoZHJvcGRvd25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGRyb3Bkb3duVG9nZ2xlTGlzdCA9IFtdLnNsaWNlLmNhbGwoZHJvcGRvd25FbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFKSlcblxuICAgICAgICAkKGRyb3Bkb3duVG9nZ2xlTGlzdCkuYWRkQ2xhc3MoQ0xBU1NfTkFNRV9BQ1RJVkUpXG4gICAgICB9XG5cbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSlcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNhbGxiYWNrKClcbiAgICB9XG4gIH1cblxuICAvLyBTdGF0aWNcbiAgc3RhdGljIF9qUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCAkdGhpcyA9ICQodGhpcylcbiAgICAgIGxldCBkYXRhID0gJHRoaXMuZGF0YShEQVRBX0tFWSlcblxuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgVGFiKHRoaXMpXG4gICAgICAgICR0aGlzLmRhdGEoREFUQV9LRVksIGRhdGEpXG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApXG4gICAgICAgIH1cblxuICAgICAgICBkYXRhW2NvbmZpZ10oKVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuLyoqXG4gKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICovXG5cbiQoZG9jdW1lbnQpXG4gIC5vbihFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KClcbiAgICBUYWIuX2pRdWVyeUludGVyZmFjZS5jYWxsKCQodGhpcyksICdzaG93JylcbiAgfSlcblxuLyoqXG4gKiBqUXVlcnlcbiAqL1xuXG4kLmZuW05BTUVdID0gVGFiLl9qUXVlcnlJbnRlcmZhY2VcbiQuZm5bTkFNRV0uQ29uc3RydWN0b3IgPSBUYWJcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gVGFiLl9qUXVlcnlJbnRlcmZhY2Vcbn1cblxuZXhwb3J0IGRlZmF1bHQgVGFiXG4iLCIvKipcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBCb290c3RyYXAgKHY0LjYuMSk6IHRvYXN0LmpzXG4gKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKi9cblxuaW1wb3J0ICQgZnJvbSAnanF1ZXJ5J1xuaW1wb3J0IFV0aWwgZnJvbSAnLi91dGlsJ1xuXG4vKipcbiAqIENvbnN0YW50c1xuICovXG5cbmNvbnN0IE5BTUUgPSAndG9hc3QnXG5jb25zdCBWRVJTSU9OID0gJzQuNi4xJ1xuY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnXG5jb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YFxuY29uc3QgSlFVRVJZX05PX0NPTkZMSUNUID0gJC5mbltOQU1FXVxuXG5jb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSdcbmNvbnN0IENMQVNTX05BTUVfSElERSA9ICdoaWRlJ1xuY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnXG5jb25zdCBDTEFTU19OQU1FX1NIT1dJTkcgPSAnc2hvd2luZydcblxuY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElERSA9IGBoaWRlJHtFVkVOVF9LRVl9YFxuY29uc3QgRVZFTlRfSElEREVOID0gYGhpZGRlbiR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWBcbmNvbnN0IEVWRU5UX1NIT1dOID0gYHNob3duJHtFVkVOVF9LRVl9YFxuXG5jb25zdCBTRUxFQ1RPUl9EQVRBX0RJU01JU1MgPSAnW2RhdGEtZGlzbWlzcz1cInRvYXN0XCJdJ1xuXG5jb25zdCBEZWZhdWx0ID0ge1xuICBhbmltYXRpb246IHRydWUsXG4gIGF1dG9oaWRlOiB0cnVlLFxuICBkZWxheTogNTAwXG59XG5cbmNvbnN0IERlZmF1bHRUeXBlID0ge1xuICBhbmltYXRpb246ICdib29sZWFuJyxcbiAgYXV0b2hpZGU6ICdib29sZWFuJyxcbiAgZGVsYXk6ICdudW1iZXInXG59XG5cbi8qKlxuICogQ2xhc3MgZGVmaW5pdGlvblxuICovXG5cbmNsYXNzIFRvYXN0IHtcbiAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnRcbiAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKVxuICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsXG4gICAgdGhpcy5fc2V0TGlzdGVuZXJzKClcbiAgfVxuXG4gIC8vIEdldHRlcnNcbiAgc3RhdGljIGdldCBWRVJTSU9OKCkge1xuICAgIHJldHVybiBWRVJTSU9OXG4gIH1cblxuICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgIHJldHVybiBEZWZhdWx0VHlwZVxuICB9XG5cbiAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgIHJldHVybiBEZWZhdWx0XG4gIH1cblxuICAvLyBQdWJsaWNcbiAgc2hvdygpIHtcbiAgICBjb25zdCBzaG93RXZlbnQgPSAkLkV2ZW50KEVWRU5UX1NIT1cpXG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoc2hvd0V2ZW50KVxuICAgIGlmIChzaG93RXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSlcbiAgICB9XG5cbiAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcpXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XKVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpLnRyaWdnZXIoRVZFTlRfU0hPV04pXG5cbiAgICAgIGlmICh0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcbiAgICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuaGlkZSgpXG4gICAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKVxuICAgIFV0aWwucmVmbG93KHRoaXMuX2VsZW1lbnQpXG4gICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORylcbiAgICBpZiAodGhpcy5fY29uZmlnLmFuaW1hdGlvbikge1xuICAgICAgY29uc3QgdHJhbnNpdGlvbkR1cmF0aW9uID0gVXRpbC5nZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0aGlzLl9lbGVtZW50KVxuXG4gICAgICAkKHRoaXMuX2VsZW1lbnQpXG4gICAgICAgIC5vbmUoVXRpbC5UUkFOU0lUSU9OX0VORCwgY29tcGxldGUpXG4gICAgICAgIC5lbXVsYXRlVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRHVyYXRpb24pXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbXBsZXRlKClcbiAgICB9XG4gIH1cblxuICBoaWRlKCkge1xuICAgIGlmICghdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgY29uc3QgaGlkZUV2ZW50ID0gJC5FdmVudChFVkVOVF9ISURFKVxuXG4gICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKGhpZGVFdmVudClcbiAgICBpZiAoaGlkZUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0aGlzLl9jbG9zZSgpXG4gIH1cblxuICBkaXNwb3NlKCkge1xuICAgIHRoaXMuX2NsZWFyVGltZW91dCgpXG5cbiAgICBpZiAodGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XKSkge1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVylcbiAgICB9XG5cbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9mZihFVkVOVF9DTElDS19ESVNNSVNTKVxuXG4gICAgJC5yZW1vdmVEYXRhKHRoaXMuX2VsZW1lbnQsIERBVEFfS0VZKVxuICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsXG4gICAgdGhpcy5fY29uZmlnID0gbnVsbFxuICB9XG5cbiAgLy8gUHJpdmF0ZVxuICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgIGNvbmZpZyA9IHtcbiAgICAgIC4uLkRlZmF1bHQsXG4gICAgICAuLi4kKHRoaXMuX2VsZW1lbnQpLmRhdGEoKSxcbiAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcbiAgICB9XG5cbiAgICBVdGlsLnR5cGVDaGVja0NvbmZpZyhcbiAgICAgIE5BTUUsXG4gICAgICBjb25maWcsXG4gICAgICB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRUeXBlXG4gICAgKVxuXG4gICAgcmV0dXJuIGNvbmZpZ1xuICB9XG5cbiAgX3NldExpc3RlbmVycygpIHtcbiAgICAkKHRoaXMuX2VsZW1lbnQpLm9uKEVWRU5UX0NMSUNLX0RJU01JU1MsIFNFTEVDVE9SX0RBVEFfRElTTUlTUywgKCkgPT4gdGhpcy5oaWRlKCkpXG4gIH1cblxuICBfY2xvc2UoKSB7XG4gICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9ISURFKVxuICAgICAgJCh0aGlzLl9lbGVtZW50KS50cmlnZ2VyKEVWRU5UX0hJRERFTilcbiAgICB9XG5cbiAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKVxuICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uRHVyYXRpb24gPSBVdGlsLmdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50KHRoaXMuX2VsZW1lbnQpXG5cbiAgICAgICQodGhpcy5fZWxlbWVudClcbiAgICAgICAgLm9uZShVdGlsLlRSQU5TSVRJT05fRU5ELCBjb21wbGV0ZSlcbiAgICAgICAgLmVtdWxhdGVUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25EdXJhdGlvbilcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcGxldGUoKVxuICAgIH1cbiAgfVxuXG4gIF9jbGVhclRpbWVvdXQoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpXG4gICAgdGhpcy5fdGltZW91dCA9IG51bGxcbiAgfVxuXG4gIC8vIFN0YXRpY1xuICBzdGF0aWMgX2pRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0ICRlbGVtZW50ID0gJCh0aGlzKVxuICAgICAgbGV0IGRhdGEgPSAkZWxlbWVudC5kYXRhKERBVEFfS0VZKVxuICAgICAgY29uc3QgX2NvbmZpZyA9IHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZ1xuXG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgZGF0YSA9IG5ldyBUb2FzdCh0aGlzLCBfY29uZmlnKVxuICAgICAgICAkZWxlbWVudC5kYXRhKERBVEFfS0VZLCBkYXRhKVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKVxuICAgICAgICB9XG5cbiAgICAgICAgZGF0YVtjb25maWddKHRoaXMpXG4gICAgICB9XG4gICAgfSlcbiAgfVxufVxuXG4vKipcbiAqIGpRdWVyeVxuICovXG5cbiQuZm5bTkFNRV0gPSBUb2FzdC5falF1ZXJ5SW50ZXJmYWNlXG4kLmZuW05BTUVdLkNvbnN0cnVjdG9yID0gVG9hc3RcbiQuZm5bTkFNRV0ubm9Db25mbGljdCA9ICgpID0+IHtcbiAgJC5mbltOQU1FXSA9IEpRVUVSWV9OT19DT05GTElDVFxuICByZXR1cm4gVG9hc3QuX2pRdWVyeUludGVyZmFjZVxufVxuXG5leHBvcnQgZGVmYXVsdCBUb2FzdFxuIl0sIm5hbWVzIjpbIlRSQU5TSVRJT05fRU5EIiwiTUFYX1VJRCIsIk1JTExJU0VDT05EU19NVUxUSVBMSUVSIiwidG9UeXBlIiwib2JqIiwidG9TdHJpbmciLCJjYWxsIiwibWF0Y2giLCJ0b0xvd2VyQ2FzZSIsImdldFNwZWNpYWxUcmFuc2l0aW9uRW5kRXZlbnQiLCJiaW5kVHlwZSIsImRlbGVnYXRlVHlwZSIsImhhbmRsZSIsImV2ZW50IiwiJCIsInRhcmdldCIsImlzIiwiaGFuZGxlT2JqIiwiaGFuZGxlciIsImFwcGx5IiwiYXJndW1lbnRzIiwidW5kZWZpbmVkIiwidHJhbnNpdGlvbkVuZEVtdWxhdG9yIiwiZHVyYXRpb24iLCJjYWxsZWQiLCJvbmUiLCJVdGlsIiwic2V0VGltZW91dCIsInRyaWdnZXJUcmFuc2l0aW9uRW5kIiwiX3RoaXMiLCJzZXRUcmFuc2l0aW9uRW5kU3VwcG9ydCIsImZuIiwiZW11bGF0ZVRyYW5zaXRpb25FbmQiLCJzcGVjaWFsIiwiZ2V0VUlEIiwicHJlZml4IiwiTWF0aCIsInJhbmRvbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRTZWxlY3RvckZyb21FbGVtZW50IiwiZWxlbWVudCIsInNlbGVjdG9yIiwiZ2V0QXR0cmlidXRlIiwiaHJlZkF0dHIiLCJ0cmltIiwicXVlcnlTZWxlY3RvciIsIl8iLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsImNzcyIsInRyYW5zaXRpb25EZWxheSIsImZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uIiwicGFyc2VGbG9hdCIsImZsb2F0VHJhbnNpdGlvbkRlbGF5Iiwic3BsaXQiLCJyZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJ0cmlnZ2VyIiwic3VwcG9ydHNUcmFuc2l0aW9uRW5kIiwiQm9vbGVhbiIsImlzRWxlbWVudCIsIm5vZGVUeXBlIiwidHlwZUNoZWNrQ29uZmlnIiwiY29tcG9uZW50TmFtZSIsImNvbmZpZyIsImNvbmZpZ1R5cGVzIiwicHJvcGVydHkiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImV4cGVjdGVkVHlwZXMiLCJ2YWx1ZSIsInZhbHVlVHlwZSIsIlJlZ0V4cCIsInRlc3QiLCJFcnJvciIsInRvVXBwZXJDYXNlIiwiZmluZFNoYWRvd1Jvb3QiLCJkb2N1bWVudEVsZW1lbnQiLCJhdHRhY2hTaGFkb3ciLCJnZXRSb290Tm9kZSIsInJvb3QiLCJTaGFkb3dSb290IiwicGFyZW50Tm9kZSIsImpRdWVyeURldGVjdGlvbiIsIlR5cGVFcnJvciIsInZlcnNpb24iLCJqcXVlcnkiLCJtaW5NYWpvciIsImx0TWFqb3IiLCJtaW5NaW5vciIsIm1pblBhdGNoIiwibWF4TWFqb3IiLCJOQU1FIiwiVkVSU0lPTiIsIkRBVEFfS0VZIiwiRVZFTlRfS0VZIiwiREFUQV9BUElfS0VZIiwiSlFVRVJZX05PX0NPTkZMSUNUIiwiQ0xBU1NfTkFNRV9BTEVSVCIsIkNMQVNTX05BTUVfRkFERSIsIkNMQVNTX05BTUVfU0hPVyIsIkVWRU5UX0NMT1NFIiwiRVZFTlRfQ0xPU0VEIiwiRVZFTlRfQ0xJQ0tfREFUQV9BUEkiLCJTRUxFQ1RPUl9ESVNNSVNTIiwiQWxlcnQiLCJfZWxlbWVudCIsImNsb3NlIiwicm9vdEVsZW1lbnQiLCJfZ2V0Um9vdEVsZW1lbnQiLCJjdXN0b21FdmVudCIsIl90cmlnZ2VyQ2xvc2VFdmVudCIsImlzRGVmYXVsdFByZXZlbnRlZCIsIl9yZW1vdmVFbGVtZW50IiwiZGlzcG9zZSIsInJlbW92ZURhdGEiLCJwYXJlbnQiLCJjbG9zZXN0IiwiY2xvc2VFdmVudCIsIkV2ZW50IiwicmVtb3ZlQ2xhc3MiLCJoYXNDbGFzcyIsIl9kZXN0cm95RWxlbWVudCIsImRldGFjaCIsInJlbW92ZSIsIl9qUXVlcnlJbnRlcmZhY2UiLCJlYWNoIiwiJGVsZW1lbnQiLCJkYXRhIiwiX2hhbmRsZURpc21pc3MiLCJhbGVydEluc3RhbmNlIiwicHJldmVudERlZmF1bHQiLCJvbiIsIkNvbnN0cnVjdG9yIiwibm9Db25mbGljdCIsIkNMQVNTX05BTUVfQUNUSVZFIiwiQ0xBU1NfTkFNRV9CVVRUT04iLCJDTEFTU19OQU1FX0ZPQ1VTIiwiRVZFTlRfRk9DVVNfQkxVUl9EQVRBX0FQSSIsIkVWRU5UX0xPQURfREFUQV9BUEkiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRV9DQVJST1QiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRVMiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFU19CVVRUT05TIiwiU0VMRUNUT1JfSU5QVVQiLCJTRUxFQ1RPUl9BQ1RJVkUiLCJTRUxFQ1RPUl9CVVRUT04iLCJCdXR0b24iLCJzaG91bGRBdm9pZFRyaWdnZXJDaGFuZ2UiLCJ0b2dnbGUiLCJ0cmlnZ2VyQ2hhbmdlRXZlbnQiLCJhZGRBcmlhUHJlc3NlZCIsImlucHV0IiwidHlwZSIsImNoZWNrZWQiLCJjbGFzc0xpc3QiLCJjb250YWlucyIsImFjdGl2ZUVsZW1lbnQiLCJmb2N1cyIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInRvZ2dsZUNsYXNzIiwiYXZvaWRUcmlnZ2VyQ2hhbmdlIiwiYnV0dG9uIiwiaW5pdGlhbEJ1dHRvbiIsImlucHV0QnRuIiwidGFnTmFtZSIsIndpbmRvdyIsImJ1dHRvbnMiLCJzbGljZSIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJpIiwibGVuIiwibGVuZ3RoIiwiYWRkIiwiQVJST1dfTEVGVF9LRVlDT0RFIiwiQVJST1dfUklHSFRfS0VZQ09ERSIsIlRPVUNIRVZFTlRfQ09NUEFUX1dBSVQiLCJTV0lQRV9USFJFU0hPTEQiLCJDTEFTU19OQU1FX0NBUk9VU0VMIiwiQ0xBU1NfTkFNRV9TTElERSIsIkNMQVNTX05BTUVfUklHSFQiLCJDTEFTU19OQU1FX0xFRlQiLCJDTEFTU19OQU1FX05FWFQiLCJDTEFTU19OQU1FX1BSRVYiLCJDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQiLCJESVJFQ1RJT05fTkVYVCIsIkRJUkVDVElPTl9QUkVWIiwiRElSRUNUSU9OX0xFRlQiLCJESVJFQ1RJT05fUklHSFQiLCJFVkVOVF9TTElERSIsIkVWRU5UX1NMSUQiLCJFVkVOVF9LRVlET1dOIiwiRVZFTlRfTU9VU0VFTlRFUiIsIkVWRU5UX01PVVNFTEVBVkUiLCJFVkVOVF9UT1VDSFNUQVJUIiwiRVZFTlRfVE9VQ0hNT1ZFIiwiRVZFTlRfVE9VQ0hFTkQiLCJFVkVOVF9QT0lOVEVSRE9XTiIsIkVWRU5UX1BPSU5URVJVUCIsIkVWRU5UX0RSQUdfU1RBUlQiLCJTRUxFQ1RPUl9BQ1RJVkVfSVRFTSIsIlNFTEVDVE9SX0lURU0iLCJTRUxFQ1RPUl9JVEVNX0lNRyIsIlNFTEVDVE9SX05FWFRfUFJFViIsIlNFTEVDVE9SX0lORElDQVRPUlMiLCJTRUxFQ1RPUl9EQVRBX1NMSURFIiwiU0VMRUNUT1JfREFUQV9SSURFIiwiRGVmYXVsdCIsImludGVydmFsIiwia2V5Ym9hcmQiLCJzbGlkZSIsInBhdXNlIiwid3JhcCIsInRvdWNoIiwiRGVmYXVsdFR5cGUiLCJQb2ludGVyVHlwZSIsIlRPVUNIIiwiUEVOIiwiQ2Fyb3VzZWwiLCJfaXRlbXMiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1BhdXNlZCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJ0b3VjaFN0YXJ0WCIsInRvdWNoRGVsdGFYIiwiX2NvbmZpZyIsIl9nZXRDb25maWciLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfdG91Y2hTdXBwb3J0ZWQiLCJuYXZpZ2F0b3IiLCJtYXhUb3VjaFBvaW50cyIsIl9wb2ludGVyRXZlbnQiLCJQb2ludGVyRXZlbnQiLCJNU1BvaW50ZXJFdmVudCIsIl9hZGRFdmVudExpc3RlbmVycyIsIm5leHQiLCJfc2xpZGUiLCJuZXh0V2hlblZpc2libGUiLCJoaWRkZW4iLCJwcmV2IiwiY3ljbGUiLCJjbGVhckludGVydmFsIiwiX3VwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJ2aXNpYmlsaXR5U3RhdGUiLCJiaW5kIiwidG8iLCJpbmRleCIsImFjdGl2ZUluZGV4IiwiX2dldEl0ZW1JbmRleCIsImRpcmVjdGlvbiIsIm9mZiIsIl9oYW5kbGVTd2lwZSIsImFic0RlbHRheCIsImFicyIsIl90aGlzMiIsIl9rZXlkb3duIiwiX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMiLCJzdGFydCIsIl90aGlzMyIsIm9yaWdpbmFsRXZlbnQiLCJwb2ludGVyVHlwZSIsImNsaWVudFgiLCJ0b3VjaGVzIiwibW92ZSIsImVuZCIsImNsZWFyVGltZW91dCIsImUiLCJ3aGljaCIsImluZGV4T2YiLCJfZ2V0SXRlbUJ5RGlyZWN0aW9uIiwiaXNOZXh0RGlyZWN0aW9uIiwiaXNQcmV2RGlyZWN0aW9uIiwibGFzdEl0ZW1JbmRleCIsImlzR29pbmdUb1dyYXAiLCJkZWx0YSIsIml0ZW1JbmRleCIsIl90cmlnZ2VyU2xpZGVFdmVudCIsInJlbGF0ZWRUYXJnZXQiLCJldmVudERpcmVjdGlvbk5hbWUiLCJ0YXJnZXRJbmRleCIsImZyb21JbmRleCIsInNsaWRlRXZlbnQiLCJmcm9tIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJpbmRpY2F0b3JzIiwibmV4dEluZGljYXRvciIsImNoaWxkcmVuIiwiYWRkQ2xhc3MiLCJlbGVtZW50SW50ZXJ2YWwiLCJwYXJzZUludCIsImRlZmF1bHRJbnRlcnZhbCIsImFjdGl2ZUVsZW1lbnRJbmRleCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJzbGlkRXZlbnQiLCJfdGhpczQiLCJhY3Rpb24iLCJyaWRlIiwiX2RhdGFBcGlDbGlja0hhbmRsZXIiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiJGNhcm91c2VsIiwiQ0xBU1NfTkFNRV9DT0xMQVBTRSIsIkNMQVNTX05BTUVfQ09MTEFQU0lORyIsIkNMQVNTX05BTUVfQ09MTEFQU0VEIiwiRElNRU5TSU9OX1dJRFRIIiwiRElNRU5TSU9OX0hFSUdIVCIsIkVWRU5UX1NIT1ciLCJFVkVOVF9TSE9XTiIsIkVWRU5UX0hJREUiLCJFVkVOVF9ISURERU4iLCJTRUxFQ1RPUl9BQ1RJVkVTIiwiQ29sbGFwc2UiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsImlkIiwidG9nZ2xlTGlzdCIsImVsZW0iLCJmaWx0ZXJFbGVtZW50IiwiZmlsdGVyIiwiZm91bmRFbGVtIiwiX3NlbGVjdG9yIiwicHVzaCIsIl9wYXJlbnQiLCJfZ2V0UGFyZW50IiwiX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyIsImhpZGUiLCJzaG93IiwiYWN0aXZlcyIsImFjdGl2ZXNEYXRhIiwibm90Iiwic3RhcnRFdmVudCIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzdHlsZSIsImF0dHIiLCJzZXRUcmFuc2l0aW9uaW5nIiwiY29tcGxldGUiLCJjYXBpdGFsaXplZERpbWVuc2lvbiIsInNjcm9sbFNpemUiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJ0cmlnZ2VyQXJyYXlMZW5ndGgiLCIkZWxlbSIsImlzVHJhbnNpdGlvbmluZyIsImhhc1dpZHRoIiwiX2dldFRhcmdldEZyb21FbGVtZW50IiwidHJpZ2dlckFycmF5IiwiaXNPcGVuIiwiY3VycmVudFRhcmdldCIsIiR0cmlnZ2VyIiwic2VsZWN0b3JzIiwiJHRhcmdldCIsImlzQnJvd3NlciIsInRpbWVvdXREdXJhdGlvbiIsImxvbmdlclRpbWVvdXRCcm93c2VycyIsInVzZXJBZ2VudCIsIm1pY3JvdGFza0RlYm91bmNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwidGFza0RlYm91bmNlIiwic2NoZWR1bGVkIiwic3VwcG9ydHNNaWNyb1Rhc2tzIiwiZGVib3VuY2UiLCJpc0Z1bmN0aW9uIiwiZnVuY3Rpb25Ub0NoZWNrIiwiZ2V0VHlwZSIsImdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSIsIm93bmVyRG9jdW1lbnQiLCJkZWZhdWx0VmlldyIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQYXJlbnROb2RlIiwibm9kZU5hbWUiLCJob3N0IiwiZ2V0U2Nyb2xsUGFyZW50IiwiYm9keSIsIl9nZXRTdHlsZUNvbXB1dGVkUHJvcCIsIm92ZXJmbG93Iiwib3ZlcmZsb3dYIiwib3ZlcmZsb3dZIiwiZ2V0UmVmZXJlbmNlTm9kZSIsInJlZmVyZW5jZSIsInJlZmVyZW5jZU5vZGUiLCJpc0lFMTEiLCJNU0lucHV0TWV0aG9kQ29udGV4dCIsImRvY3VtZW50TW9kZSIsImlzSUUxMCIsImlzSUUiLCJnZXRPZmZzZXRQYXJlbnQiLCJub09mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsIm5leHRFbGVtZW50U2libGluZyIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290Iiwibm9kZSIsImZpbmRDb21tb25PZmZzZXRQYXJlbnQiLCJlbGVtZW50MSIsImVsZW1lbnQyIiwib3JkZXIiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsIk5vZGUiLCJET0NVTUVOVF9QT1NJVElPTl9GT0xMT1dJTkciLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJ1cHBlclNpZGUiLCJodG1sIiwic2Nyb2xsaW5nRWxlbWVudCIsImluY2x1ZGVTY3JvbGwiLCJyZWN0Iiwic3VidHJhY3QiLCJzY3JvbGxUb3AiLCJzY3JvbGxMZWZ0IiwibW9kaWZpZXIiLCJ0b3AiLCJib3R0b20iLCJsZWZ0IiwicmlnaHQiLCJnZXRCb3JkZXJzU2l6ZSIsInN0eWxlcyIsImF4aXMiLCJzaWRlQSIsInNpZGVCIiwiZ2V0U2l6ZSIsImNvbXB1dGVkU3R5bGUiLCJtYXgiLCJnZXRXaW5kb3dTaXplcyIsImhlaWdodCIsIndpZHRoIiwiY2xhc3NDYWxsQ2hlY2siLCJpbnN0YW5jZSIsImNyZWF0ZUNsYXNzIiwiZGVmaW5lUHJvcGVydGllcyIsInByb3BzIiwiZGVzY3JpcHRvciIsImVudW1lcmFibGUiLCJjb25maWd1cmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnR5Iiwia2V5IiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJzb3VyY2UiLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsInJlc3VsdCIsInNpemVzIiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJob3JpelNjcm9sbGJhciIsIm9mZnNldFdpZHRoIiwidmVydFNjcm9sbGJhciIsImdldE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJiaXRyYXJ5Tm9kZSIsImZpeGVkUG9zaXRpb24iLCJpc0hUTUwiLCJjaGlsZHJlblJlY3QiLCJwYXJlbnRSZWN0Iiwic2Nyb2xsUGFyZW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlIiwiZXhjbHVkZVNjcm9sbCIsInJlbGF0aXZlT2Zmc2V0IiwiaW5uZXJXaWR0aCIsImlubmVySGVpZ2h0Iiwib2Zmc2V0IiwiaXNGaXhlZCIsImdldEZpeGVkUG9zaXRpb25PZmZzZXRQYXJlbnQiLCJwYXJlbnRFbGVtZW50IiwiZWwiLCJnZXRCb3VuZGFyaWVzIiwicG9wcGVyIiwicGFkZGluZyIsImJvdW5kYXJpZXNFbGVtZW50IiwiYm91bmRhcmllcyIsImJvdW5kYXJpZXNOb2RlIiwiX2dldFdpbmRvd1NpemVzIiwiaXNQYWRkaW5nTnVtYmVyIiwiZ2V0QXJlYSIsIl9yZWYiLCJjb21wdXRlQXV0b1BsYWNlbWVudCIsInBsYWNlbWVudCIsInJlZlJlY3QiLCJyZWN0cyIsInNvcnRlZEFyZWFzIiwia2V5cyIsIm1hcCIsImFyZWEiLCJzb3J0IiwiYSIsImIiLCJmaWx0ZXJlZEFyZWFzIiwiX3JlZjIiLCJjb21wdXRlZFBsYWNlbWVudCIsInZhcmlhdGlvbiIsImdldFJlZmVyZW5jZU9mZnNldHMiLCJzdGF0ZSIsImNvbW1vbk9mZnNldFBhcmVudCIsImdldE91dGVyU2l6ZXMiLCJ4IiwibWFyZ2luQm90dG9tIiwieSIsIm1hcmdpblJpZ2h0IiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJoYXNoIiwicmVwbGFjZSIsIm1hdGNoZWQiLCJnZXRQb3BwZXJPZmZzZXRzIiwicmVmZXJlbmNlT2Zmc2V0cyIsInBvcHBlclJlY3QiLCJwb3BwZXJPZmZzZXRzIiwiaXNIb3JpeiIsIm1haW5TaWRlIiwic2Vjb25kYXJ5U2lkZSIsIm1lYXN1cmVtZW50Iiwic2Vjb25kYXJ5TWVhc3VyZW1lbnQiLCJmaW5kIiwiYXJyIiwiY2hlY2siLCJBcnJheSIsImZpbmRJbmRleCIsInByb3AiLCJjdXIiLCJydW5Nb2RpZmllcnMiLCJtb2RpZmllcnMiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJmb3JFYWNoIiwiY29uc29sZSIsIndhcm4iLCJlbmFibGVkIiwidXBkYXRlIiwiaXNEZXN0cm95ZWQiLCJhcnJvd1N0eWxlcyIsImF0dHJpYnV0ZXMiLCJmbGlwcGVkIiwib3B0aW9ucyIsInBvc2l0aW9uRml4ZWQiLCJmbGlwIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJwb3NpdGlvbiIsImlzQ3JlYXRlZCIsIm9uQ3JlYXRlIiwib25VcGRhdGUiLCJpc01vZGlmaWVyRW5hYmxlZCIsIm1vZGlmaWVyTmFtZSIsInNvbWUiLCJuYW1lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwicHJlZml4ZXMiLCJ1cHBlclByb3AiLCJjaGFyQXQiLCJ0b0NoZWNrIiwiZGVzdHJveSIsInJlbW92ZUF0dHJpYnV0ZSIsIndpbGxDaGFuZ2UiLCJkaXNhYmxlRXZlbnRMaXN0ZW5lcnMiLCJyZW1vdmVPbkRlc3Ryb3kiLCJyZW1vdmVDaGlsZCIsImdldFdpbmRvdyIsImF0dGFjaFRvU2Nyb2xsUGFyZW50cyIsImNhbGxiYWNrIiwic2Nyb2xsUGFyZW50cyIsImlzQm9keSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwYXNzaXZlIiwic2V0dXBFdmVudExpc3RlbmVycyIsInVwZGF0ZUJvdW5kIiwic2Nyb2xsRWxlbWVudCIsImV2ZW50c0VuYWJsZWQiLCJlbmFibGVFdmVudExpc3RlbmVycyIsInNjaGVkdWxlVXBkYXRlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc051bWVyaWMiLCJuIiwiaXNOYU4iLCJpc0Zpbml0ZSIsInNldFN0eWxlcyIsInVuaXQiLCJzZXRBdHRyaWJ1dGVzIiwiYXBwbHlTdHlsZSIsImFycm93RWxlbWVudCIsImFwcGx5U3R5bGVPbkxvYWQiLCJtb2RpZmllck9wdGlvbnMiLCJnZXRSb3VuZGVkT2Zmc2V0cyIsInNob3VsZFJvdW5kIiwiX2RhdGEkb2Zmc2V0cyIsInJvdW5kIiwiZmxvb3IiLCJub1JvdW5kIiwidiIsInJlZmVyZW5jZVdpZHRoIiwicG9wcGVyV2lkdGgiLCJpc1ZlcnRpY2FsIiwiaXNWYXJpYXRpb24iLCJzYW1lV2lkdGhQYXJpdHkiLCJib3RoT2RkV2lkdGgiLCJob3Jpem9udGFsVG9JbnRlZ2VyIiwidmVydGljYWxUb0ludGVnZXIiLCJpc0ZpcmVmb3giLCJjb21wdXRlU3R5bGUiLCJsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24iLCJncHVBY2NlbGVyYXRpb24iLCJvZmZzZXRQYXJlbnRSZWN0IiwiZGV2aWNlUGl4ZWxSYXRpbyIsInByZWZpeGVkUHJvcGVydHkiLCJpbnZlcnRUb3AiLCJpbnZlcnRMZWZ0IiwiYXJyb3ciLCJpc01vZGlmaWVyUmVxdWlyZWQiLCJyZXF1ZXN0aW5nTmFtZSIsInJlcXVlc3RlZE5hbWUiLCJyZXF1ZXN0aW5nIiwiaXNSZXF1aXJlZCIsIl9yZXF1ZXN0aW5nIiwicmVxdWVzdGVkIiwiX2RhdGEkb2Zmc2V0cyRhcnJvdyIsInNpZGVDYXBpdGFsaXplZCIsImFsdFNpZGUiLCJvcFNpZGUiLCJhcnJvd0VsZW1lbnRTaXplIiwiY2VudGVyIiwicG9wcGVyTWFyZ2luU2lkZSIsInBvcHBlckJvcmRlclNpZGUiLCJzaWRlVmFsdWUiLCJtaW4iLCJnZXRPcHBvc2l0ZVZhcmlhdGlvbiIsInBsYWNlbWVudHMiLCJ2YWxpZFBsYWNlbWVudHMiLCJjbG9ja3dpc2UiLCJjb3VudGVyIiwiY29uY2F0IiwicmV2ZXJzZSIsIkJFSEFWSU9SUyIsIkZMSVAiLCJDTE9DS1dJU0UiLCJDT1VOVEVSQ0xPQ0tXSVNFIiwicGxhY2VtZW50T3Bwb3NpdGUiLCJmbGlwT3JkZXIiLCJiZWhhdmlvciIsInN0ZXAiLCJyZWZPZmZzZXRzIiwib3ZlcmxhcHNSZWYiLCJvdmVyZmxvd3NMZWZ0Iiwib3ZlcmZsb3dzUmlnaHQiLCJvdmVyZmxvd3NUb3AiLCJvdmVyZmxvd3NCb3R0b20iLCJvdmVyZmxvd3NCb3VuZGFyaWVzIiwiZmxpcHBlZFZhcmlhdGlvbkJ5UmVmIiwiZmxpcFZhcmlhdGlvbnMiLCJmbGlwcGVkVmFyaWF0aW9uQnlDb250ZW50IiwiZmxpcFZhcmlhdGlvbnNCeUNvbnRlbnQiLCJmbGlwcGVkVmFyaWF0aW9uIiwia2VlcFRvZ2V0aGVyIiwidG9WYWx1ZSIsInN0ciIsInNpemUiLCJwYXJzZU9mZnNldCIsImJhc2VQbGFjZW1lbnQiLCJ1c2VIZWlnaHQiLCJmcmFnbWVudHMiLCJmcmFnIiwiZGl2aWRlciIsInNlYXJjaCIsInNwbGl0UmVnZXgiLCJvcHMiLCJvcCIsIm1lcmdlV2l0aFByZXZpb3VzIiwicmVkdWNlIiwiaW5kZXgyIiwicHJldmVudE92ZXJmbG93IiwidHJhbnNmb3JtUHJvcCIsInBvcHBlclN0eWxlcyIsInRyYW5zZm9ybSIsInByaW9yaXR5IiwicHJpbWFyeSIsImVzY2FwZVdpdGhSZWZlcmVuY2UiLCJzZWNvbmRhcnkiLCJzaGlmdCIsInNoaWZ0dmFyaWF0aW9uIiwic2hpZnRPZmZzZXRzIiwiYm91bmQiLCJpbm5lciIsInN1YnRyYWN0TGVuZ3RoIiwib25Mb2FkIiwiRGVmYXVsdHMiLCJQb3BwZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGUkJDEiLCJkZXN0cm95JCQxIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEiLCJkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEiLCJVdGlscyIsImdsb2JhbCIsIlBvcHBlclV0aWxzIiwiRVNDQVBFX0tFWUNPREUiLCJTUEFDRV9LRVlDT0RFIiwiVEFCX0tFWUNPREUiLCJBUlJPV19VUF9LRVlDT0RFIiwiQVJST1dfRE9XTl9LRVlDT0RFIiwiUklHSFRfTU9VU0VfQlVUVE9OX1dISUNIIiwiUkVHRVhQX0tFWURPV04iLCJDTEFTU19OQU1FX0RJU0FCTEVEIiwiQ0xBU1NfTkFNRV9EUk9QVVAiLCJDTEFTU19OQU1FX0RST1BSSUdIVCIsIkNMQVNTX05BTUVfRFJPUExFRlQiLCJDTEFTU19OQU1FX01FTlVSSUdIVCIsIkNMQVNTX05BTUVfUE9TSVRJT05fU1RBVElDIiwiRVZFTlRfQ0xJQ0siLCJFVkVOVF9LRVlET1dOX0RBVEFfQVBJIiwiRVZFTlRfS0VZVVBfREFUQV9BUEkiLCJTRUxFQ1RPUl9GT1JNX0NISUxEIiwiU0VMRUNUT1JfTUVOVSIsIlNFTEVDVE9SX05BVkJBUl9OQVYiLCJTRUxFQ1RPUl9WSVNJQkxFX0lURU1TIiwiUExBQ0VNRU5UX1RPUCIsIlBMQUNFTUVOVF9UT1BFTkQiLCJQTEFDRU1FTlRfQk9UVE9NIiwiUExBQ0VNRU5UX0JPVFRPTUVORCIsIlBMQUNFTUVOVF9SSUdIVCIsIlBMQUNFTUVOVF9MRUZUIiwiYm91bmRhcnkiLCJkaXNwbGF5IiwicG9wcGVyQ29uZmlnIiwiRHJvcGRvd24iLCJfcG9wcGVyIiwiX21lbnUiLCJfZ2V0TWVudUVsZW1lbnQiLCJfaW5OYXZiYXIiLCJfZGV0ZWN0TmF2YmFyIiwiZGlzYWJsZWQiLCJpc0FjdGl2ZSIsIl9jbGVhck1lbnVzIiwidXNlUG9wcGVyIiwic2hvd0V2ZW50IiwiX2dldFBhcmVudEZyb21FbGVtZW50IiwicmVmZXJlbmNlRWxlbWVudCIsIl9nZXRQb3BwZXJDb25maWciLCJub29wIiwiaGlkZUV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwiY29uc3RydWN0b3IiLCJfZ2V0UGxhY2VtZW50IiwiJHBhcmVudERyb3Bkb3duIiwiX2dldE9mZnNldCIsInRvZ2dsZXMiLCJjb250ZXh0IiwiY2xpY2tFdmVudCIsImRyb3Bkb3duTWVudSIsIl9kYXRhQXBpS2V5ZG93bkhhbmRsZXIiLCJpdGVtcyIsIml0ZW0iLCJDTEFTU19OQU1FX1NDUk9MTEFCTEUiLCJDTEFTU19OQU1FX1NDUk9MTEJBUl9NRUFTVVJFUiIsIkNMQVNTX05BTUVfQkFDS0RST1AiLCJDTEFTU19OQU1FX09QRU4iLCJDTEFTU19OQU1FX1NUQVRJQyIsIkVWRU5UX0hJREVfUFJFVkVOVEVEIiwiRVZFTlRfRk9DVVNJTiIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX0NMSUNLX0RJU01JU1MiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MiLCJFVkVOVF9NT1VTRVVQX0RJU01JU1MiLCJFVkVOVF9NT1VTRURPV05fRElTTUlTUyIsIlNFTEVDVE9SX0RJQUxPRyIsIlNFTEVDVE9SX01PREFMX0JPRFkiLCJTRUxFQ1RPUl9EQVRBX0RJU01JU1MiLCJTRUxFQ1RPUl9GSVhFRF9DT05URU5UIiwiU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQiLCJiYWNrZHJvcCIsIk1vZGFsIiwiX2RpYWxvZyIsIl9iYWNrZHJvcCIsIl9pc1Nob3duIiwiX2lzQm9keU92ZXJmbG93aW5nIiwiX2lnbm9yZUJhY2tkcm9wQ2xpY2siLCJfc2Nyb2xsYmFyV2lkdGgiLCJfY2hlY2tTY3JvbGxiYXIiLCJfc2V0U2Nyb2xsYmFyIiwiX2FkanVzdERpYWxvZyIsIl9zZXRFc2NhcGVFdmVudCIsIl9zZXRSZXNpemVFdmVudCIsIl9zaG93QmFja2Ryb3AiLCJfc2hvd0VsZW1lbnQiLCJ0cmFuc2l0aW9uIiwiX2hpZGVNb2RhbCIsImh0bWxFbGVtZW50IiwiaGFuZGxlVXBkYXRlIiwiX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24iLCJoaWRlRXZlbnRQcmV2ZW50ZWQiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJzY3JvbGxIZWlnaHQiLCJtb2RhbFRyYW5zaXRpb25EdXJhdGlvbiIsIm1vZGFsQm9keSIsIkVMRU1FTlRfTk9ERSIsImFwcGVuZENoaWxkIiwiX2VuZm9yY2VGb2N1cyIsInNob3duRXZlbnQiLCJ0cmFuc2l0aW9uQ29tcGxldGUiLCJfdGhpczUiLCJoYXMiLCJfdGhpczYiLCJfdGhpczciLCJfdGhpczgiLCJfcmVzZXRBZGp1c3RtZW50cyIsIl9yZXNldFNjcm9sbGJhciIsIl9yZW1vdmVCYWNrZHJvcCIsImFuaW1hdGUiLCJjcmVhdGVFbGVtZW50IiwiY2xhc3NOYW1lIiwiYXBwZW5kVG8iLCJfdGhpczkiLCJiYWNrZHJvcFRyYW5zaXRpb25EdXJhdGlvbiIsImNhbGxiYWNrUmVtb3ZlIiwicGFkZGluZ0xlZnQiLCJwYWRkaW5nUmlnaHQiLCJfZ2V0U2Nyb2xsYmFyV2lkdGgiLCJmaXhlZENvbnRlbnQiLCJzdGlja3lDb250ZW50IiwiYWN0dWFsUGFkZGluZyIsImNhbGN1bGF0ZWRQYWRkaW5nIiwiX3RoaXMxMCIsImFjdHVhbE1hcmdpbiIsImNhbGN1bGF0ZWRNYXJnaW4iLCJlbGVtZW50cyIsIm1hcmdpbiIsInNjcm9sbERpdiIsInNjcm9sbGJhcldpZHRoIiwiX3RoaXMxMSIsInVyaUF0dHJzIiwiQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiIsIkRlZmF1bHRXaGl0ZWxpc3QiLCJiciIsImNvbCIsImNvZGUiLCJkaXYiLCJlbSIsImhyIiwiaDEiLCJoMiIsImgzIiwiaDQiLCJoNSIsImg2IiwiaW1nIiwibGkiLCJvbCIsInAiLCJwcmUiLCJzIiwic21hbGwiLCJzcGFuIiwic3ViIiwic3VwIiwic3Ryb25nIiwidSIsInVsIiwiU0FGRV9VUkxfUEFUVEVSTiIsIkRBVEFfVVJMX1BBVFRFUk4iLCJhbGxvd2VkQXR0cmlidXRlIiwiYWxsb3dlZEF0dHJpYnV0ZUxpc3QiLCJhdHRyTmFtZSIsIm5vZGVWYWx1ZSIsInJlZ0V4cCIsImF0dHJSZWdleCIsInNhbml0aXplSHRtbCIsInVuc2FmZUh0bWwiLCJ3aGl0ZUxpc3QiLCJzYW5pdGl6ZUZuIiwiZG9tUGFyc2VyIiwiRE9NUGFyc2VyIiwiY3JlYXRlZERvY3VtZW50IiwicGFyc2VGcm9tU3RyaW5nIiwid2hpdGVsaXN0S2V5cyIsImVsTmFtZSIsImF0dHJpYnV0ZUxpc3QiLCJ3aGl0ZWxpc3RlZEF0dHJpYnV0ZXMiLCJpbm5lckhUTUwiLCJDTEFTU19QUkVGSVgiLCJCU0NMU19QUkVGSVhfUkVHRVgiLCJESVNBTExPV0VEX0FUVFJJQlVURVMiLCJIT1ZFUl9TVEFURV9TSE9XIiwiSE9WRVJfU1RBVEVfT1VUIiwiU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiIsIlNFTEVDVE9SX0FSUk9XIiwiVFJJR0dFUl9IT1ZFUiIsIlRSSUdHRVJfRk9DVVMiLCJUUklHR0VSX0NMSUNLIiwiVFJJR0dFUl9NQU5VQUwiLCJBdHRhY2htZW50TWFwIiwiQVVUTyIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiTEVGVCIsImFuaW1hdGlvbiIsInRlbXBsYXRlIiwidGl0bGUiLCJkZWxheSIsImNvbnRhaW5lciIsImZhbGxiYWNrUGxhY2VtZW50IiwiY3VzdG9tQ2xhc3MiLCJzYW5pdGl6ZSIsIkhJREUiLCJISURERU4iLCJTSE9XIiwiU0hPV04iLCJJTlNFUlRFRCIsIkNMSUNLIiwiRk9DVVNJTiIsIkZPQ1VTT1VUIiwiTU9VU0VFTlRFUiIsIk1PVVNFTEVBVkUiLCJUb29sdGlwIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2hvdmVyU3RhdGUiLCJfYWN0aXZlVHJpZ2dlciIsInRpcCIsIl9zZXRMaXN0ZW5lcnMiLCJlbmFibGUiLCJkaXNhYmxlIiwidG9nZ2xlRW5hYmxlZCIsImRhdGFLZXkiLCJfZ2V0RGVsZWdhdGVDb25maWciLCJjbGljayIsIl9pc1dpdGhBY3RpdmVUcmlnZ2VyIiwiX2VudGVyIiwiX2xlYXZlIiwiZ2V0VGlwRWxlbWVudCIsIl9oaWRlTW9kYWxIYW5kbGVyIiwiaXNXaXRoQ29udGVudCIsInNoYWRvd1Jvb3QiLCJpc0luVGhlRG9tIiwidGlwSWQiLCJzZXRDb250ZW50IiwiYXR0YWNobWVudCIsIl9nZXRBdHRhY2htZW50IiwiYWRkQXR0YWNobWVudENsYXNzIiwiX2dldENvbnRhaW5lciIsIl9maXhUcmFuc2l0aW9uIiwicHJldkhvdmVyU3RhdGUiLCJfY2xlYW5UaXBDbGFzcyIsImdldFRpdGxlIiwic2V0RWxlbWVudENvbnRlbnQiLCJjb250ZW50IiwiZW1wdHkiLCJhcHBlbmQiLCJ0ZXh0IiwiZGVmYXVsdEJzQ29uZmlnIiwiX2hhbmRsZVBvcHBlclBsYWNlbWVudENoYW5nZSIsInRyaWdnZXJzIiwiZXZlbnRJbiIsImV2ZW50T3V0IiwiX2ZpeFRpdGxlIiwidGl0bGVUeXBlIiwiZGF0YUF0dHJpYnV0ZXMiLCJkYXRhQXR0ciIsIiR0aXAiLCJ0YWJDbGFzcyIsImpvaW4iLCJwb3BwZXJEYXRhIiwiaW5pdENvbmZpZ0FuaW1hdGlvbiIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIlBvcG92ZXIiLCJfZ2V0Q29udGVudCIsIkNMQVNTX05BTUVfRFJPUERPV05fSVRFTSIsIkVWRU5UX0FDVElWQVRFIiwiRVZFTlRfU0NST0xMIiwiTUVUSE9EX09GRlNFVCIsIk1FVEhPRF9QT1NJVElPTiIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9OQVZfTElOS1MiLCJTRUxFQ1RPUl9OQVZfSVRFTVMiLCJTRUxFQ1RPUl9MSVNUX0lURU1TIiwiU0VMRUNUT1JfRFJPUERPV04iLCJTRUxFQ1RPUl9EUk9QRE9XTl9JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSIsIm1ldGhvZCIsIlNjcm9sbFNweSIsIl9zY3JvbGxFbGVtZW50IiwiX29mZnNldHMiLCJfdGFyZ2V0cyIsIl9hY3RpdmVUYXJnZXQiLCJfc2Nyb2xsSGVpZ2h0IiwiX3Byb2Nlc3MiLCJyZWZyZXNoIiwiYXV0b01ldGhvZCIsIm9mZnNldE1ldGhvZCIsIm9mZnNldEJhc2UiLCJfZ2V0U2Nyb2xsVG9wIiwiX2dldFNjcm9sbEhlaWdodCIsInRhcmdldHMiLCJ0YXJnZXRTZWxlY3RvciIsInRhcmdldEJDUiIsInBhZ2VZT2Zmc2V0IiwiX2dldE9mZnNldEhlaWdodCIsIm1heFNjcm9sbCIsIl9hY3RpdmF0ZSIsIl9jbGVhciIsImlzQWN0aXZlVGFyZ2V0IiwicXVlcmllcyIsIiRsaW5rIiwicGFyZW50cyIsInNjcm9sbFNweXMiLCJzY3JvbGxTcHlzTGVuZ3RoIiwiJHNweSIsIkNMQVNTX05BTUVfRFJPUERPV05fTUVOVSIsIlNFTEVDVE9SX0FDVElWRV9VTCIsIlNFTEVDVE9SX0RST1BET1dOX0FDVElWRV9DSElMRCIsIlRhYiIsInByZXZpb3VzIiwibGlzdEVsZW1lbnQiLCJpdGVtU2VsZWN0b3IiLCJtYWtlQXJyYXkiLCJoaWRkZW5FdmVudCIsImFjdGl2ZUVsZW1lbnRzIiwiYWN0aXZlIiwiX3RyYW5zaXRpb25Db21wbGV0ZSIsImRyb3Bkb3duQ2hpbGQiLCJkcm9wZG93bkVsZW1lbnQiLCJkcm9wZG93blRvZ2dsZUxpc3QiLCIkdGhpcyIsIkNMQVNTX05BTUVfSElERSIsIkNMQVNTX05BTUVfU0hPV0lORyIsImF1dG9oaWRlIiwiVG9hc3QiLCJfY2xlYXJUaW1lb3V0IiwiX2Nsb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/adminlte/plugins/bootstrap/js/bootstrap.bundle.js\n");

/***/ }),

/***/ "./resources/css/app.css":
/*!*******************************!*\
  !*** ./resources/css/app.css ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvY3NzL2FwcC5jc3MuanMiLCJtYXBwaW5ncyI6IjtBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Nzcy9hcHAuY3NzP2E1ZTciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5leHBvcnQge307Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./resources/css/app.css\n");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/bootstrap.bundle": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunk"] = self["webpackChunk"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/adminlte/plugins/bootstrap/js/bootstrap.bundle.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/css/app.css")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;